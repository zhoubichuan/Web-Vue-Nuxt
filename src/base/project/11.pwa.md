---
lang: zh-CN
sidebarDepth: 0
meta:
  - name: description
    content: 个人总结的vuepress学习技术文档-主题
  - name: keywords
    content: vuepress,最新技术文档,vuepress主题
---

# 十一.组合

## 1.效果组合

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0x000, 1.0))
      webGLRenderer.setSize(window.innerWidth/2, window.innerHeight/2)
      webGLRenderer.shadowMapEnabled = true

      var sphere = createMesh(new THREE.SphereGeometry(10, 40, 40))
      // add the sphere to the scene
      scene.add(sphere)

      // position and point the camera to the center of the scene
      camera.position.x = -10
      camera.position.y = 15
      camera.position.z = 25

      camera.lookAt(new THREE.Vector3(0, 0, 0))

      var orbitControls = new THREE.OrbitControls(camera)
      orbitControls.autoRotate = false
      var clock = new THREE.Clock()

      var ambi = new THREE.AmbientLight(0x181818)
      scene.add(ambi)

      var spotLight = new THREE.DirectionalLight(0xffffff)
      spotLight.position.set(550, 100, 550)
      spotLight.intensity = 0.6

      scene.add(spotLight)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      var renderPass = new THREE.RenderPass(scene, camera)
      var effectFilm = new THREE.FilmPass(0.8, 0.325, 256, false)
      effectFilm.renderToScreen = true

      var composer = new THREE.EffectComposer(webGLRenderer)
      composer.addPass(renderPass)
      composer.addPass(effectFilm)

      // setup the control gui
      var controls = new (function () {
        this.scanlinesCount = 256
        this.grayscale = false
        this.scanlinesIntensity = 0.3
        this.noiseIntensity = 0.8

        this.updateEffectFilm = function () {
          effectFilm.uniforms.grayscale.value = controls.grayscale
          effectFilm.uniforms.nIntensity.value = controls.noiseIntensity
          effectFilm.uniforms.sIntensity.value = controls.scanlinesIntensity
          effectFilm.uniforms.sCount.value = controls.scanlinesCount
        }
      })()

      var gui = new dat.GUI()
      gui
        .add(controls, "scanlinesIntensity", 0, 1)
        .onChange(controls.updateEffectFilm)
      gui
        .add(controls, "noiseIntensity", 0, 3)
        .onChange(controls.updateEffectFilm)
      gui.add(controls, "grayscale").onChange(controls.updateEffectFilm)
      gui
        .add(controls, "scanlinesCount", 0, 2048)
        .step(1)
        .onChange(controls.updateEffectFilm)

      // call the render function
      var step = 0

      render()

      function createMesh(geom) {
        var planetTexture = THREE.ImageUtils.loadTexture(
          this.$withBase("/assets/textures/planets/Earth.png")
        )
        var specularTexture = THREE.ImageUtils.loadTexture(
          this.$withBase("/assets/textures/planets/EarthSpec.png")
        )
        var normalTexture = THREE.ImageUtils.loadTexture(
          this.$withBase("/assets/textures/planets/EarthNormal.png")
        )

        var planetMaterial = new THREE.MeshPhongMaterial()
        planetMaterial.specularMap = specularTexture
        planetMaterial.specular = new THREE.Color(0x4444aa)

        planetMaterial.normalMap = normalTexture
        planetMaterial.map = planetTexture
        //               planetMaterial.shininess = 150;

        // create a multimaterial
        var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [
          planetMaterial,
        ])

        return mesh
      }

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        //sphere.rotation.y=step+=0.01;
        var delta = clock.getDelta()
        orbitControls.update(delta)

        sphere.rotation.y += 0.002

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        //            webGLRenderer.render(scene, camera);
        composer.render(delta)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 2.简单传球

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0x000, 1.0))
      webGLRenderer.setSize(window.innerWidth/2, window.innerHeight/2)
      webGLRenderer.shadowMapEnabled = true

      var sphere = createMesh(new THREE.SphereGeometry(10, 40, 40))
      // add the sphere to the scene
      scene.add(sphere)

      // position and point the camera to the center of the scene
      camera.position.x = -10
      camera.position.y = 15
      camera.position.z = 25

      camera.lookAt(new THREE.Vector3(0, 0, 0))

      var orbitControls = new THREE.OrbitControls(camera)
      orbitControls.autoRotate = false
      var clock = new THREE.Clock()

      var ambi = new THREE.AmbientLight(0x686868)
      scene.add(ambi)

      var spotLight = new THREE.DirectionalLight(0xffffff)
      spotLight.position.set(550, 100, 550)
      spotLight.intensity = 0.6

      scene.add(spotLight)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      var renderPass = new THREE.RenderPass(scene, camera)
      var effectCopy = new THREE.ShaderPass(THREE.CopyShader)
      effectCopy.renderToScreen = true

      var bloomPass = new THREE.BloomPass(3, 25, 5.0, 256)
      var effectFilm = new THREE.FilmPass(0.8, 0.325, 256, false)
      effectFilm.renderToScreen = true

      var dotScreenPass = new THREE.DotScreenPass()

      // basic renderer that renders the scene, and uses the
      // effectCopy shader to output the image to the defined
      // rendertarget.
      var composer = new THREE.EffectComposer(webGLRenderer)
      composer.addPass(renderPass)
      composer.addPass(effectCopy)

      // we use a texture pass to pass the rendered output to
      // a texture, so we can reuse it
      var renderScene = new THREE.TexturePass(composer.renderTarget2)

      // lower left corner
      var composer1 = new THREE.EffectComposer(webGLRenderer)
      composer1.addPass(renderScene)
      composer1.addPass(dotScreenPass)
      composer1.addPass(effectCopy)

      // lower right corner
      var composer2 = new THREE.EffectComposer(webGLRenderer)
      composer2.addPass(renderScene)
      composer2.addPass(effectCopy)

      // upper left corner
      var composer3 = new THREE.EffectComposer(webGLRenderer)
      composer3.addPass(renderScene)
      composer3.addPass(bloomPass)
      composer3.addPass(effectCopy)

      // upper right corner
      var composer4 = new THREE.EffectComposer(webGLRenderer)
      composer4.addPass(renderScene)
      composer4.addPass(effectFilm)

      // setup the control gui
      var controls = new (function () {
        // film
        this.scanlinesCount = 256
        this.grayscale = false
        this.scanlinesIntensity = 0.3
        this.noiseIntensity = 0.8

        // bloompass
        this.strength = 3
        this.kernelSize = 25
        this.sigma = 5.0
        this.resolution = 256

        // dotscreen
        this.centerX = 0.5
        this.centerY = 0.5
        this.angle = 1.57
        this.scale = 1

        this.updateEffectFilm = function () {
          effectFilm.uniforms.grayscale.value = controls.grayscale
          effectFilm.uniforms.nIntensity.value = controls.noiseIntensity
          effectFilm.uniforms.sIntensity.value = controls.scanlinesIntensity
          effectFilm.uniforms.sCount.value = controls.scanlinesCount
        }

        this.updateDotScreen = function () {
          var dotScreenPass = new THREE.DotScreenPass(
            new THREE.Vector2(controls.centerX, controls.centerY),
            controls.angle,
            controls.scale
          )

          composer1 = new THREE.EffectComposer(webGLRenderer)
          composer1.addPass(renderScene)
          composer1.addPass(dotScreenPass)
          composer1.addPass(effectCopy)
        }

        this.updateEffectBloom = function () {
          bloomPass = new THREE.BloomPass(
            controls.strength,
            controls.kernelSize,
            controls.sigma,
            controls.resolution
          )
          composer3 = new THREE.EffectComposer(webGLRenderer)
          composer3.addPass(renderScene)
          composer3.addPass(bloomPass)
          composer3.addPass(effectCopy)
        }
      })()

      var gui = new dat.GUI()

      var bpFolder = gui.addFolder("BloomPass")
      bpFolder
        .add(controls, "strength", 1, 10)
        .onChange(controls.updateEffectBloom)
      bpFolder
        .add(controls, "kernelSize", 1, 100)
        .onChange(controls.updateEffectBloom)
      bpFolder
        .add(controls, "sigma", 1, 10)
        .onChange(controls.updateEffectBloom)
      bpFolder
        .add(controls, "resolution", 0, 1024)
        .onChange(controls.updateEffectBloom)

      var fpFolder = gui.addFolder("FilmPass")
      fpFolder
        .add(controls, "scanlinesIntensity", 0, 1)
        .onChange(controls.updateEffectFilm)
      fpFolder
        .add(controls, "noiseIntensity", 0, 3)
        .onChange(controls.updateEffectFilm)
      fpFolder.add(controls, "grayscale").onChange(controls.updateEffectFilm)
      fpFolder
        .add(controls, "scanlinesCount", 0, 2048)
        .step(1)
        .onChange(controls.updateEffectFilm)

      var dsFolder = gui.addFolder("DotScreenPass")
      dsFolder.add(controls, "centerX", 0, 1).onChange(controls.updateDotScreen)
      dsFolder.add(controls, "centerY", 0, 1).onChange(controls.updateDotScreen)
      dsFolder
        .add(controls, "angle", 0, 3.14)
        .onChange(controls.updateDotScreen)
      dsFolder.add(controls, "scale", 0, 10).onChange(controls.updateDotScreen)

      // call the render function
      var step = 0

      render()

      function createMesh(geom) {
        var planetTexture = THREE.ImageUtils.loadTexture(
          this.$withBase("/assets/textures/planets/Earth.png")
        )
        var specularTexture = THREE.ImageUtils.loadTexture(
          this.$withBase("/assets/textures/planets/EarthSpec.png")
        )
        var normalTexture = THREE.ImageUtils.loadTexture(
          this.$withBase("/assets/textures/planets/EarthNormal.png")
        )

        var planetMaterial = new THREE.MeshPhongMaterial()
        planetMaterial.specularMap = specularTexture
        planetMaterial.specular = new THREE.Color(0x4444aa)

        planetMaterial.normalMap = normalTexture
        planetMaterial.map = planetTexture
        //               planetMaterial.shininess = 150;

        // create a multimaterial
        var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [
          planetMaterial,
        ])

        return mesh
      }

      var width = window.innerWidth || 2
      var height = window.innerHeight || 2

      var halfWidth = width / 2
      var halfHeight = height / 2

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        //sphere.rotation.y=step+=0.01;
        var delta = clock.getDelta()
        orbitControls.update(delta)

        sphere.rotation.y += 0.002

        // render using requestAnimationFrame
        requestAnimationFrame(render)

        webGLRenderer.autoClear = false
        webGLRenderer.clear()

        webGLRenderer.setViewport(0, 0, 2 * halfWidth, 2 * halfHeight)
        composer.render(delta)

        webGLRenderer.setViewport(0, 0, halfWidth, halfHeight)
        composer1.render(delta)

        webGLRenderer.setViewport(halfWidth, 0, halfWidth, halfHeight)
        composer2.render(delta)

        webGLRenderer.setViewport(0, halfHeight, halfWidth, halfHeight)
        composer3.render(delta)

        webGLRenderer.setViewport(halfWidth, halfHeight, halfWidth, halfHeight)
        composer4.render(delta)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 3.效果组合

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0x000, 1.0))
      webGLRenderer.setSize(window.innerWidth/2, window.innerHeight/2)
      webGLRenderer.shadowMapEnabled = true

      var sphere = createMesh(new THREE.SphereGeometry(10, 40, 40))
      // add the sphere to the scene
      scene.add(sphere)

      // position and point the camera to the center of the scene
      camera.position.x = -10
      camera.position.y = 15
      camera.position.z = 25

      camera.lookAt(new THREE.Vector3(0, 0, 0))

      var orbitControls = new THREE.OrbitControls(camera)
      orbitControls.autoRotate = false
      var clock = new THREE.Clock()

      var ambi = new THREE.AmbientLight(0x181818)
      scene.add(ambi)

      var spotLight = new THREE.DirectionalLight(0xffffff)
      spotLight.position.set(550, 100, 550)
      spotLight.intensity = 0.6

      scene.add(spotLight)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      var renderPass = new THREE.RenderPass(scene, camera)

      var effectGlitch = new THREE.GlitchPass(64)
      effectGlitch.renderToScreen = true

      var composer = new THREE.EffectComposer(webGLRenderer)
      composer.addPass(renderPass)
      composer.addPass(effectGlitch)

      // setup the control gui
      var controls = new (function () {
        this.goWild = false
        this.updateEffect = function () {
          effectGlitch.goWild = controls.goWild
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "goWild").onChange(controls.updateEffect)

      // call the render function
      var step = 0

      render()

      function createMesh(geom) {
        var planetTexture = THREE.ImageUtils.loadTexture(
          this.$withBase("/assets/textures/planets/Earth.png")
        )
        var specularTexture = THREE.ImageUtils.loadTexture(
          this.$withBase("/assets/textures/planets/EarthSpec.png")
        )
        var normalTexture = THREE.ImageUtils.loadTexture(
          this.$withBase("/assets/textures/planets/EarthNormal.png")
        )

        var planetMaterial = new THREE.MeshPhongMaterial()
        planetMaterial.specularMap = specularTexture
        planetMaterial.specular = new THREE.Color(0x4444aa)

        planetMaterial.normalMap = normalTexture
        planetMaterial.map = planetTexture

        // create a multimaterial
        var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [
          planetMaterial,
        ])

        return mesh
      }

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        //sphere.rotation.y=step+=0.01;
        var delta = clock.getDelta()
        orbitControls.update(delta)

        sphere.rotation.y += 0.002

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        composer.render(delta)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 4.后处理掩模

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var sceneEarth = new THREE.Scene()
      var sceneMars = new THREE.Scene()
      var sceneBG = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )
      var cameraBG = new THREE.OrthographicCamera(
        -window.innerWidth,
        window.innerWidth,
        window.innerHeight,
        -window.innerHeight,
        -10000,
        10000
      )
      cameraBG.position.z = 50

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0x000, 1.0))
      webGLRenderer.setSize(window.innerWidth/2, window.innerHeight/2)
      webGLRenderer.shadowMapEnabled = true

      var sphere = createEarthMesh(new THREE.SphereGeometry(10, 40, 40))
      sphere.position.x = -10
      var sphere2 = createMarshMesh(new THREE.SphereGeometry(5, 40, 40))
      sphere2.position.x = 10
      sceneEarth.add(sphere)
      sceneMars.add(sphere2)

      // position and point the camera to the center of the scene
      camera.position.x = -10
      camera.position.y = 15
      camera.position.z = 25

      camera.lookAt(new THREE.Vector3(0, 0, 0))

      var orbitControls = new THREE.OrbitControls(camera)
      orbitControls.autoRotate = false
      var clock = new THREE.Clock()

      var ambi = new THREE.AmbientLight(0x181818)
      var ambi2 = new THREE.AmbientLight(0x181818)
      sceneEarth.add(ambi)
      sceneMars.add(ambi2)

      var spotLight = new THREE.DirectionalLight(0xffffff)
      spotLight.position.set(550, 100, 550)
      spotLight.intensity = 0.6

      var spotLight2 = new THREE.DirectionalLight(0xffffff)
      spotLight.position.set(550, 100, 550)
      spotLight.intensity = 0.6

      sceneEarth.add(spotLight)
      sceneMars.add(spotLight2)

      var materialColor = new THREE.MeshBasicMaterial({
        map: THREE.ImageUtils.loadTexture(
          this.$withBase("/assets/textures/starry-deep-outer-space-galaxy.jpg")
        ),
        depthTest: false,
      })
      var bgPlane = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), materialColor)
      bgPlane.position.z = -100
      bgPlane.scale.set(window.innerWidth * 2, window.innerHeight * 2, 1)
      sceneBG.add(bgPlane)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      var bgPass = new THREE.RenderPass(sceneBG, cameraBG)
      var renderPass = new THREE.RenderPass(sceneEarth, camera)
      renderPass.clear = false
      var renderPass2 = new THREE.RenderPass(sceneMars, camera)
      renderPass2.clear = false

      var effectCopy = new THREE.ShaderPass(THREE.CopyShader)
      effectCopy.renderToScreen = true

      var clearMask = new THREE.ClearMaskPass()
      // earth mask
      var earthMask = new THREE.MaskPass(sceneEarth, camera)
      //        earthMask.inverse = true;
      // mars mask
      var marsMask = new THREE.MaskPass(sceneMars, camera)
      //        marsMask.inverse = true;

      var effectSepia = new THREE.ShaderPass(THREE.SepiaShader)
      effectSepia.uniforms["amount"].value = 0.8

      var effectColorify = new THREE.ShaderPass(THREE.ColorifyShader)
      effectColorify.uniforms["color"].value.setRGB(0.5, 0.5, 1)

      var composer = new THREE.EffectComposer(webGLRenderer)
      composer.renderTarget1.stencilBuffer = true
      composer.renderTarget2.stencilBuffer = true

      composer.addPass(bgPass)
      composer.addPass(renderPass)
      composer.addPass(renderPass2)
      composer.addPass(marsMask)
      composer.addPass(effectColorify)
      composer.addPass(clearMask)
      composer.addPass(earthMask)
      composer.addPass(effectSepia)
      composer.addPass(clearMask)
      composer.addPass(effectCopy)

      render()

      function createMarshMesh(geom) {
        var planetTexture = THREE.ImageUtils.loadTexture(
          this.$withBase("/assets/textures/planets/Mars_2k-050104.png")
        )
        var normalTexture = THREE.ImageUtils.loadTexture(
          this.$withBase("/assets/textures/planets/Mars-normalmap_2k.png")
        )

        var planetMaterial = new THREE.MeshPhongMaterial()
        planetMaterial.normalMap = normalTexture
        planetMaterial.map = planetTexture
        //               planetMaterial.shininess = 150;

        // create a multimaterial
        var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [
          planetMaterial,
        ])

        return mesh
      }

      function createEarthMesh(geom) {
        var planetTexture = THREE.ImageUtils.loadTexture(
          this.$withBase("/assets/textures/planets/Earth.png")
        )
        var specularTexture = THREE.ImageUtils.loadTexture(
          this.$withBase("/assets/textures/planets/EarthSpec.png")
        )
        var normalTexture = THREE.ImageUtils.loadTexture(
          this.$withBase("/assets/textures/planets/EarthNormal.png")
        )

        var planetMaterial = new THREE.MeshPhongMaterial()
        planetMaterial.specularMap = specularTexture
        planetMaterial.specular = new THREE.Color(0x4444aa)

        planetMaterial.normalMap = normalTexture
        planetMaterial.map = planetTexture
        //               planetMaterial.shininess = 150;

        // create a multimaterial
        var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [
          planetMaterial,
        ])

        return mesh
      }

      function render() {
        webGLRenderer.autoClear = false

        stats.update()

        //sphere.rotation.y=step+=0.01;
        var delta = clock.getDelta()
        orbitControls.update(delta)

        sphere.rotation.y += 0.002
        sphere2.rotation.y += 0.002

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        //            webGLRenderer.render(scene, camera);
        composer.render(delta)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 5.着色器传递简单

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xaaaaff, 1.0))
      webGLRenderer.setSize(window.innerWidth/2, window.innerHeight/2)
      webGLRenderer.shadowMapEnabled = true

      //        // position and point the camera to the center of the scene
      camera.position.x = 20
      camera.position.y = 30
      camera.position.z = 40
      camera.lookAt(new THREE.Vector3(-15, -10, -25))

      // add spotlight for the shadows
      var spotLight = new THREE.SpotLight(0xffffff)
      spotLight.castShadow = true
      spotLight.position.set(0, 60, 50)
      spotLight.intensity = 1
      spotLight.shadowMapWidth = 2048
      spotLight.shadowMapHeight = 2048
      spotLight.shadowCameraFov = 120
      spotLight.shadowCameraNear = 1
      spotLight.shadowCameraFar = 1000

      var ambiLight = new THREE.AmbientLight(0x444444)
      scene.add(ambiLight)

      scene.add(spotLight)
      var plane = new THREE.BoxGeometry(1600, 1600, 0.1, 40, 40)

      var cube = new THREE.Mesh(
        plane,
        new THREE.MeshPhongMaterial({
          color: 0xffffff,
          map: THREE.ImageUtils.loadTexture(
            this.$withBase("/assets/textures/general/plaster-diffuse.jpg")
          ),
          normalMap: THREE.ImageUtils.loadTexture(
            this.$withBase("/assets/textures/general/plaster-normal.jpg")
          ),
          normalScale: new THREE.Vector2(0.6, 0.6),
        })
      )
      cube.material.map.wrapS = THREE.RepeatWrapping
      cube.material.map.wrapT = THREE.RepeatWrapping
      cube.material.normalMap.wrapS = THREE.RepeatWrapping
      cube.material.normalMap.wrapT = THREE.RepeatWrapping
      cube.rotation.x = Math.PI / 2
      cube.material.map.repeat.set(80, 80)

      cube.receiveShadow = true
      cube.position.z = -150
      cube.position.x = -150
      scene.add(cube)

      var cube1 = new THREE.Mesh(
        new THREE.BoxGeometry(30, 10, 2),
        new THREE.MeshPhongMaterial({ color: 0xff0000 })
      )
      cube1.position.x = -15
      cube1.position.y = 5
      cube1.position.z = 15
      cube1.castShadow = true
      scene.add(cube1)

      var cube2 = cube1.clone()
      cube2.material = cube1.material.clone()
      cube2.material.color = new THREE.Color(0x00ff00)
      cube2.position.z = 5
      cube2.position.x = -20
      scene.add(cube2)

      var cube3 = cube1.clone()
      cube3.material = cube1.material.clone()
      cube3.material.color = new THREE.Color(0x0000ff)
      cube3.position.z = -8
      cube3.position.x = -25
      scene.add(cube3)

      var mesh

      // add the output of the renderer to the html element

      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      var loader = new THREE.OBJMTLLoader()
      loader.load(
        this.$withBase("/assets/models/sol/libertStatue.obj"),
        this.$withBase("/assets/models/sol/libertStatue.mtl"),
        function (event) {
          var object = event

          // fix for incorrect uvs.
          console.log(event)
          var geom = object.children[0].geometry
          var uv3 = geom.faceVertexUvs[0][0]
          var uv4 = geom.faceVertexUvs[0][10]

          // fill in the missing ones
          for (var j = 0; j < 7616 - 7206; j++) {
            if (geom.faces[j + 7206] instanceof THREE.Face4) {
              geom.faceVertexUvs[0].push(uv4)
            } else {
              geom.faceVertexUvs[0].push(uv4)
            }
          }

          object.children.forEach(function (e) {
            e.castShadow = true
          })

          object.scale.set(20, 20, 20)
          mesh = object
          mesh.position.x = 15
          mesh.position.z = 5
          scene.add(object)
        }
      )

      var mirror = new THREE.ShaderPass(THREE.MirrorShader)
      mirror.enabled = false

      var hue = new THREE.ShaderPass(THREE.HueSaturationShader)
      hue.enabled = false

      var vignette = new THREE.ShaderPass(THREE.VignetteShader)
      vignette.enabled = false

      var colorCorrection = new THREE.ShaderPass(THREE.ColorCorrectionShader)
      colorCorrection.enabled = false
      var rgbShift = new THREE.ShaderPass(THREE.RGBShiftShader)
      rgbShift.enabled = false

      var brightness = new THREE.ShaderPass(THREE.BrightnessContrastShader)
      brightness.uniforms.brightness.value = 0
      brightness.uniforms.contrast.value = 0
      brightness.enabled = false
      brightness.uniforms.brightness.value = 0
      brightness.uniforms.contrast.value = 0

      var colorify = new THREE.ShaderPass(THREE.ColorifyShader)
      colorify.uniforms.color.value = new THREE.Color(0xffffff)
      colorify.enabled = false

      var sepia = new THREE.ShaderPass(THREE.SepiaShader)
      sepia.uniforms.amount.value = 1
      sepia.enabled = false

      var kal = new THREE.ShaderPass(THREE.KaleidoShader)
      kal.enabled = false

      var lum = new THREE.ShaderPass(THREE.LuminosityShader)
      lum.enabled = false

      var techni = new THREE.ShaderPass(THREE.TechnicolorShader)
      techni.enabled = false

      var unpack = new THREE.ShaderPass(THREE.UnpackDepthRGBAShader)
      unpack.enabled = false

      var renderPass = new THREE.RenderPass(scene, camera)
      var effectCopy = new THREE.ShaderPass(THREE.CopyShader)
      effectCopy.renderToScreen = true

      var composer = new THREE.EffectComposer(webGLRenderer)
      composer.addPass(renderPass)
      composer.addPass(brightness)
      composer.addPass(sepia)
      composer.addPass(mirror)
      composer.addPass(colorify)
      composer.addPass(colorCorrection)
      composer.addPass(rgbShift)
      composer.addPass(vignette)
      composer.addPass(hue)
      composer.addPass(kal)
      composer.addPass(lum)
      composer.addPass(techni)
      composer.addPass(unpack)
      composer.addPass(effectCopy)

      var controls = new (function () {
        this.brightness = 0.01
        this.contrast = 0.01
        this.select = "none"
        this.color = 0xffffff
        this.amount = 1
        this.powRGB_R = 2
        this.mulRGB_R = 1
        this.powRGB_G = 2
        this.mulRGB_G = 1
        this.powRGB_B = 2
        this.mulRGB_B = 1
        this.rgbAmount = 0.005
        this.angle = 0.0
        this.side = 1
        this.offset = 1
        this.darkness = 1
        this.hue = 0.01
        this.saturation = 0.01
        this.kalAngle = 0
        this.kalSides = 6

        this.rotate = false

        this.switchShader = function () {
          switch (controls.select) {
            case "none": {
              enableShader()
              break
            }

            case "colorify": {
              enableShader(colorify)
              break
            }

            case "brightness": {
              enableShader(brightness)
              break
            }

            case "sepia": {
              enableShader(sepia)
              break
            }

            case "colorCorrection": {
              enableShader(colorCorrection)
              break
            }

            case "rgbShift": {
              enableShader(rgbShift)
              break
            }

            case "mirror": {
              enableShader(mirror)
              break
            }

            case "vignette": {
              enableShader(vignette)
              break
            }

            case "hueAndSaturation": {
              enableShader(hue)
              break
            }

            case "kaleidoscope": {
              enableShader(kal)
              break
            }
            case "luminosity": {
              enableShader(lum)
              break
            }
            case "technicolor": {
              enableShader(techni)
              break
            }
            case "unpackDepth": {
              enableShader(unpack)
              break
            }
          }
        }

        this.changeBrightness = function () {
          brightness.uniforms.brightness.value = controls.brightness
          brightness.uniforms.contrast.value = controls.contrast
        }

        this.changeColor = function () {
          colorify.uniforms.color.value = new THREE.Color(controls.color)
        }

        this.changeSepia = function () {
          sepia.uniforms.amount.value = controls.amount
        }

        this.changeCorrection = function () {
          colorCorrection.uniforms.mulRGB.value = new THREE.Vector3(
            controls.mulRGB_R,
            controls.mulRGB_G,
            controls.mulRGB_B
          )
          colorCorrection.uniforms.powRGB.value = new THREE.Vector3(
            controls.powRGB_R,
            controls.powRGB_G,
            controls.powRGB_B
          )
        }

        this.changeRGBShifter = function () {
          rgbShift.uniforms.amount.value = controls.rgbAmount
          rgbShift.uniforms.angle.value = controls.angle
        }

        this.changeMirror = function () {
          mirror.uniforms.side.value = controls.side
        }

        this.changeVignette = function () {
          vignette.uniforms.darkness.value = controls.darkness
          vignette.uniforms.offset.value = controls.offset
        }

        this.changeHue = function () {
          hue.uniforms.hue.value = controls.hue
          hue.uniforms.saturation.value = controls.saturation
        }

        this.changeKal = function () {
          kal.uniforms.sides.value = controls.kalSides
          kal.uniforms.angle.value = controls.kalAngle
        }

        function enableShader(shader) {
          // we're not interested in the first or the last one
          for (var i = 1; i < composer.passes.length - 1; i++) {
            if (composer.passes[i] == shader) {
              composer.passes[i].enabled = true
            } else {
              composer.passes[i].enabled = false
            }
          }
        }
      })()

      var gui = new dat.GUI()

      gui
        .add(controls, "select", [
          "none",
          "colorify",
          "brightness",
          "sepia",
          "colorCorrection",
          "rgbShift",
          "mirror",
          "vignette",
          "hueAndSaturation",
          "kaleidoscope",
          "luminosity",
          "technicolor",
        ])
        .onChange(controls.switchShader)
      gui.add(controls, "rotate")

      var bnFolder = gui.addFolder("Brightness")
      bnFolder
        .add(controls, "brightness", -1, 1)
        .onChange(controls.changeBrightness)
      bnFolder
        .add(controls, "contrast", -1, 1)
        .onChange(controls.changeBrightness)

      var clFolder = gui.addFolder("Colorify")
      clFolder.addColor(controls, "color").onChange(controls.changeColor)

      var colFolder = gui.addFolder("Color Correction")
      colFolder
        .add(controls, "powRGB_R", 0, 5)
        .onChange(controls.changeCorrection)
      colFolder
        .add(controls, "powRGB_G", 0, 5)
        .onChange(controls.changeCorrection)
      colFolder
        .add(controls, "powRGB_B", 0, 5)
        .onChange(controls.changeCorrection)
      colFolder
        .add(controls, "mulRGB_R", 0, 5)
        .onChange(controls.changeCorrection)
      colFolder
        .add(controls, "mulRGB_G", 0, 5)
        .onChange(controls.changeCorrection)
      colFolder
        .add(controls, "mulRGB_B", 0, 5)
        .onChange(controls.changeCorrection)

      var sepiaFolder = gui.addFolder("Sepia")
      sepiaFolder
        .add(controls, "amount", 0, 2)
        .step(0.1)
        .onChange(controls.changeSepia)

      var shiftFolder = gui.addFolder("RGB Shift")
      shiftFolder
        .add(controls, "rgbAmount", 0, 0.1)
        .step(0.001)
        .onChange(controls.changeRGBShifter)
      shiftFolder
        .add(controls, "angle", 0, 3.14)
        .step(0.001)
        .onChange(controls.changeRGBShifter)

      var mirrorFolder = gui.addFolder("mirror")
      mirrorFolder
        .add(controls, "side", 0, 3)
        .step(1)
        .onChange(controls.changeMirror)

      var vignetteFolder = gui.addFolder("vignette")
      vignetteFolder
        .add(controls, "darkness", 0, 2)
        .onChange(controls.changeVignette)
      vignetteFolder
        .add(controls, "offset", 0, 2)
        .onChange(controls.changeVignette)

      var hueAndSat = gui.addFolder("hue and saturation")
      hueAndSat
        .add(controls, "hue", -1, 1)
        .step(0.01)
        .onChange(controls.changeHue)
      hueAndSat
        .add(controls, "saturation", -1, 1)
        .step(0.01)
        .onChange(controls.changeHue)

      var kalMenu = gui.addFolder("Kaleidoscope")
      kalMenu
        .add(controls, "kalAngle", -2 * Math.PI, 2 * Math.PI)
        .onChange(controls.changeKal)
      kalMenu.add(controls, "kalSides", 2, 20).onChange(controls.changeKal)

      render()

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        //
        if (controls.rotate) {
          if (mesh) mesh.rotation.y += 0.01
          cube1.rotation.y += 0.01
          cube2.rotation.y += 0.01
          cube3.rotation.y += 0.01
        }

        requestAnimationFrame(render)
        //        webGLRenderer.render(scene, camera);
        composer.render()
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 6.着色器类模糊

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var scale = chroma.scale(["white", "blue"])

      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xaaaaff, 1.0))
      webGLRenderer.setSize(window.innerWidth/2, window.innerHeight/2)
      webGLRenderer.shadowMapEnabled = true

      //        // position and point the camera to the center of the scene
      camera.position.x = 30
      camera.position.y = 30
      camera.position.z = 30
      camera.lookAt(new THREE.Vector3(0, 0, 0))

      var dirLight = new THREE.DirectionalLight(0xffffff)
      dirLight.position.set(30, 30, 30)
      dirLight.intensity = 0.8
      scene.add(dirLight)

      // add spotlight for the shadows
      var spotLight = new THREE.SpotLight(0xffffff)
      spotLight.castShadow = true
      spotLight.position.set(-30, 30, -100)
      spotLight.target.position.x = -10
      spotLight.target.position.z = -10
      spotLight.intensity = 0.6
      spotLight.shadowMapWidth = 4096
      spotLight.shadowMapHeight = 4096
      spotLight.shadowCameraFov = 120
      spotLight.shadowCameraNear = 1
      spotLight.shadowCameraFar = 200

      scene.add(spotLight)
      var plane = new THREE.BoxGeometry(1600, 1600, 0.1, 40, 40)

      var cube = new THREE.Mesh(
        plane,
        new THREE.MeshPhongMaterial({
          color: 0xffffff,
          map: THREE.ImageUtils.loadTexture(
            this.$withBase("/assets/textures/general/floor-wood.jpg")
          ),
          normalScale: new THREE.Vector2(0.6, 0.6),
        })
      )
      cube.material.map.wrapS = THREE.RepeatWrapping
      cube.material.map.wrapT = THREE.RepeatWrapping

      cube.rotation.x = Math.PI / 2
      cube.material.map.repeat.set(80, 80)

      cube.receiveShadow = true
      cube.position.z = -150
      cube.position.x = -150
      scene.add(cube)

      var range = 3
      var stepX = 8
      var stepZ = 8
      for (var i = -25; i < 5; i++) {
        for (var j = -15; j < 15; j++) {
          var cube = new THREE.Mesh(
            new THREE.BoxGeometry(3, 4, 3),
            new THREE.MeshPhongMaterial({
              color: scale(Math.random()).hex(),
              opacity: 0.8,
              transparent: true,
            })
          )
          cube.position.x = i * stepX + (Math.random() - 0.5) * range
          cube.position.z = j * stepZ + (Math.random() - 0.5) * range
          cube.position.y = (Math.random() - 0.5) * 2
          cube.castShadow = true
          scene.add(cube)
        }
      }

      // add the output of the renderer to the html element

      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      var hBlur = new THREE.ShaderPass(THREE.HorizontalBlurShader)
      hBlur.enabled = false
      hBlur.uniforms.h.value = 1 / window.innerHeight
      var vBlur = new THREE.ShaderPass(THREE.VerticalBlurShader)
      vBlur.enabled = false
      vBlur.uniforms.v.value = 1 / window.innerWidth

      var hTilt = new THREE.ShaderPass(THREE.HorizontalTiltShiftShader)
      hTilt.enabled = false
      hTilt.uniforms.h.value = 1 / window.innerHeight
      var vTilt = new THREE.ShaderPass(THREE.VerticalTiltShiftShader)
      vTilt.enabled = false
      vTilt.uniforms.v.value = 1 / window.innerWidth

      var tri = new THREE.ShaderPass(THREE.TriangleBlurShader, "texture")
      tri.enabled = false

      var renderPass = new THREE.RenderPass(scene, camera)
      var effectCopy = new THREE.ShaderPass(THREE.CopyShader)
      effectCopy.renderToScreen = true

      var composer = new THREE.EffectComposer(webGLRenderer)
      composer.addPass(renderPass)
      composer.addPass(hBlur)
      composer.addPass(vBlur)
      composer.addPass(vTilt)
      composer.addPass(hTilt)
      composer.addPass(tri)
      composer.addPass(effectCopy)

      var controls = new (function () {
        this.hBlur = false
        this.vBlur = false
        this.hTilt = false
        this.vTilt = false
        this.triBlur = false

        this.hTiltR = 0.35
        this.vTiltR = 0.35

        this.deltaX = 0.05
        this.deltaY = 0.05

        this.onChange = function () {
          hBlur.enabled = controls.hBlur
          vBlur.enabled = controls.vBlur

          hTilt.enabled = controls.hTilt
          hTilt.uniforms.r.value = controls.hTiltR
          vTilt.enabled = controls.vTilt
          vTilt.uniforms.r.value = controls.vTiltR

          tri.enabled = controls.triBlur
          tri.uniforms.delta.value = new THREE.Vector2(
            controls.deltaX,
            controls.deltaY
          )
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "hBlur").onChange(controls.onChange)
      gui.add(controls, "vBlur").onChange(controls.onChange)
      gui.add(controls, "hTilt").onChange(controls.onChange)
      gui.add(controls, "hTiltR", 0, 1).onChange(controls.onChange)
      gui.add(controls, "vTilt").onChange(controls.onChange)
      gui.add(controls, "vTiltR", 0, 1).onChange(controls.onChange)
      gui.add(controls, "triBlur").onChange(controls.onChange)
      gui
        .add(controls, "deltaX", 0, 0.05)
        .step(0.001)
        .onChange(controls.onChange)
      gui
        .add(controls, "deltaY", 0, 0.05)
        .step(0.001)
        .onChange(controls.onChange)

      render()

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        //
        //

        requestAnimationFrame(render)
        //        webGLRenderer.render(scene, camera);
        composer.render()
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 7.先进的

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var scale = chroma.scale(["white", "blue"])
      var stats = this.initStats()
      var scene = new THREE.Scene()
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xaaaaff, 1.0))
      webGLRenderer.setSize(window.innerWidth/2, window.innerHeight/2)
      webGLRenderer.shadowMapEnabled = true
      webGLRenderer.antialias = false
      camera.position.x = 30
      camera.position.y = 30
      camera.position.z = 30
      camera.lookAt(new THREE.Vector3(0, 0, 0))
      var dirLight = new THREE.DirectionalLight(0xffffff)
      dirLight.position.set(30, 30, 30)
      dirLight.intensity = 0.8
      scene.add(dirLight)
      var spotLight = new THREE.SpotLight(0xffffff)
      spotLight.castShadow = true
      spotLight.position.set(-30, 30, -100)
      spotLight.target.position.x = -10
      spotLight.target.position.z = -10
      spotLight.intensity = 0.6
      spotLight.shadowMapWidth = 4096
      spotLight.shadowMapHeight = 4096
      spotLight.shadowCameraFov = 120
      spotLight.shadowCameraNear = 1
      spotLight.shadowCameraFar = 200

      scene.add(spotLight)
      var plane = new THREE.BoxGeometry(1600, 1600, 0.1, 40, 40)

      var cube = new THREE.Mesh(
        plane,
        new THREE.MeshPhongMaterial({
          color: 0xffffff,
          map: THREE.ImageUtils.loadTexture(
            this.$withBase("/assets/textures/general/floor-wood.jpg")
          ),
          normalScale: new THREE.Vector2(0.6, 0.6),
        })
      )
      cube.material.map.wrapS = THREE.RepeatWrapping
      cube.material.map.wrapT = THREE.RepeatWrapping

      cube.rotation.x = Math.PI / 2
      cube.material.map.repeat.set(80, 80)

      cube.receiveShadow = true
      cube.position.z = -150
      cube.position.x = -150
      scene.add(cube)

      var range = 3
      var stepX = 8
      var stepZ = 8
      for (var i = -25; i < 5; i++) {
        for (var j = -15; j < 15; j++) {
          var cube = new THREE.Mesh(
            new THREE.BoxGeometry(3, 4, 3),
            new THREE.MeshPhongMaterial({
              color: scale(Math.random()).hex(),
              opacity: 0.8,
              transparent: true,
            })
          )
          cube.position.x = i * stepX + (Math.random() - 0.5) * range
          cube.position.z = j * stepZ + (Math.random() - 0.5) * range
          cube.position.y = (Math.random() - 0.5) * 2
          cube.castShadow = true
          scene.add(cube)
        }
      }

      // add the output of the renderer to the html element

      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // create the shaders
      // overlay of black and white
      var bleachFilter = new THREE.ShaderPass(THREE.BleachBypassShader)
      bleachFilter.enabled = false

      var edgeShader = new THREE.ShaderPass(THREE.EdgeShader)
      edgeShader.enabled = false

      var FXAAShader = new THREE.ShaderPass(THREE.FXAAShader)
      FXAAShader.enabled = false

      var focusShader = new THREE.ShaderPass(THREE.FocusShader)
      focusShader.enabled = false

      var renderPass = new THREE.RenderPass(scene, camera)
      var effectCopy = new THREE.ShaderPass(THREE.CopyShader)
      effectCopy.renderToScreen = true

      var composer = new THREE.EffectComposer(webGLRenderer)
      composer.addPass(renderPass)
      composer.addPass(bleachFilter)
      composer.addPass(edgeShader)
      composer.addPass(FXAAShader)
      composer.addPass(focusShader)
      composer.addPass(effectCopy)

      var controls = new (function () {
        this.bleachOpacity = 1
        this.bleach = false
        this.edgeDetect = false
        this.edgeAspect = 512
        this.FXAA = false

        this.focus = false
        this.sampleDistance = 0.94
        this.waveFactor = 0.00125
        this.screenWidth = window.innerWidth
        this.screenHeight = window.innerHeight

        this.onChange = function () {
          bleachFilter.enabled = controls.bleach
          bleachFilter.uniforms.opacity.value = controls.bleachOpacity

          edgeShader.enabled = controls.edgeDetect
          edgeShader.uniforms.aspect.value = new THREE.Vector2(
            controls.edgeAspect,
            controls.edgeAspect
          )

          FXAAShader.enabled = controls.FXAA
          FXAAShader.uniforms.resolution.value = new THREE.Vector2(
            1 / window.innerWidth,
            1 / window.innerHeight
          )

          focusShader.enabled = controls.focus
          focusShader.uniforms.screenWidth.value = controls.screenWidth
          focusShader.uniforms.screenHeight.value = controls.screenHeight
          focusShader.uniforms.waveFactor.value = controls.waveFactor
          focusShader.uniforms.sampleDistance.value = controls.sampleDistance
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "bleach").onChange(controls.onChange)
      gui.add(controls, "bleachOpacity", 0, 2).onChange(controls.onChange)
      gui.add(controls, "edgeDetect").onChange(controls.onChange)
      gui
        .add(controls, "edgeAspect", 128, 2048)
        .step(128)
        .onChange(controls.onChange)
      gui.add(controls, "FXAA").onChange(controls.onChange)
      gui.add(controls, "focus").onChange(controls.onChange)
      gui
        .add(controls, "sampleDistance", 0, 2)
        .step(0.01)
        .onChange(controls.onChange)
      gui
        .add(controls, "waveFactor", 0, 0.005)
        .step(0.0001)
        .onChange(controls.onChange)

      render()

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()
        requestAnimationFrame(render)
        composer.render()
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 8.自定义着色器类

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0x000, 1.0))
      webGLRenderer.setSize(window.innerWidth/2, window.innerHeight/2)
      webGLRenderer.shadowMapEnabled = true

      var sphere = createMesh(new THREE.SphereGeometry(10, 40, 40))
      // add the sphere to the scene
      scene.add(sphere)

      // position and point the camera to the center of the scene
      camera.position.x = -10
      camera.position.y = 15
      camera.position.z = 25

      camera.lookAt(new THREE.Vector3(0, 0, 0))

      var orbitControls = new THREE.OrbitControls(camera)
      orbitControls.autoRotate = false
      var clock = new THREE.Clock()

      var ambi = new THREE.AmbientLight(0x181818)
      scene.add(ambi)

      var spotLight = new THREE.DirectionalLight(0xffffff)
      spotLight.position.set(550, 100, 550)
      spotLight.intensity = 0.6

      scene.add(spotLight)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      var renderPass = new THREE.RenderPass(scene, camera)
      var effectCopy = new THREE.ShaderPass(THREE.CopyShader)
      effectCopy.renderToScreen = true
      var shaderPass = new THREE.ShaderPass(THREE.CustomGrayScaleShader)
      shaderPass.enabled = false

      var bitPass = new THREE.ShaderPass(THREE.CustomBitShader)
      bitPass.enabled = false

      var composer = new THREE.EffectComposer(webGLRenderer)
      composer.addPass(renderPass)
      composer.addPass(shaderPass)
      composer.addPass(bitPass)
      composer.addPass(effectCopy)

      // setup the control gui
      var controls = new (function () {
        this.grayScale = false
        this.rPower = 0.2126
        this.gPower = 0.7152
        this.bPower = 0.0722

        this.bitShader = false
        this.bitSize = 8

        this.updateEffectFilm = function () {
          shaderPass.enabled = controls.grayScale
          shaderPass.uniforms.rPower.value = controls.rPower
          shaderPass.uniforms.gPower.value = controls.gPower
          shaderPass.uniforms.bPower.value = controls.bPower
        }

        this.updateBit = function () {
          bitPass.enabled = controls.bitShader
          bitPass.uniforms.bitSize.value = controls.bitSize
        }
      })()

      var gui = new dat.GUI()
      var grayMenu = gui.addFolder("gray scale")
      grayMenu.add(controls, "grayScale").onChange(controls.updateEffectFilm)
      grayMenu.add(controls, "rPower", 0, 1).onChange(controls.updateEffectFilm)
      grayMenu.add(controls, "gPower", 0, 1).onChange(controls.updateEffectFilm)
      grayMenu.add(controls, "bPower", 0, 1).onChange(controls.updateEffectFilm)

      var bitMenu = gui.addFolder("bit")
      bitMenu.add(controls, "bitShader").onChange(controls.updateBit)
      bitMenu
        .add(controls, "bitSize", 2, 24)
        .step(1)
        .onChange(controls.updateBit)

      // call the render function
      var step = 0

      render()

      function createMesh(geom) {
        var planetTexture = THREE.ImageUtils.loadTexture(
          this.$withBase("/assets/textures/planets/Earth.png")
        )
        var specularTexture = THREE.ImageUtils.loadTexture(
          this.$withBase("/assets/textures/planets/EarthSpec.png")
        )
        var normalTexture = THREE.ImageUtils.loadTexture(
          this.$withBase("/assets/textures/planets/EarthNormal.png")
        )

        var planetMaterial = new THREE.MeshPhongMaterial()
        planetMaterial.specularMap = specularTexture
        planetMaterial.specular = new THREE.Color(0x4444aa)

        planetMaterial.normalMap = normalTexture
        planetMaterial.map = planetTexture
        //               planetMaterial.shininess = 150;

        // create a multimaterial
        var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [
          planetMaterial,
        ])

        return mesh
      }

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()
        var delta = clock.getDelta()
        orbitControls.update(delta)
        sphere.rotation.y += 0.002
        requestAnimationFrame(render)
        composer.render(delta)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::
