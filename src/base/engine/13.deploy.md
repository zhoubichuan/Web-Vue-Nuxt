---
lang: zh-CN
sidebarDepth: 0
meta:
  - name: description
    content: 个人总结的vuepress学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 十三.模型文件

## 1.加载 obj 格式模型文件

:::demo

```vue
<template>
  <div class="three"></div>
</template>
<script>
export default {
  mounted() {
    //TODO:加载obj格式模型文件
    var renderer,
      camera,
      scene,
      gui,
      stats,
      ambientLight,
      directionalLight,
      control

    function initRender() {
      renderer = new THREE.WebGLRenderer({ antialias: true })
      renderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      //渲染器渲染阴影效果
      renderer.shadowMap.enabled = true
      renderer.shadowMap.type = THREE.PCFSoftShadowMap // 默认的是，没有设置的这个清晰 THREE.PCFShadowMap
      document.body.appendChild(renderer.domElement)
    }

    function initCamera() {
      camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )
      camera.position.set(0, 100, 200)
      camera.lookAt(new THREE.Vector3(0, 0, 0))
    }

    function initScene() {
      scene = new THREE.Scene()
    }

    function initGui() {
      //声明一个保存需求修改的相关数据的对象
      gui = {}

      var datGui = new dat.GUI()
      //将设置属性添加到gui当中，gui.add(对象，属性，最小值，最大值）
    }

    function initLight() {
      ambientLight = new THREE.AmbientLight("#ffffff")
      scene.add(ambientLight)

      directionalLight = new THREE.DirectionalLight("#ffffff")
      directionalLight.position.set(40, 60, 10)

      directionalLight.shadow.camera.near = 1 //产生阴影的最近距离
      directionalLight.shadow.camera.far = 400 //产生阴影的最远距离
      directionalLight.shadow.camera.left = -50 //产生阴影距离位置的最左边位置
      directionalLight.shadow.camera.right = 50 //最右边
      directionalLight.shadow.camera.top = 50 //最上边
      directionalLight.shadow.camera.bottom = -50 //最下面

      //这两个值决定生成阴影密度 默认512
      directionalLight.shadow.mapSize.height = 1024
      directionalLight.shadow.mapSize.width = 1024

      //平行光开启阴影投射
      directionalLight.castShadow = true

      scene.add(directionalLight)
    }

    function initModel() {
      //底部平面
      var planeGeometry = new THREE.PlaneGeometry(100, 100)
      var planeMaterial = new THREE.MeshLambertMaterial({
        color: 0xfabdefff,
        side: THREE.DoubleSide,
      })
      var plane = new THREE.Mesh(planeGeometry, planeMaterial)
      plane.rotation.x = -0.5 * Math.PI
      plane.position.y = -0.1
      plane.receiveShadow = true //可以接收阴影
      scene.add(plane)
      //创建MTL加载器
      var mtlLoader = new THREE.MTLLoader()
      //设置文件路径
      mtlLoader.setPath("../js/models/obj/")
      //加载mtl文件
      mtlLoader.load("female02.mtl", function (material) {
        //创建OBJ加载器
        var objLoader = new THREE.OBJLoader()
        //设置当前加载的纹理
        objLoader.setMaterials(material)
        objLoader.setPath("../js/models/obj/")
        objLoader.load(
          "female02.obj",
          //onload函数
          function (object) {
            //添加阴影
            //traverse函数会遍历自身向下的所有子节点
            object.traverse(function (item) {
              if (item instanceof THREE.Mesh) {
                item.castShadow = true
                item.receiveShadow = true
              }
            })
            //缩放
            object.scale.set(0.3, 0.3, 0.3)
            scene.add(object)
          },
          //onProcess方法
          function (event) {
            console.log(event)
            //若长度可以计算
            if (event.lengthComputable) {
              console.log(
                "now process : " + (event.loaded / event.total) * 100 + "%"
              )
            }
          }
        )
      })
    }

    function initStats() {
      stats = new Stats()
      document.body.appendChild(stats.dom)
    }

    function initControl() {
      control = new THREE.OrbitControls(camera, renderer.domElement)
    }

    function render() {
      control.update()
      renderer.render(scene, camera)
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight
      camera.updateProjectionMatrix()
      renderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
    }

    function animate() {
      //更新控制器
      render()

      //更新性能插件
      stats.update()

      requestAnimationFrame(animate)
    }

    function draw() {
      initGui()
      initRender()
      initScene()
      initCamera()
      initLight()
      initModel()
      initStats()

      initControl()

      animate()
      window.onresize = onWindowResize
    }
  },
}
</script>
```

:::

## 2.加载多个纹理贴图

:::demo

```vue
<template>
  <div class="three"></div>
</template>
<script>
export default {
  mounted() {
    //TODO:加载多个纹理贴图
    var renderer,
      camera,
      scene,
      gui,
      stats,
      ambientLight,
      directionalLight,
      control

    function initRender() {
      renderer = new THREE.WebGLRenderer({ antialias: true })
      renderer.setSize(window.innerWidth, window.innerHeight)
      //渲染器渲染阴影效果
      renderer.shadowMap.enabled = true
      renderer.shadowMap.type = THREE.PCFSoftShadowMap // 默认的是，没有设置的这个清晰 THREE.PCFShadowMap
      document.body.appendChild(renderer.domElement)
    }

    function initCamera() {
      camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )
      camera.position.set(0, 100, 200)
      camera.lookAt(new THREE.Vector3(0, 0, 0))
    }

    function initScene() {
      scene = new THREE.Scene()
    }

    function initGui() {
      //声明一个保存需求修改的相关数据的对象
      gui = {}

      var datGui = new dat.GUI()
      //将设置属性添加到gui当中，gui.add(对象，属性，最小值，最大值）
    }

    function initLight() {
      ambientLight = new THREE.AmbientLight("#ffffff")
      scene.add(ambientLight)

      directionalLight = new THREE.DirectionalLight("#ffffff")
      directionalLight.position.set(40, 60, 10)

      directionalLight.shadow.camera.near = 1 //产生阴影的最近距离
      directionalLight.shadow.camera.far = 400 //产生阴影的最远距离
      directionalLight.shadow.camera.left = -50 //产生阴影距离位置的最左边位置
      directionalLight.shadow.camera.right = 50 //最右边
      directionalLight.shadow.camera.top = 50 //最上边
      directionalLight.shadow.camera.bottom = -50 //最下面
      //这两个值决定生成阴影密度 默认512
      directionalLight.shadow.mapSize.height = 1024
      directionalLight.shadow.mapSize.width = 1024

      //平行光开启阴影投射
      directionalLight.castShadow = true

      scene.add(directionalLight)
    }

    function initModel() {
      var manager = new THREE.LoadingManager()
      var texture = new THREE.Texture()
      var texture2 = new THREE.Texture()
      var loader = new THREE.ImageLoader(manager)
      loader.load(
        "../js/models/obj/01_-_Default1noCulling.JPG",
        function (image) {
          texture.image = image
          texture.needsUpdate = true
        }
      )
      loader.load(
        "../js/models/obj/02_-_Default1noCulling.JPG",
        function (image) {
          texture2.image = image
          texture2.needsUpdate = true
        }
      )
      var i = 0
      //创建OBJ加载器
      var objLoader = new THREE.OBJLoader(manager)
      objLoader.load(
        "../js/models/obj/female02.obj",
        //onload函数
        function (object) {
          //添加阴影
          //traverse函数会遍历自身向下的所有子节点
          object.traverse(function (item) {
            if (item instanceof THREE.Mesh) {
              if (i % 2 == 0) {
                item.material.map = texture
              } else {
                item.material.map = texture2
              }
              i++
              item.castShadow = true
              item.receiveShadow = true
            }
          })
          //缩放
          object.scale.set(0.3, 0.3, 0.3)
          scene.add(object)
        }
      )
    }

    function initStats() {
      stats = new Stats()
      document.body.appendChild(stats.dom)
    }

    function initControl() {
      control = new THREE.OrbitControls(camera, renderer.domElement)
    }

    function render() {
      control.update()
      renderer.render(scene, camera)
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight
      camera.updateProjectionMatrix()
      renderer.setSize(window.innerWidth, window.innerHeight)
    }

    function animate() {
      //更新控制器
      render()

      //更新性能插件
      stats.update()

      requestAnimationFrame(animate)
    }

    function draw() {
      initGui()
      initRender()
      initScene()
      initCamera()
      initLight()
      initModel()
      initStats()

      initControl()

      animate()
      window.onresize = onWindowResize
    }
  },
}
</script>
```

:::

## 3.多视图

:::demo

```vue
<template>
  <div class="three"></div>
</template>
<script>
export default {
  mounted() {
    //TODO:多视图
    /// <reference path="../js/three.js"/>
    var container1, container2, container3, container4
    var scene, renderer
    var renderer1, renderer2, renderer3, renderer4
    var light
    function draw() {
      container1 = document.getElementById("container1")
      container2 = document.getElementById("container2")
      container3 = document.getElementById("container3")
      container4 = document.getElementById("container4")
      initRenderer()
      initScene()
      initCamera()
      initObject()
      animate()
    }
    function animate() {
      render()
      stats.update()
      requestAnimationFrame(animate)
    }
    function initRenderer() {
      renderer1 = new THREE.WebGLRenderer({ antialias: true, alpha: true }) //alpha表示渲染背景透明
      renderer1.setSize(500, 250)
      renderer2 = new THREE.WebGLRenderer({ antialias: true, alpha: true })
      renderer2.setSize(500, 250)
      renderer3 = new THREE.WebGLRenderer({ antialias: true, alpha: true })
      renderer3.setSize(500, 250)
      renderer4 = new THREE.WebGLRenderer({ antialias: true, alpha: true })
      renderer4.setSize(500, 250)

      container1.appendChild(renderer1.domElement)
      container2.appendChild(renderer2.domElement)
      container3.appendChild(renderer3.domElement)
      container4.appendChild(renderer4.domElement)
      stats = new Stats()
      stats.domElement.style.position = "absolute"
      stats.domElement.style.top = "0px"

      container1.appendChild(stats.domElement)
    }
    function initScene() {
      scene = new THREE.Scene()
      light = new THREE.DirectionalLight(0xffffff)
      light.position.set(0, 0, 1).normalize()
      scene.add(light)
    }
    function initCamera() {
      camera1 = new THREE.PerspectiveCamera(45, 500 / 250, 1, 10000)
      camera1.setViewOffset(500, 250, 0, 0, 500, 250)
      camera1.position.z = 1800

      camera2 = new THREE.PerspectiveCamera(45, 500 / 250, 1, 10000)
      camera2.setViewOffset(500, 250, 0, 0, 500, 250)
      camera2.position.x = 1800

      camera3 = new THREE.PerspectiveCamera(65, 500 / 250, 1, 10000)
      camera3.setViewOffset(500, 250, 0, 0, 500, 250)
      camera3.position.y = 1000
      camera3.up.set(0, 0, 1)

      camera4 = new THREE.PerspectiveCamera(45, 500 / 250, 1, 10000)
      camera4.setViewOffset(500, 250, 0, 0, 500, 250)
      camera4.position.z = 800
      camera4.position.x = 300
    }
    function initObject() {
      var canvas = document.createElement("canvas")
      canvas.width = 128
      canvas.height = 128

      var context = canvas.getContext("2d")
      var gradient = context.createRadialGradient(
        canvas.width / 2,
        canvas.height / 2,
        0,
        canvas.width / 2,
        canvas.height / 2,
        canvas.width / 2
      )
      gradient.addColorStop(0.1, "rgba(210,210,210,1)")
      gradient.addColorStop(1, "rgba(255,255,255,1)")
      context.fillStyle = gradient
      context.fillRect(0, 0, canvas.width, canvas.height)

      var shadowTexture = new THREE.Texture(canvas)
      shadowTexture.needsUpdate = true

      var shadowMaterial = new THREE.MeshBasicMaterial({
        map: shadowTexture,
      })
      var shadowGeo = new THREE.PlaneGeometry(300, 300, 1, 1)

      mesh = new THREE.Mesh(shadowGeo, shadowMaterial)
      mesh.position.y = -250
      mesh.rotation.x = -Math.PI / 2
      scene.add(mesh)

      mesh = new THREE.Mesh(shadowGeo, shadowMaterial)
      mesh.position.x = -400
      mesh.position.y = -250
      mesh.rotation.x = -Math.PI / 2
      scene.add(mesh)

      mesh = new THREE.Mesh(shadowGeo, shadowMaterial)
      mesh.position.x = 400
      mesh.position.y = -250
      mesh.rotation.x = -Math.PI / 2
      scene.add(mesh)

      var faceIndices = ["a", "b", "c", "d"]
      var color,
        f1,
        f2,
        f3,
        p,
        n,
        vertexIndex,
        radius = 200,
        geometry1 = new THREE.IcosahedronGeometry(radius, 1),
        geometry2 = new THREE.IcosahedronGeometry(radius, 1),
        geometry3 = new THREE.IcosahedronGeometry(radius, 1)
      for (var i = 0; i < geometry1.faces.length; i++) {
        f1 = geometry1.faces[i]
        f2 = geometry2.faces[i]
        f3 = geometry3.faces[i]

        n = f1 instanceof THREE.Face3 ? 3 : 4
        for (var j = 0; j < n; j++) {
          vertexIndex = f1[faceIndices[j]]
          p = geometry1.vertices[vertexIndex]
          color = new THREE.Color(0xffffff)
          color.setHSL((p.y / radius + 1) / 2, 1, 1)
          f1.vertexColors[j] = color

          color = new THREE.Color(0xffffff)
          color.setHSL(0, (p.y / radius + 1) / 2, 1, 1)
          f2.vertexColors[j] = color

          color = new THREE.Color(0xffffff)
          color.setHSL((0.125 * vertexIndex) / geometry1.vertices.length, 1, 1)
          f3.vertexColors[j] = color
        }
      }
      var material = new THREE.MeshLambertMaterial({
        vertexColors: THREE.VertexColors,
        //color:0x00FF00,
        side: THREE.DoubleSide, //表示材质的两面都会渲染 FrontSide只渲染前面 BackSide只渲染后面
        wireframe: false, //该参数的含义为显示线框
      })
      group1 = new THREE.Mesh(geometry1, material)
      group1.position.x = -400
      group1.rotation.x = -1.87
      scene.add(group1)

      group2 = new THREE.Mesh(geometry2, material)
      group2.position.x = 400
      group2.rotation.x = 0
      scene.add(group2)

      group3 = new THREE.Mesh(geometry3, material)
      group3.position.x = 0
      group3.rotation.x = 0
      scene.add(group3)
    }
    function render() {
      camera1.lookAt(scene.position)
      camera2.lookAt(scene.position)
      camera3.lookAt(scene.position)
      camera4.lookAt(scene.position)

      renderer1.render(scene, camera1)
      renderer2.render(scene, camera2)
      renderer3.render(scene, camera3)
      renderer4.render(scene, camera4)
    }
  },
}
</script>
```

:::

## 4.鼠标交互

:::demo

```vue
<template>
  <div class="three"></div>
</template>
<script>
export default {
  mounted() {
    //TODO:鼠标交互
    /// <reference path="../js/three.js" />
    //import * as THREE from '../js/three.module.js';
    var container
    var scene, raycaster, camera, renderer
    var mouse = new THREE.Vector2(),
      INTERSECTED
    var radius = 100,
      theta = 0
    function draw() {
      container = document.createElement("div")
      document.body.appendChild(container)

      var info = document.createElement("div")
      info.style.position = "absolute"
      info.style.top = "10px"
      info.style.width = "100%"
      info.style.textAlign = "center"
      info.innerHTML = "demo16_鼠标交互拾取物体"
      container.appendChild(info)

      camera = new THREE.PerspectiveCamera(
        70,
        window.innerWidth / window.innerHeight,
        1,
        10000
      )
      scene = new THREE.Scene()

      var light = new THREE.DirectionalLight(0xffffff, 1)
      light.position.set(1, 1, 1).normalize()
      scene.add(light)

      var geometry = new THREE.BoxGeometry(20, 20, 20)
      for (var i = 0; i < 2000; i++) {
        var obj = new THREE.Mesh(
          geometry,
          new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff })
        )
        obj.position.x = Math.random() * 800 - 400
        obj.position.y = Math.random() * 800 - 400
        obj.position.z = Math.random() * 800 - 400

        obj.rotation.x = Math.random() * 2 * Math.PI
        obj.rotation.y = Math.random() * 2 * Math.PI
        obj.rotation.z = Math.random() * 2 * Math.PI

        obj.scale.x = Math.random() + 0.5
        obj.scale.y = Math.random() + 0.5
        obj.scale.z = Math.random() + 0.5
        scene.add(obj)
      }

      raycaster = new THREE.Raycaster()

      renderer = new THREE.WebGLRenderer()
      renderer.setClearColor(0xf0f0f0)
      renderer.setPixelRatio(window.devicePixelRatio)
      renderer.setSize(window.innerWidth, window.innerHeight)
      renderer.sortObjects = false
      container.appendChild(renderer.domElement)

      document.addEventListener("mousemove", onDocumentMouseMove, false)
      window.addEventListener("resize", onWindowResize, false)
      animate()
    }

    function animate() {
      requestAnimationFrame(animate)
      render()
    }
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight
      camera.updateProjectionMatrix()

      renderer.setSize(window.innerWidth, window.innerHeight)
    }
    function onDocumentMouseMove(event) {
      event.preventDefault()
      //通过鼠标点击的位置计算出射线所需要的点的位置，以屏幕中心为原点，值的范围为-1到1.
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1
    }
    function render() {
      theta += 0.1
      // renderer.render(scene, camera);
      camera.position.x = radius * Math.sin(THREE.Math.degToRad(theta))
      camera.position.y = radius * Math.sin(THREE.Math.degToRad(theta))
      camera.position.z = radius * Math.cos(THREE.Math.degToRad(theta))
      camera.lookAt(scene.position)

      camera.updateMatrixWorld()
      //根据在屏幕的二维位置以及相机的矩阵更新射线的位置
      //第一个参数为归一化的设备坐标(xyz在-1到1之间),第二个参数光线起源的位置
      //得到一个由相机指向鼠标的光线
      raycaster.setFromCamera(mouse, camera)
      //参数为检测相交物体的数组
      //返回一个数组,为相交的对象的数组
      //增加第二个参数，可以遍历子子孙孙对象
      var intersects = raycaster.intersectObjects(scene.children, true)
      //intersects是返回的一个数组，如果当前位置没有可选中的对象，那这个数组为空，否则为多个对象组成的数组，排列顺序为距离屏幕的距离从近到远的顺序排列
      //数组的每一个子对象内包含:
      // distance：距离屏幕的距离
      // face：与射线相交的模型的面
      // faceIndex：与射线相交的模型的面的下标
      // object：与射线相交的模型对象
      // point：射线与模型相交的点的位置坐标
      // uv：与射线相交的模型的面的uv映射位置
      // if (intersects.length > 0) {
      //     if (INTERSECTED != intersects[0].object) {
      //         if (INTERSECTED){
      //             INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
      //         }
      //         console.log(INTERSECTED)
      //         INTERSECTED = intersects[0].object;
      //         INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
      //         INTERSECTED.material.emissive.setHex(0xff0000);
      //     }
      // }
      // else {
      //     if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);
      //     INTERSECTED = null;
      // }
      for (let i = 0; i < intersects.length; i++) {
        intersects[0].object.material.emissive.setHex(0xff00ff) //设置反射光,所以颜色看起来高亮些
        //intersects[0].object.material.color.set(0xff00ff);//设置材质色彩,根据光照呈现不同的色泽
      }
      renderer.render(scene, camera)
    }
  },
}
</script>
```

:::

## 5.鼠标框选

:::demo

```vue
<template>
  <div class="three"></div>
</template>
<script>
export default {
  mounted() {
    //TODO:鼠标框选
    var renderer,
      camera,
      scene,
      gui,
      stats,
      ambientLight,
      directionalLight,
      control

    function initRender() {
      renderer = new THREE.WebGLRenderer({ antialias: true })
      renderer.setSize(window.innerWidth, window.innerHeight)
      //告诉渲染器需要阴影效果
      renderer.shadowMap.enabled = true
      renderer.shadowMap.type = THREE.PCFSoftShadowMap // 默认的是，没有设置的这个清晰 THREE.PCFShadowMap
      document.body.appendChild(renderer.domElement)
    }

    function initCamera() {
      camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )
      camera.position.set(0, 100, 200)
      camera.lookAt(new THREE.Vector3(0, 0, 0))
    }

    function initScene() {
      scene = new THREE.Scene()
    }

    function initGui() {
      //声明一个保存需求修改的相关数据的对象
      gui = {
        createScene: function () {
          //首先先删除掉当前场景所含有的立方体
          deleteGroup("group")
          //创建一个新的模型组
          let group = new THREE.Group()
          group.name = "group"
          let geometry = new THREE.BoxGeometry(10, 10, 10)
          for (let i = 0; i < 300; i++) {
            let material = new THREE.MeshLambertMaterial({
              color: randomColor(),
            })
            let mesh = new THREE.Mesh(geometry, material)
            //随机位置
            mesh.position.set(
              THREE.Math.randFloatSpread(200),
              THREE.Math.randFloatSpread(200),
              THREE.Math.randFloatSpread(200)
            )
            group.add(mesh)
          }
          scene.add(group)
        },
        exporterScene: function () {
          //首先将场景转成json对象
          let group = scene.getObjectByName("group")
          if (!group) return
          let obj = group.toJSON()
          //将json对象转成json字符串并存储
          download("file.json", JSON.stringify(obj))
        },
        importerScene: function () {
          //创建一个input来获取json数据
          let input = document.createElement("input")
          input.type = "file"
          input.addEventListener("change", function () {
            let file = input.files[0]
            //判断是否是json格式的文件
            if (file.type.indexOf("json") >= 0) {
              //首先先删除掉当前场景所含有的立方体
              deleteGroup("group")

              //读取文件内的内容
              let reader = new FileReader()
              reader.readAsText(file)
              reader.onloadend = function () {
                //使用three.js的JSONLoader将模型导入到场景
                let loader = new THREE.ObjectLoader()
                let group = loader.parse(JSON.parse(this.result))
                scene.add(group)
              }
            }
          })
          input.click()
        },
        loaderScene: function () {
          //首先先删除掉当前场景所含有的立方体
          deleteGroup("group")

          //使用JSONLoader加载json格式文件
          let loader = new THREE.ObjectLoader()

          loader.load("../js/models/json/file.json", function (group) {
            console.log(group)
            scene.add(group)
          })
        },
      }

      //var datGui = new dat.GUI();
      //将设置属性添加到gui当中，gui.add(对象，属性，最小值，最大值）
      /*datGui.add(gui, "createScene").name("添加模型");
    datGui.add(gui, "exporterScene").name("导出模型");
    datGui.add(gui, "importerScene").name("导入模型");
    datGui.add(gui, "loaderScene").name("加载模型");*/

      gui.createScene()
    }

    //随机颜色
    function randomColor() {
      var arrHex = [
          "0",
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9",
          "a",
          "b",
          "c",
          "d",
          "e",
          "f",
        ],
        strHex = "#",
        index

      for (var i = 0; i < 6; i++) {
        index = Math.round(Math.random() * 15)
        strHex += arrHex[index]
      }

      return strHex
    }

    //保存文件
    function download(filename, text) {
      var pom = document.createElement("a")
      pom.setAttribute(
        "href",
        "data:text/plain;charset=utf-8," + encodeURIComponent(text)
      )
      pom.setAttribute("download", filename)
      if (document.createEvent) {
        var event = document.createEvent("MouseEvents")
        event.initEvent("click", true, true)
        pom.dispatchEvent(event)
      } else {
        pom.click()
      }
    }

    //删除group
    function deleteGroup(name) {
      let group = scene.getObjectByName(name)
      if (!group) return
      //删除掉所有的模型组内的mesh
      group.traverse(function (item) {
        if (item instanceof THREE.Mesh) {
          item.geometry.dispose() //删除几何体
          item.material.dispose() //删除材质
        }
      })

      scene.remove(group)
    }

    function initLight() {
      ambientLight = new THREE.AmbientLight("#111111")
      scene.add(ambientLight)

      directionalLight = new THREE.DirectionalLight("#ffffff")
      directionalLight.position.set(40, 60, 10)

      directionalLight.shadow.camera.near = 1 //产生阴影的最近距离
      directionalLight.shadow.camera.far = 400 //产生阴影的最远距离
      directionalLight.shadow.camera.left = -50 //产生阴影距离位置的最左边位置
      directionalLight.shadow.camera.right = 50 //最右边
      directionalLight.shadow.camera.top = 50 //最上边
      directionalLight.shadow.camera.bottom = -50 //最下面

      //这两个值决定生成阴影密度 默认512
      directionalLight.shadow.mapSize.height = 1024
      directionalLight.shadow.mapSize.width = 1024

      //告诉平行光需要开启阴影投射
      directionalLight.castShadow = true

      scene.add(directionalLight)
    }

    function initStats() {
      stats = new Stats()
      document.body.appendChild(stats.dom)
    }

    function initControl() {
      control = new THREE.OrbitControls(camera, renderer.domElement)
      control.enabled = false
    }

    function render() {
      control.update()

      renderer.render(scene, camera)
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight
      camera.updateProjectionMatrix()
      renderer.setSize(window.innerWidth, window.innerHeight)
    }

    function animate() {
      //更新控制器
      render()

      //更新性能插件
      stats.update()

      requestAnimationFrame(animate)
    }

    function addTouch() {
      //获取显示区域一半的大小
      var half = {}

      //获取一下当前的dom的距离左上角的偏移量
      var domClient = {}

      //鼠标按下距离左上角的距离
      var down = {}
      var move = {}

      var max = {}
      var min = {}

      var modelsList = []

      var group

      var material = new THREE.MeshPhongMaterial({ color: 0xffffff })

      //声明一个显示的拖拽框的div
      var div = document.createElement("div")
      div.style.cssText =
        "position:fixed; box-sizing:border-box; border:1px solid #ccc;"

      renderer.domElement.addEventListener(
        "mousedown",
        function (e) {
          if (e.button !== 0) {
            return
          }

          group = scene.getObjectByName("group")

          half.height = renderer.domElement.offsetHeight / 2
          half.width = renderer.domElement.offsetWidth / 2

          domClient.x = renderer.domElement.getBoundingClientRect().left
          domClient.y = renderer.domElement.getBoundingClientRect().top

          down.x = e.clientX - domClient.x
          down.y = e.clientY - domClient.y

          for (let i = 0; i < group.children.length; i++) {
            let box = new THREE.Box3()
            box.expandByObject(group.children[i])

            //获取到平面的坐标
            let vec3 = new THREE.Vector3()
            box.getCenter(vec3)
            let vec = vec3.project(camera)

            modelsList.push({
              component: group.children[i],
              position: {
                x: vec.x * half.width + half.width,
                y: -vec.y * half.height + half.height,
              },
              normalMaterial: group.children[i].material,
            })
          }

          //重置样式
          div.style.left = 0
          div.style.top = 0
          div.style.width = 0
          div.style.height = 0
          document.body.appendChild(div)

          //绑定鼠标按下移动事件和抬起事件
          document.addEventListener("mousemove", movefun, false)
          document.addEventListener("mouseup", upfun, false)
        },
        false
      )

      function movefun(e) {
        move.x = e.clientX - domClient.x
        move.y = e.clientY - domClient.y

        //计算出来大小来设置拖拽框
        min.x = Math.min(move.x, down.x)
        min.y = Math.min(move.y, down.y)
        max.x = Math.max(move.x, down.x)
        max.y = Math.max(move.y, down.y)

        //设置div框
        div.style.left = min.x + "px"
        div.style.top = min.y + "px"
        div.style.width = max.x - min.x + "px"
        div.style.height = max.y - min.y + "px"

        //判断修改哪些构件
        for (let i = 0; i < modelsList.length; i++) {
          let position = modelsList[i].position
          if (
            position.x > min.x &&
            position.x < max.x &&
            position.y > min.y &&
            position.y < max.y
          ) {
            modelsList[i].component.material = material
          } else {
            modelsList[i].component.material = modelsList[i].normalMaterial
          }
        }
      }

      function upfun(e) {
        //清除事件
        document.body.removeChild(div)
        document.removeEventListener("mousemove", movefun, false)
        document.removeEventListener("mouseup", upfun, false)

        //将所有的模型修改为当前默认的模型
        for (let i = 0; i < modelsList.length; i++) {
          modelsList[i].component.material = modelsList[i].normalMaterial
        }
      }
    }

    function draw() {
      initRender()
      initScene()
      initCamera()
      initLight()
      initStats()
      initGui()

      initControl()

      addTouch()

      animate()
      window.onresize = onWindowResize
    }
  },
}
</script>
```

:::

## 6.物体旋转

:::demo

```vue
<template>
  <div class="three"></div>
</template>
<script>
export default {
  mounted() {
    //TODO:物体旋转
    /// <reference path="../js/three.js"/>
    //import * as THREE from '../js/three.module.js';
    function init() {
      initReneder()
      initCamera()
      initScene()
      initLight()

      initObject()
      initGrid()
      animate()
    }
    //渲染器
    var renderer
    function initReneder() {
      width = document.getElementById("canvas-frame").clientWidth
      height = document.getElementById("canvas-frame").clientHeight
      renderer = new THREE.WebGLRenderer({
        antialias: false, //设置为false可以提高渲染性能
      })
      renderer.setSize(width, height)
      document.getElementById("canvas-frame").appendChild(renderer.domElement)
      renderer.setClearColor(0xffffff, 1.0)
    }
    //相机
    var camera
    function initCamera() {
      camera = new THREE.PerspectiveCamera(45, width / height, 1, 10000)
      camera.position.x = 200
      camera.position.y = 300
      camera.position.z = 1000
      camera.up.x = 0
      camera.up.y = 0
      camera.up.z = 0
      camera.lookAt(0, 0, 0)
    }
    //创建场景
    var scene
    function initScene() {
      scene = new THREE.Scene()
    }
    //灯光
    var light
    function initLight() {
      light = new THREE.DirectionalLight(0xff0000, 1.0, 0)
      light.position.set(100, 100, 200)
      scene.add(light)
    }
    var mesh
    function initObject() {
      var geometry = new THREE.BoxGeometry(100, 100, 100)
      for (let i = 0; i < geometry.faces.length; i += 2) {
        var hex = Math.random() * 0xffffff //随机颜色
        geometry.faces[i].color.setHex(hex)
        geometry.faces[i + 1].color.setHex(hex)
      }
      var material = new THREE.MeshBasicMaterial({
        vertexColors: THREE.FaceColors,
      })
      mesh = new THREE.Mesh(geometry, material)
      mesh.position = new THREE.Vector3(0, 0, 0)
      scene.add(mesh)
    }

    //辅助线
    function initGrid() {
      //参数代表网格的长宽和每一行分多少份
      var helper = new THREE.GridHelper(window.innerWidth, 20, 0xff00ff)
      //helper.setColors(0x000fff, 0x808080);
      scene.add(helper)
    }

    //帧循环
    function animate() {
      mesh.rotateY(0.1)
      //mesh.rotateY(Math.PI);
      renderer.render(scene, camera)
      requestAnimationFrame(animate)
    }
  },
}
</script>
```

:::

## 7.加载多个纹理贴图

:::demo

```vue
<template>
  <div class="three"></div>
</template>
<script>
export default {
  mounted() {
    /// <reference path="../js/three.js"/>
    //import * as THREE from '../js/three.module.js';
    function init() {
      initReneder()
      initCamera()
      initScene()
      initLight()

      initObject()
      initGrid()
      animate()
    }
    //渲染器
    var renderer
    function initReneder() {
      width = document.getElementById("canvas-frame").clientWidth
      height = document.getElementById("canvas-frame").clientHeight
      renderer = new THREE.WebGLRenderer({
        antialias: false, //设置为false可以提高渲染性能
      })
      renderer.setSize(width, height)
      document.getElementById("canvas-frame").appendChild(renderer.domElement)
      renderer.setClearColor(0xffffff, 1.0)
    }
    //相机
    var camera
    function initCamera() {
      camera = new THREE.PerspectiveCamera(45, width / height, 1, 10000)
      camera.position.x = 200
      camera.position.y = 300
      camera.position.z = 1000
      camera.up.x = 0
      camera.up.y = 0
      camera.up.z = 0
      camera.lookAt(0, 0, 0)
    }
    //创建场景
    var scene
    function initScene() {
      scene = new THREE.Scene()
    }
    //灯光
    var light
    function initLight() {
      light = new THREE.DirectionalLight(0xffffff * Math.random(), 1.0, 0)
      light.position.set(200, 200, 200)
      scene.add(light)
    }
    var mesh
    var mesh1
    var group
    function initObject() {
      var geometry = new THREE.BoxGeometry(100, 100, 100)
      var geometry1 = new THREE.CylinderGeometry(50, 50, 100, 100, 2)
      for (let i = 0; i < geometry.faces.length; i += 2) {
        var hex = Math.random() * 0xffffff //随机颜色
        geometry.faces[i].color.setHex(hex)
        geometry.faces[i + 1].color.setHex(hex)
      }
      var material = new THREE.MeshBasicMaterial({
        vertexColors: THREE.FaceColors,
      })
      var material1 = new THREE.MeshLambertMaterial({
        vertexColors: THREE.VertexColors,
        color: 0xffffff * Math.random(),
      })
      mesh = new THREE.Mesh(geometry, material)
      mesh1 = new THREE.Mesh(geometry1, material1)
      mesh.position = new THREE.Vector3(0, 0, 0)

      //不同于平时的绕几何体几何中心的旋转
      //在这一步多加一个组对象,旋转组对象即可,改变物体在组对象的相对位置
      group = new THREE.Group()
      group.add(mesh)
      group.add(mesh1)
      mesh.translateX(-50)
      mesh.translateY(-50)
      mesh.translateZ(-50)
      mesh1.translateX(50)
      mesh1.translateY(50)
      mesh1.translateZ(50)

      // group.translateX(500);
      // group.translateY(50);
      // group.translateZ(50);

      scene.add(group)
    }

    //TODO:物体绕任意轴旋转
    //辅助线
    function initGrid() {
      //参数代表网格的长宽和每一行分多少份
      var helper = new THREE.GridHelper(window.innerWidth, 20, 0xff00ff)
      //helper.setColors(0x000fff, 0x808080);
      scene.add(helper)
    }

    //帧循环
    var v1 = new THREE.Vector3(1, 1, 1).normalize() //旋转轴
    var x = 0.05
    var y = 0
    function animate() {
      y += 1
      if (y == 100) {
        x *= -1
        y = 0
      }

      mesh.rotateOnAxis(v1, x)
      mesh1.rotateOnAxis(v1, x)
      //group.rotateY(0.1);
      //mesh.rotateX(0.1);
      //mesh.rotateY(Math.PI);//一帧转一圈
      renderer.render(scene, camera)
      requestAnimationFrame(animate)
    }
  },
}
</script>
```

:::

## 8.包围盒实验

:::demo

```vue
<template>
  <div class="three"></div>
</template>
<script>
export default {
  mounted() {
    //TODO:包围盒实验
    //import * as THREE from '../js/three.module.js';
    function init() {
      initReneder()
      initCamera()
      initScene()
      initLight()

      initObject()
      initGrid()
      animate()
    }
    //渲染器
    var renderer
    function initReneder() {
      width = document.getElementById("canvas-frame").clientWidth
      height = document.getElementById("canvas-frame").clientHeight
      renderer = new THREE.WebGLRenderer({
        antialias: false, //设置为false可以提高渲染性能
      })
      renderer.setSize(width, height)
      document.getElementById("canvas-frame").appendChild(renderer.domElement)
      renderer.setClearColor(0xffffff, 1.0)
    }
    //相机
    var camera
    function initCamera() {
      camera = new THREE.PerspectiveCamera(45, width / height, 1, 10000)
      camera.position.x = 200
      camera.position.y = 300
      camera.position.z = 1000
      camera.up.x = 0
      camera.up.y = 0
      camera.up.z = 0
      camera.lookAt(0, 0, 0)
    }
    //创建场景
    var scene
    function initScene() {
      scene = new THREE.Scene()
    }
    //灯光
    var light
    function initLight() {
      light = new THREE.DirectionalLight(0xffffff * Math.random(), 1.0, 0)
      light.position.set(200, 200, 200)
      scene.add(light)
    }
    var mesh
    var group
    var boxHelper
    function initObject() {
      var geometry = new THREE.BoxGeometry(100, 100, 100)
      for (let i = 0; i < geometry.faces.length; i += 2) {
        var hex = Math.random() * 0xffffff //随机颜色
        geometry.faces[i].color.setHex(hex)
        geometry.faces[i + 1].color.setHex(hex)
      }
      var material = new THREE.MeshBasicMaterial({
        vertexColors: THREE.FaceColors,
      })
      mesh = new THREE.Mesh(geometry, material)
      mesh.position = new THREE.Vector3(0, 0, 0)

      //不同于平时的绕几何体几何中心的旋转
      //在这一步多加一个组对象,旋转组对象即可,改变物体在组对象的相对位置
      group = new THREE.Group()

      boxHelper = new THREE.BoxHelper(mesh)
      group.add(boxHelper)
      scene.add(group)
    }

    //辅助线
    function initGrid() {
      //参数代表网格的长宽和每一行分多少份
      var helper = new THREE.GridHelper(window.innerWidth, 20, 0xff00ff)
      //helper.setColors(0x000fff, 0x808080);
      scene.add(helper)
    }

    //帧循环
    var v1 = new THREE.Vector3(0, 1, 0).normalize() //旋转轴
    function animate() {
      group.rotateOnAxis(v1, 0.03)
      renderer.render(scene, camera)
      requestAnimationFrame(animate)
    }
  },
}
</script>
```

:::

## 9.粒子系统

:::demo

```vue
<template>
  <div class="three"></div>
</template>
<script>
export default {
  mounted() {
    //TODO:粒子系统
    //import * as THREE from '../js/three.module.js';
    var renderer,
      camera,
      scene,
      gui,
      stats,
      ambientLight,
      directionalLight,
      control,
      parent
    function initRender() {
      renderer = new THREE.WebGLRenderer({ antialias: true })
      renderer.setSize(window.innerWidth, window.innerHeight)
      //渲染器渲染阴影效果
      renderer.shadowMap.enabled = true
      renderer.shadowMap.type = THREE.PCFSoftShadowMap // 默认的是，没有设置的这个清晰 THREE.PCFShadowMap
      document.body.appendChild(renderer.domElement)
    }

    function initCamera() {
      camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        10000
      )
      camera.position.set(0, 100, 500)
      camera.lookAt(new THREE.Vector3(0, 0, 0))
    }

    function initScene() {
      scene = new THREE.Scene()
    }

    function initGui() {
      //声明一个保存需求修改的相关数据的对象
      gui = {}

      var datGui = new dat.GUI()
      //将设置属性添加到gui当中，gui.add(对象，属性，最小值，最大值）
    }

    function initLight() {
      ambientLight = new THREE.AmbientLight("#ffffff")
      scene.add(ambientLight)

      directionalLight = new THREE.DirectionalLight("#ffffff")
      directionalLight.position.set(40, 60, 10)

      directionalLight.shadow.camera.near = 1 //产生阴影的最近距离
      directionalLight.shadow.camera.far = 400 //产生阴影的最远距离
      directionalLight.shadow.camera.left = -50 //产生阴影距离位置的最左边位置
      directionalLight.shadow.camera.right = 50 //最右边
      directionalLight.shadow.camera.top = 50 //最上边
      directionalLight.shadow.camera.bottom = -50 //最下面

      //这两个值决定生成阴影密度 默认512
      directionalLight.shadow.mapSize.height = 1024
      directionalLight.shadow.mapSize.width = 1024

      //平行光开启阴影投射
      directionalLight.castShadow = true

      scene.add(directionalLight)
    }

    function initModel() {
      //底部平面
      var planeGeometry = new THREE.PlaneGeometry(100, 100)
      var planeMaterial = new THREE.MeshBasicMaterial({
        color: 0xff00ab,
        side: THREE.DoubleSide,
      })
      var plane = new THREE.Mesh(planeGeometry, planeMaterial)
      plane.rotation.x = -0.5 * Math.PI
      plane.position.y = -0.1
      plane.receiveShadow = true //可以接收阴影
      scene.add(plane)
      //创建OBJ加载器
      var objLoader = new THREE.OBJLoader()
      objLoader.setPath("../js/models/obj/")
      objLoader.load("female02.obj", function (object) {
        //onload函数
        object.scale.set(0.3, 0.3, 0.3)
        //设置材质
        for (let i = 0; i < object.children.length; i++) {
          var mat = object.children[i].material
          mat.color.set(0xffffff)
          mat.wireframe = true
        }
        scene.add(object)
      })
      parent = new THREE.Object3D()
      //粒子系统
      var grid = new THREE.Points(
        new THREE.PlaneBufferGeometry(15000, 15000, 64, 64),
        new THREE.PointsMaterial({
          color: 0xf23ac0,
          size: 10,
        })
      )
      parent.add(grid)
      scene.add(parent)
    }

    function initStats() {
      stats = new Stats()
      document.body.appendChild(stats.dom)
    }

    function initControl() {
      control = new THREE.OrbitControls(camera, renderer.domElement)
    }

    function render() {
      control.update()
      renderer.render(scene, camera)
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight
      camera.updateProjectionMatrix()
      renderer.setSize(window.innerWidth, window.innerHeight)
    }

    function animate() {
      //更新控制器
      render()
      parent.rotation.x += 0.01
      parent.rotation.y += 0.01
      parent.rotation.z += 0.01
      //更新性能插件
      stats.update()

      requestAnimationFrame(animate)
    }

    function draw() {
      initGui()
      initRender()
      initScene()
      initCamera()
      initLight()
      initModel()
      initStats()

      initControl()

      animate()
      window.onresize = onWindowResize
    }
  },
}
</script>
```

:::

## 10.粒子系统\_人物模型粒子化

:::demo

```vue
<template>
  <div class="three"></div>
</template>
<script>
export default {
  mounted() {
    //TODO:粒子系统_人物模型粒子化
    //import * as THREE from '../js/three.module.js';
    var renderer,
      camera,
      scene,
      gui,
      stats,
      ambientLight,
      directionalLight,
      control,
      parent
    function initRender() {
      renderer = new THREE.WebGLRenderer({ antialias: true })
      renderer.setSize(window.innerWidth, window.innerHeight)
      //渲染器渲染阴影效果
      renderer.shadowMap.enabled = true
      renderer.shadowMap.type = THREE.PCFSoftShadowMap // 默认的是，没有设置的这个清晰 THREE.PCFShadowMap
      document.body.appendChild(renderer.domElement)
    }

    function initCamera() {
      camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        10000
      )
      camera.position.set(0, 100, 2000)
      camera.lookAt(new THREE.Vector3(0, 0, 0))
    }

    function initScene() {
      scene = new THREE.Scene()
    }

    function initGui() {
      //声明一个保存需求修改的相关数据的对象
      gui = {}

      var datGui = new dat.GUI()
      //将设置属性添加到gui当中，gui.add(对象，属性，最小值，最大值）
    }

    function initLight() {
      ambientLight = new THREE.AmbientLight("#ffffff")
      scene.add(ambientLight)

      directionalLight = new THREE.DirectionalLight("#ffffff")
      directionalLight.position.set(40, 60, 10)

      directionalLight.shadow.camera.near = 1 //产生阴影的最近距离
      directionalLight.shadow.camera.far = 400 //产生阴影的最远距离
      directionalLight.shadow.camera.left = -50 //产生阴影距离位置的最左边位置
      directionalLight.shadow.camera.right = 50 //最右边
      directionalLight.shadow.camera.top = 50 //最上边
      directionalLight.shadow.camera.bottom = -50 //最下面

      //这两个值决定生成阴影密度 默认512
      directionalLight.shadow.mapSize.height = 1024
      directionalLight.shadow.mapSize.width = 1024

      //平行光开启阴影投射
      directionalLight.castShadow = true

      scene.add(directionalLight)
    }

    function initModel() {
      //底部平面
      var planeGeometry = new THREE.PlaneGeometry(1000, 1000)
      //console.log(planeGeometry)
      var planeMaterial = new THREE.MeshBasicMaterial({
        color: 0xaaaaaa,
        side: THREE.DoubleSide,
      })
      var plane = new THREE.Mesh(planeGeometry, planeMaterial)
      plane.rotation.x = -0.5 * Math.PI
      plane.position.y = -2
      plane.receiveShadow = true //可以接收阴影
      //创建OBJ加载器
      var objLoader = new THREE.OBJLoader()
      objLoader.setPath("../js/models/obj/")
      parent = new THREE.Group()
      objLoader.load("female02.obj", function (object) {
        //onload函数
        object.scale.set(0.3, 0.3, 0.3)
        colorRandom = []
        for (let i = 0; i < 5; i++) {
          colorRandom.push(0xffffff * Math.random())
        }

        //设置材质
        for (let i = 0; i < object.children.length; i++) {
          var child = object.children[i]
          //顶点数组
          child.geometry.vertices = []
          for (let j = 0; j < child.geometry.attributes.position.count; j++) {
            var pos = child.geometry.attributes.position
            child.geometry.vertices[j] = new THREE.Vector3(
              pos.getX(j),
              pos.getY(j),
              pos.getZ(j)
            )
          }
          createMesh(child.geometry, scene, 2, 0, 0, 0, colorRandom, true)
          //body.add(grid)
        }
        parent.add(plane)
        parent.position.y = 0
        scene.add(parent)
      })
    }
    var clonesMeshes = []
    var meshes = []
    //粒子动画
    function createMesh(
      originalGeometry,
      scene,
      scale,
      x,
      y,
      z,
      color,
      dynamic
    ) {
      //获取顶点位置
      var vertices = originalGeometry.vertices //顶点数组
      var vLength = vertices.length //顶点数组长度

      //几何体对象
      var geometry = new THREE.Geometry()
      //存放几何体顶点和相关属性的数组
      var vertices_tmp = [] //x,y,z,down,up
      for (var i = 0; i < vLength; i++) {
        var p = vertices[i]
        geometry.vertices[i] = p.clone()

        vertices_tmp[i] = [p.x, p.y, p.z, 0, 0]
      }
      //模型的位置
      var clones = [
        [400, 0, 400],
        [-400, 0, -400],
        [-400, 0, 400],
        [400, 0, -400],
        [0, 0, 0],
      ]
      //处理模型由上到下的坍塌动画,静态动态物体
      if (dynamic) {
        for (let i = 0; i < clones.length; i++) {
          c = color[i]
          mesh = new THREE.Points(
            geometry,
            new THREE.PointsMaterial({
              color: c,
              size: 5,
            })
          )
          mesh.scale.x = mesh.scale.y = mesh.scale.z = scale
          mesh.position.x = x + clones[i][0]
          mesh.position.y = y + clones[i][1]
          mesh.position.z = z + clones[i][2]
          parent.add(mesh)
          //管理对象
          clonesMeshes.push({ mesh: mesh, speed: 0.5 + Math.random() })
        }
      } else {
        mesh = new THREE.Points(
          geometry,
          new THREE.PointsMaterial({
            color: color,
            size: 1,
          })
        )
        mesh.scale.x = mesh.scale.y = mesh.scale.z = scale
        mesh.position.x = x
        mesh.position.y = y
        mesh.position.z = z
        parent.add(mesh)
      }
      //初始化参数
      meshes.push({
        mesh: mesh,
        vertices: geometry.vertices,
        vertices_tmp: vertices_tmp,
        vLength: vLength,
        down: 0,
        up: 0,
        speed: 80,
        delay: Math.floor(200 + 200 * Math.random()),
        started: false,
        start: 100, //各部分开始崩塌的时间
        dynamic: dynamic,
        direction: 0,
      })
    }

    function initStats() {
      stats = new Stats()
      document.body.appendChild(stats.dom)
    }

    function initControl() {
      control = new THREE.OrbitControls(camera, renderer.domElement)
    }
    var clock = new THREE.Clock()
    var index = 0
    function render() {
      //计算每一帧的时间
      var delta = clock.getDelta()
      var delta = delta < 2 ? delta : 2
      parent.rotation.y += -0.5 * delta
      //根据动态还是静态来计算模型顶点位置
      for (index = 0; index < meshes.length; index++) {
        data = meshes[index]
        mesh = data.mesh
        vertices = data.vertices
        vertices_tmp = data.vertices_tmp
        vLength = data.vLength
        if (data.dynamic == false) {
          continue
        }
        //最开始,没有移动,设置向下移动
        if (data.start > 0) {
          data.start -= 1
        } else {
          //开始动画
          if (!data.started) {
            data.direction = -1
            data.started = true
          }
        }
        //移动每一个顶点
        for (var i = 0; i < vLength; i++) {
          var p = vertices[i]
          var vt = vertices_tmp[i]
          if (data.direction < 0) {
            if (p.y > 0) {
              //在每一个时间片段-0.5 ~ +0.5,左右移动
              //1.5扩散范围,100左右类似爆破效果
              p.x += 1.5 * (0.5 - Math.random()) * data.speed * delta
              //向下的概率大于向上的概率,总体趋势向下
              p.y += 3 * (0.15 - Math.random()) * data.speed * delta
              p.z += 1.5 * (0.5 - Math.random()) * data.speed * delta
            } else {
              if (!vt[3]) {
                //0代表向下
                vt[3] = 1
                data.down += 1
              }
            }
          }
          if (data.direction > 0) {
            var d =
              Math.abs(p.x - vt[0]) +
              Math.abs(p.y - vt[1]) +
              Math.abs(p.z - vt[2])
            if (d > 1) {
              p.x +=
                (-(p.x - vt[0]) / d) *
                data.speed *
                delta *
                (0.75 - Math.random())
              p.y +=
                (-(p.y - vt[1]) / d) * data.speed * delta * (1 + Math.random())
              p.z +=
                (-(p.z - vt[2]) / d) *
                data.speed *
                delta *
                (0.75 - Math.random())
            } else {
              if (!vt[4]) {
                vt[4] = 1
                data.up += 1
              }
            }
          }
        }
        //初始化数据
        if (data.down === vLength) {
          if (data.delay === 0) {
            data.direction = 1
            data.speed = 80
            data.down = 0
            data.delay = 300
            for (let i = 0; i < vLength; i++) {
              vertices_tmp[i][3] = 0
            }
          } else {
            data.delay -= 1
          }
        }
        if (data.up === vLength) {
          if (data.delay === 0) {
            data.direction = -1
            data.speed = 80
            data.up = 0
            data.delay = 300
            for (let i = 0; i < vLength; i++) {
              vertices_tmp[i][4] = 0
            }
          } else {
            data.delay -= 1
          }
        }
        //这个参数设置为true,GPU才会去刷新顶点的位置
        mesh.geometry.verticesNeedUpdate = true
      }
      control.update()
      renderer.render(scene, camera)
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight
      camera.updateProjectionMatrix()
      renderer.setSize(window.innerWidth, window.innerHeight)
    }

    function animate() {
      //更新控制器
      render()
      // parent.rotation.x+=0.01;
      // parent.rotation.y += 0.01;
      //更新性能插件
      stats.update()

      requestAnimationFrame(animate)
    }
    //初始化函数
    function draw() {
      initGui()
      initRender()
      initScene()
      initCamera()
      initLight()
      initModel()
      initStats()
      initControl()
      animate()
      window.onresize = onWindowResize
    }
  },
}
</script>
```

:::

## 11.贝塞尔曲线和绘制路径

:::demo

```vue
<template>
  <div class="three"></div>
</template>
<script>
export default {
  mounted() {
    //TODO:贝塞尔曲线和绘制路径
    //绘图命令和点计算
    //为了不每调用一个函数就计算一次顶点,将每个与绘图相关的函数存为一条指令,最后一次性调用某个函数,生成所有顶点
    //这样不必在每个函数都单独的实现绘制顶点的方法,只需要一个函数在最后的时候,去生成所有的顶点,提高效率
    //import * as THREE from '../js/three.module.js';
    var container, stats
    var camera, scene, renderer
    var group
    var targetRotation = 0
    var targetRotationOnMoUseDown = 0
    var mouseX = 0
    var mouseXOnMouseDown = 0
    var windowHalfX = window.innerWidth / 2
    var windowHalfY = window.innerHeight / 2
    var circleShape, line, points

    function init() {
      //创建canvas画布
      container = document.createElement("div")
      document.body.appendChild(container)

      var info = document.createElement("div")
      info.style.position = "absolute"
      info.style.top = "10px"
      info.style.width = "100%"
      info.style.textAlign = "center"
      info.innerHTML = "Simple procedurally generate 3D shapes<br/>Drag to spin"
      container.appendChild(info)

      //场景
      scene = new THREE.Scene()
      camera = new THREE.PerspectiveCamera(
        50,
        window.innerWidth / window.innerHeight,
        1,
        1000
      )
      camera.position.set(0, 150, 500)
      scene.add(camera)

      //灯光
      var light = new THREE.PointLight(0xffffff, 0.8)
      camera.add(light)

      //组对象
      group = new THREE.Group()
      group.position.y = 50
      scene.add(group)

      //贴图
      // var texture=THREE.ImageUtils.loadTexture("../images/joystick.png");
      // texture.wrapS=texture.wrapT=THREE.RepeatWrapping;
      // texture.repeat.set(0.008,0.008);

      //创建一个自定义的形状
      //THREE.Line本质是一个mesh
      function addShape(shape, color, x, y, z, rx, ry, rz, s) {
        points = shape.createPointsGeometry(50)
        points.vertices.push(new THREE.Vector3(180, 0, 0)) //把闭合点手动传入,使之成为闭合图形
        //参数列表 geometry 材质 模式
        line = new THREE.Line(
          points,
          new THREE.LineBasicMaterial({
            color: color,
          })
        )

        line.position.set(x, y, z - 25)
        line.rotation.set(rx, ry, rz)
        line.scale.set(s, s, s)
        group.add(line)
      }

      //circle
      var circleRadius = 180
      circleShape = new THREE.Shape()
      circleShape.moveTo(circleRadius, 0) //移动点到这个坐标
      circleShape.quadraticCurveTo(0, circleRadius, -circleRadius, 0) //贝塞尔曲线(4个参数为起始点xy和终点xy坐标)
      //circleShape.vertices.push(new THREE.Vector3(180, 0,0))
      //参数列表 shape 颜色 图形位置,x,y,z 旋转 x,y,z 缩放
      addShape(circleShape, 0x00f000, 0, 0, 0, 0, 0, 0, 1)

      renderer = new THREE.WebGLRenderer({ antialias: true })
      renderer.setClearColor(0xf0f0f0)
      renderer.setPixelRatio(window.devicePixelRatio)
      renderer.setSize(window.innerWidth, window.innerHeight)
      container.appendChild(renderer.domElement)
    }
    animate()
    function animate() {
      requestAnimationFrame(animate)
      if (renderer) {
        renderer.render(scene, camera)
      } else {
        console.log("render is undefined")
      }
    }
  },
}
</script>
```

:::

## 12.加载多个纹理贴图

:::demo

```vue
<template>
  <div class="three"></div>
</template>
<script>
export default {
  mounted() {
    //TODO:着色器
    //import * as THREE from '../js/three.module.js';
    var container, stats
    var camera, scene, renderer
    var group
    var targetRotation = 0
    var targetRotationOnMoUseDown = 0
    var windowHalfY = window.innerHeight / 2
    var circleShape, line, points

    function init() {
      //创建canvas画布
      container = document.createElement("div")
      document.body.appendChild(container)

      var info = document.createElement("div")
      info.style.position = "absolute"
      info.style.top = "10px"
      info.style.width = "100%"
      info.style.textAlign = "center"
      info.innerHTML = "Simple procedurally generate 3D shapes<br/>Drag to spin"
      container.appendChild(info)

      //场景
      scene = new THREE.Scene()
      camera = new THREE.PerspectiveCamera(
        50,
        window.innerWidth / window.innerHeight,
        1,
        1000
      )
      camera.position.set(0, 150, 500)
      scene.add(camera)

      //灯光
      var light = new THREE.PointLight(0xffffff, 0.8)
      camera.add(light)
    }
    animate()
    function animate() {
      requestAnimationFrame(animate)
      if (renderer) {
        renderer.render(scene, camera)
      } else {
        console.log("render is undefined")
      }
    }
  },
}
</script>
```

:::
