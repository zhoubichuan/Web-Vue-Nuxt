---
lang: zh-CN
sidebarDepth: 0
meta:
  - name: description
    content: 个人总结的vuepress学习技术文档-主题
  - name: keywords
    content: vuepress,最新技术文档,vuepress主题
---

# 十二.其他

## 1.多骨洛米骨牌

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    getPoints() {
      var points = []
      var r = 27
      var cX = 0
      var cY = 0
      var circleOffset = 0
      for (var i = 0; i < 1000; i += 6 + circleOffset) {
        circleOffset = 4.5 * (i / 360)
        var x = (r / 1440) * (1440 - i) * Math.cos(i * (Math.PI / 180)) + cX
        var z = (r / 1440) * (1440 - i) * Math.sin(i * (Math.PI / 180)) + cY
        var y = 0
        points.push(new THREE.Vector3(x, y, z))
      }
      return points
    },
    // 界面工具
    gui(controls) {
      var gui = new dat.GUI()
      gui.add(controls, "gravityX", -100, 100)
      gui.add(controls, "gravityY", -100, 100)
      gui.add(controls, "gravityZ", -100, 100)
      gui.add(controls, "resetScene")
      this.$refs.gui.appendChild(gui.domElement)
    },
    init() {
      var scale = chroma.scale(["green", "white"])
      Physijs.scripts.worker = this.$withBase("/libs/physijs_worker.js")
      Physijs.scripts.ammo = this.$withBase("/libs/ammo.js")
      var initScene,
        render,
        applyForce,
        setMousePosition,
        mouse_position,
        ground_material,
        box_material,
        renderer,
        render_stats,
        scene,
        ground,
        light,
        camera,
        box,
        boxes = []
      renderer = new THREE.WebGLRenderer({ antialias: true })
      renderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      renderer.setClearColor(new THREE.Color(0x000000))
      this.$refs.example.appendChild(renderer.domElement)
      render_stats = new Stats()
      render_stats.domElement.style.position = "absolute"
      render_stats.domElement.style.top = "1px"
      render_stats.domElement.style.zIndex = 100
      this.$refs.webgl.appendChild(render_stats.domElement)
      scene = new Physijs.Scene()
      scene.setGravity(new THREE.Vector3(0, -50, 0))
      camera = new THREE.PerspectiveCamera(
        35,
        window.innerWidth / window.innerHeight,
        1,
        1000
      )
      camera.position.set(50, 30, 50)
      camera.lookAt(new THREE.Vector3(10, 0, 10))
      scene.add(camera)
      light = new THREE.SpotLight(0xffffff)
      light.position.set(20, 100, 50)
      scene.add(light)
      this.createGround(
        this.$withBase("/assets/textures/general/wood-2.jpg"),
        scene
      )
      var points = this.getPoints()
      var stones = []
      requestAnimationFrame(render)
      function render() {
        requestAnimationFrame(render)
        renderer.render(scene, camera)
        render_stats.update()
        scene.simulate(undefined, 1)
      }
      var jpg = this.$withBase("/assets/textures/general/darker_wood.jpg")
      var controls = new (function () {
        this.gravityX = 0
        this.gravityY = -50
        this.gravityZ = 0
        this.resetScene = function () {
          scene.setGravity(
            new THREE.Vector3(
              controls.gravityX,
              controls.gravityY,
              controls.gravityZ
            )
          )
          stones.forEach(function (st) {
            scene.remove(st)
          })
          stones = []
          points.forEach(function (point) {
            var stoneGeom = new THREE.BoxGeometry(0.6, 6, 2)
            var stone = new Physijs.BoxMesh(
              stoneGeom,
              Physijs.createMaterial(
                new THREE.MeshPhongMaterial({
                  color: scale(Math.random()).hex(),
                  transparent: true,
                  opacity: 0.8,
                  // map: THREE.ImageUtils.loadTexture(jpg),
                })
              )
            )
            stone.position.copy(point)
            stone.lookAt(scene.position)
            stone.__dirtyRotation = true
            stone.position.y = 3.5
            scene.add(stone)
            stones.push(stone)
          })
          stones[0].rotation.x = 0.2
          stones[0].__dirtyRotation = true
        }
      })()
      this.gui(controls)
      controls.resetScene()
    },
    createGround(png, scene) {
      var ground_material = Physijs.createMaterial(
        new THREE.MeshPhongMaterial({
          map: THREE.ImageUtils.loadTexture(png),
        }),
        0.9,
        0.3
      )
      var ground = new Physijs.BoxMesh(
        new THREE.BoxGeometry(60, 1, 60),
        ground_material,
        0
      )
      var borderLeft = new Physijs.BoxMesh(
        new THREE.BoxGeometry(2, 3, 60),
        ground_material,
        0
      )
      borderLeft.position.x = -31
      borderLeft.position.y = 2
      ground.add(borderLeft)
      var borderRight = new Physijs.BoxMesh(
        new THREE.BoxGeometry(2, 3, 60),
        ground_material,
        0
      )
      borderRight.position.x = 31
      borderRight.position.y = 2
      ground.add(borderRight)
      var borderBottom = new Physijs.BoxMesh(
        new THREE.BoxGeometry(64, 3, 2),
        ground_material,
        0
      )
      borderBottom.position.z = 30
      borderBottom.position.y = 2
      ground.add(borderBottom)
      var borderTop = new Physijs.BoxMesh(
        new THREE.BoxGeometry(64, 3, 2),
        ground_material,
        0
      )
      borderTop.position.z = -30
      borderTop.position.y = 2
      ground.add(borderTop)
      scene.add(ground)
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 2.material-properties

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      Physijs.scripts.worker = this.$withBase("/libs/physijs_worker.js")
      Physijs.scripts.ammo = this.$withBase("/libs/ammo.js")
      var scale = chroma.scale(["white", "blue", "red", "yellow"])
      var initScene,
        render,
        applyForce,
        setMousePosition,
        mouse_position,
        ground_material,
        box_material,
        projector,
        renderer,
        render_stats,
        physics_stats,
        scene,
        ground,
        light,
        camera,
        box,
        boxes = []
      renderer = new THREE.WebGLRenderer({ antialias: true })
      renderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      renderer.setClearColor(new THREE.Color(0x000000))
      this.$refs.example.appendChild(renderer.domElement)
      render_stats = new Stats()
      render_stats.domElement.style.position = "absolute"
      render_stats.domElement.style.top = "1px"
      render_stats.domElement.style.zIndex = 100
      this.$refs.webgl.appendChild(render_stats.domElement)
      scene = new Physijs.Scene()
      scene.setGravity(new THREE.Vector3(0, -90, 0))
      camera = new THREE.PerspectiveCamera(
        35,
        window.innerWidth / window.innerHeight,
        1,
        1000
      )
      camera.position.set(80, 60, 80)
      camera.lookAt(scene.position)
      scene.add(camera)
      // Light
      light = new THREE.SpotLight(0xffffff)
      light.position.set(20, 100, 50)
      scene.add(light)
      // Materials
      ground_material = Physijs.createMaterial(
        new THREE.MeshPhongMaterial({
          map: THREE.ImageUtils.loadTexture(
            this.$withBase("/assets/textures/general/floor-wood.jpg")
          ),
        }),
        0.9, // high friction
        0.6 // low restitution
      )
      ground_material.map.wrapS = ground_material.map.wrapT =
        THREE.RepeatWrapping
      ground_material.map.repeat.set(4, 8)
      // Ground
      ground = new Physijs.BoxMesh(
        new THREE.BoxGeometry(60, 1, 130),
        ground_material,
        0 // mass
      )
      ground.receiveShadow = true
      var borderLeft = new Physijs.BoxMesh(
        new THREE.BoxGeometry(2, 6, 130),
        ground_material,
        0 // mass
      )
      borderLeft.position.x = -31
      borderLeft.position.y = 2
      ground.add(borderLeft)
      var borderRight = new Physijs.BoxMesh(
        new THREE.BoxGeometry(2, 6, 130),
        ground_material,
        0 // mass
      )
      borderRight.position.x = 31
      borderRight.position.y = 2
      ground.add(borderRight)
      var borderBottom = new Physijs.BoxMesh(
        new THREE.BoxGeometry(64, 6, 2),
        ground_material,
        0 // mass
      )
      borderBottom.position.z = 65
      borderBottom.position.y = 2
      ground.add(borderBottom)
      var borderTop = new Physijs.BoxMesh(
        new THREE.BoxGeometry(64, 6, 2),
        ground_material,
        0 // mass
      )
      borderTop.position.z = -65
      borderTop.position.y = 2
      ground.add(borderTop)
      //            var pilar_material = Physijs.createMaterial(
      //                    new THREE.MeshPhongMaterial({color:0xff3333}),
      //                    .3, // high friction
      //                    .9 // low restitution
      //            );
      //
      //            var pilar = new Physijs.CylinderMesh(new THREE.CylinderGeometry(2,2,24),pilar_material,0);
      //            ground.add(pilar);
      //
      //
      //            var pilar2 = new Physijs.CylinderMesh(new THREE.CylinderGeometry(2,2,24),pilar_material,0);
      //            pilar2.position.x=15;
      //            ground.add(pilar2);
      //
      //
      //            var pilar3 = new Physijs.CylinderMesh(new THREE.CylinderGeometry(2,2,24),pilar_material,0);
      //            ground.add(pilar3);
      //            pilar3.position.x=-15;

      scene.add(ground)

      var meshes = []

      var controls = new (function () {
        this.cubeRestitution = 0.4
        this.cubeFriction = 0.4
        this.sphereRestitution = 0.9
        this.sphereFriction = 0.1

        this.clearMeshes = function () {
          meshes.forEach(function (e) {
            scene.remove(e)
          })
          meshes = []
        }

        this.addSpheres = function () {
          var colorSphere = scale(Math.random()).hex()
          for (var i = 0; i < 5; i++) {
            box = new Physijs.SphereMesh(
              new THREE.SphereGeometry(2, 20),
              Physijs.createMaterial(
                new THREE.MeshPhongMaterial({
                  color: colorSphere,
                  opacity: 0.8,
                  transparent: true,
                  //                                                        map: THREE.ImageUtils.loadTexture( '../assets/textures/general/floor-wood.jpg' )
                }),
                controls.sphereFriction,
                controls.sphereRestitution
              )
            )
            box.position.set(
              Math.random() * 50 - 25,
              20 + Math.random() * 5,
              Math.random() * 50 - 25
            )
            meshes.push(box)
            scene.add(box)
          }
        }

        this.addCubes = function () {
          var colorBox = scale(Math.random()).hex()
          for (var i = 0; i < 5; i++) {
            box = new Physijs.BoxMesh(
              new THREE.BoxGeometry(4, 4, 4),
              //                            new THREE.SphereGeometry( 2, 20 ),
              Physijs.createMaterial(
                new THREE.MeshPhongMaterial({
                  color: colorBox,
                  opacity: 0.8,
                  transparent: true,
                  //                                                map: THREE.ImageUtils.loadTexture( '../assets/textures/general/stone.jpg' )
                }),
                controls.cubeFriction,
                controls.cubeRestitution
              )
            )
            box.position.set(
              Math.random() * 50 - 25,
              20 + Math.random() * 5,
              Math.random() * 50 - 25
            )
            box.rotation.set(
              Math.random() * Math.PI * 2,
              Math.random() * Math.PI * 2,
              Math.random() * Math.PI * 2
            )
            meshes.push(box)
            scene.add(box)
          }
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "cubeRestitution", 0, 1)
      gui.add(controls, "cubeFriction", 0, 1)
      gui.add(controls, "sphereRestitution", 0, 1)
      gui.add(controls, "sphereFriction", 0, 1)
      gui.add(controls, "addCubes")
      gui.add(controls, "addSpheres")
      gui.add(controls, "clearMeshes")
      this.$refs.gui.appendChild(gui.domElement)
      var stepX
      var direction = 1

      render = function () {
        requestAnimationFrame(render)
        renderer.render(scene, camera)
        render_stats.update()
        ground.rotation.x += 0.002 * direction

        if (ground.rotation.x < -0.4) direction = 1
        if (ground.rotation.x > 0.4) direction = -1
        ground.__dirtyRotation = true
        scene.simulate(undefined, 1)
      }
      requestAnimationFrame(render)
      scene.simulate()
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 3.shapes

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      Physijs.scripts.worker = this.$withBase("/libs/physijs_worker.js")
      Physijs.scripts.ammo = this.$withBase("/libs/ammo.js")

      var scale = chroma.scale(["blue", "white"])

      var initScene,
        render,
        applyForce,
        setMousePosition,
        mouse_position,
        ground_material,
        box_material,
        projector,
        renderer,
        render_stats,
        physics_stats,
        scene,
        ground,
        light,
        camera,
        box,
        boxes = []

      renderer = new THREE.WebGLRenderer({ antialias: true })
      renderer.setSize(window.innerWidth / 2, window.innerHeight / 2)

      renderer.setClearColor(new THREE.Color(0x000000))
      renderer.shadowMapEnabled = true

      this.$refs.example.appendChild(renderer.domElement)

      render_stats = new Stats()
      render_stats.domElement.style.position = "absolute"
      render_stats.domElement.style.top = "1px"
      render_stats.domElement.style.left = "1px"
      render_stats.domElement.style.zIndex = 100
      this.$refs.webgl.appendChild(render_stats.domElement)

      scene = new Physijs.Scene({ reportSize: 10, fixedTimeStep: 1 / 60 })

      scene.setGravity(new THREE.Vector3(0, -20, 0))

      camera = new THREE.PerspectiveCamera(
        35,
        window.innerWidth / window.innerHeight,
        1,
        1000
      )
      camera.position.set(105, 85, 85)
      camera.lookAt(new THREE.Vector3(0, 0, 0))
      scene.add(camera)

      // ambi
      var ambi = new THREE.AmbientLight(0x222222)
      scene.add(ambi)

      // Light
      light = new THREE.SpotLight(0xffffff)
      light.position.set(40, 50, 100)
      light.castShadow = true
      light.shadowMapDebug = true
      light.shadowCameraNear = 10
      light.shadowCameraFar = 200
      light.intensity = 1.5

      var meshes = []
      scene.add(light)

      //            createGround();

      var controls = new (function () {
        this.addSphereMesh = function () {
          var sphere = new Physijs.SphereMesh(
            new THREE.SphereGeometry(3, 20),
            getMaterial()
          )
          setPosAndShade(sphere)
          meshes.push(sphere)
          scene.add(sphere)
        }
        this.addBoxMesh = function () {
          var cube = new Physijs.BoxMesh(
            new THREE.BoxGeometry(4, 2, 6),
            getMaterial()
          )
          setPosAndShade(cube)

          meshes.push(cube)
          scene.add(cube)
        }

        this.addCylinderMesh = function () {
          var cylinder = new Physijs.CylinderMesh(
            new THREE.CylinderGeometry(2, 2, 6),
            getMaterial()
          )
          setPosAndShade(cylinder)

          meshes.push(cylinder)
          scene.add(cylinder)
        }
        this.addConeMesh = function () {
          var cone = new Physijs.ConeMesh(
            new THREE.CylinderGeometry(0, 3, 7, 20, 10),
            getMaterial()
          )
          setPosAndShade(cone)

          meshes.push(cone)
          scene.add(cone)
        }
        this.addPlaneMesh = function () {
          var plane = new Physijs.PlaneMesh(
            new THREE.PlaneGeometry(5, 5, 10, 10),
            getMaterial()
          )
          setPosAndShade(plane)

          meshes.push(plane)
          scene.add(plane)
        }
        this.addCapsuleMesh = function () {
          var merged = new THREE.Geometry()
          var cyl = new THREE.CylinderGeometry(2, 2, 6)
          var top = new THREE.SphereGeometry(2)
          var bot = new THREE.SphereGeometry(2)

          var matrix = new THREE.Matrix4()
          matrix.makeTranslation(0, 3, 0)
          top.applyMatrix(matrix)

          var matrix = new THREE.Matrix4()
          matrix.makeTranslation(0, -3, 0)
          bot.applyMatrix(matrix)

          // merge to create a capsule
          merged.merge(top)
          merged.merge(bot)
          merged.merge(cyl)

          // create a physijs capsule mesh
          var capsule = new Physijs.CapsuleMesh(merged, getMaterial())
          setPosAndShade(capsule)

          meshes.push(capsule)
          scene.add(capsule)
        }
        this.addConvexMesh = function () {
          var convex = new Physijs.ConvexMesh(
            new THREE.TorusKnotGeometry(0.5, 0.3, 64, 8, 2, 3, 10),
            getMaterial()
          )

          setPosAndShade(convex)

          meshes.push(convex)
          scene.add(convex)
        }

        this.clearMeshes = function () {
          meshes.forEach(function (e) {
            scene.remove(e)
          })
          meshes = []
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "addPlaneMesh")
      gui.add(controls, "addBoxMesh")
      gui.add(controls, "addSphereMesh")
      gui.add(controls, "addCylinderMesh")
      gui.add(controls, "addConeMesh")
      gui.add(controls, "addCapsuleMesh")
      gui.add(controls, "addConvexMesh")
      gui.add(controls, "clearMeshes")
      this.$refs.gui.appendChild(gui.domElement)
      var date = new Date()
      var pn = new Perlin("rnd" + date.getTime())
      var img = this.$withBase("/assets/textures/ground/grasslight-big.jpg")
      var map = createHeightMap(pn, img)
      scene.add(map)
      render = function () {
        requestAnimationFrame(render)
        renderer.render(scene, camera)
        render_stats.update()
        scene.simulate(undefined, 2)
      }
      requestAnimationFrame(render)
      scene.simulate()

      function createHeightMap(pn, img) {
        var ground_material = Physijs.createMaterial(
          new THREE.MeshLambertMaterial({
            map: THREE.ImageUtils.loadTexture(img),
          }),
          0.3, // high friction
          0.8 // low restitution
        )

        var ground_geometry = new THREE.PlaneGeometry(120, 100, 100, 100)
        for (var i = 0; i < ground_geometry.vertices.length; i++) {
          var vertex = ground_geometry.vertices[i]
          var value = pn.noise(vertex.x / 10, vertex.y / 10, 0)
          vertex.z = value * 10
        }
        ground_geometry.computeFaceNormals()
        ground_geometry.computeVertexNormals()

        var ground = new Physijs.HeightfieldMesh(
          ground_geometry,
          ground_material,
          0, // mass
          100,
          100
        )
        ground.rotation.x = Math.PI / -2
        ground.rotation.y = 0.4
        ground.receiveShadow = true

        return ground
      }

      function createShape() {
        // add 10 random spheres
        var points = []
        for (var i = 0; i < 30; i++) {
          var randomX = -5 + Math.round(Math.random() * 10)
          var randomY = -5 + Math.round(Math.random() * 10)
          var randomZ = -5 + Math.round(Math.random() * 10)

          points.push(new THREE.Vector3(randomX, randomY, randomZ))
        }

        // use the same points to create a convexgeometry
        var hullGeometry = new THREE.ConvexGeometry(points)
        return hullGeometry
      }

      function setPosAndShade(obj) {
        obj.position.set(Math.random() * 20 - 45, 40, Math.random() * 20 - 5)

        obj.rotation.set(
          Math.random() * 2 * Math.PI,
          Math.random() * 2 * Math.PI,
          Math.random() * 2 * Math.PI
        )
        obj.castShadow = true
      }

      function getMaterial() {
        var material = Physijs.createMaterial(
          new THREE.MeshLambertMaterial({
            color: scale(Math.random()).hex(),
            //                                opacity: 0.8,
            //                                transparent: true
          }),
          0.5,
          0.7
        )

        return material
      }

      function createGround() {
        var length = 120
        var width = 120
        // Materials
        ground_material = Physijs.createMaterial(
          new THREE.MeshPhongMaterial({
            //                                color: 0xaaaaaa,
            map: THREE.ImageUtils.loadTexture(
              this.$withBase("/assets/textures/general/floor-wood.jpg")
            ),
          }),
          1, // high friction
          0.7 // low restitution
        )

        // Ground
        ground = new Physijs.BoxMesh(
          new THREE.BoxGeometry(length, 1, width),
          ground_material,
          0 // mass
        )

        ground.receiveShadow = true

        var borderLeft = new Physijs.BoxMesh(
          new THREE.BoxGeometry(2, 6, width),
          ground_material,
          0 // mass
        )

        borderLeft.position.x = (-1 * length) / 2 - 1
        borderLeft.position.y = 2
        borderLeft.receiveShadow = true

        ground.add(borderLeft)

        var borderRight = new Physijs.BoxMesh(
          new THREE.BoxGeometry(2, 6, width),
          ground_material,
          0 // mass
        )
        borderRight.position.x = length / 2 + 1
        borderRight.position.y = 2
        borderRight.receiveShadow = true

        ground.add(borderRight)

        var borderBottom = new Physijs.BoxMesh(
          new THREE.BoxGeometry(width - 1, 6, 2),
          ground_material,
          0 // mass
        )

        borderBottom.position.z = width / 2
        borderBottom.position.y = 1.5
        borderBottom.receiveShadow = true
        ground.add(borderBottom)

        var borderTop = new Physijs.BoxMesh(
          new THREE.BoxGeometry(width, 6, 2),
          ground_material,
          0 // mass
        )

        borderTop.position.z = -width / 2
        borderTop.position.y = 2

        borderTop.receiveShadow = true

        ground.position.x = 0
        ground.position.z = 0
        ground.add(borderTop)

        ground.receiveShadow = true

        scene.add(ground)
      }
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 4.constraints

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      Physijs.scripts.worker = this.$withBase("/libs/physijs_worker.js")
      Physijs.scripts.ammo = this.$withBase("/libs/ammo.js")

      var scale = chroma.scale(["white", "blue", "red", "yellow"])

      var initScene,
        render,
        applyForce,
        setMousePosition,
        mouse_position,
        ground_material,
        box_material,
        projector,
        renderer,
        render_stats,
        physics_stats,
        scene,
        ground,
        light,
        camera,
        box,
        boxes = []

      projector = new THREE.Projector()

      renderer = new THREE.WebGLRenderer({ antialias: true })
      renderer.setSize(window.innerWidth / 2, window.innerHeight / 2)

      renderer.setClearColor(new THREE.Color(0x000000))
      renderer.shadowMapEnabled = true

      this.$refs.example.appendChild(renderer.domElement)

      render_stats = new Stats()
      render_stats.domElement.style.position = "absolute"
      render_stats.domElement.style.top = "1px"
      render_stats.domElement.style.right = "1px"
      render_stats.domElement.style.zIndex = 100
      this.$refs.webgl.appendChild(render_stats.domElement)

      scene = new Physijs.Scene({ reportSize: 10, fixedTimeStep: 1 / 60 })

      scene.setGravity(new THREE.Vector3(0, -10, 0))

      camera = new THREE.PerspectiveCamera(
        35,
        window.innerWidth / window.innerHeight,
        1,
        1000
      )
      camera.position.set(85, 65, 65)
      camera.lookAt(new THREE.Vector3(0, 0, 0))
      scene.add(camera)

      // Light
      light = new THREE.SpotLight(0xffffff)
      light.position.set(20, 50, 50)
      light.castShadow = true
      light.shadowMapDebug = true
      light.shadowCameraNear = 10
      light.shadowCameraFar = 100

      scene.add(light)

      var meshes = []

      createGround()
      var flipperLeftConstraint = createLeftFlipper()
      var flipperRightConstraint = createRightFlipper()
      var sliderBottomConstraint = createSliderBottom()
      var sliderTopConstraint = createSliderTop()
      var coneTwistConstraint = createConeTwist()

      var point2point = createPointToPoint(true)

      var controls = new (function () {
        this.enableMotor = false
        this.acceleration = 2
        this.velocity = -10

        this.enableConeTwistMotor = false
        this.motorTargetX = 0
        this.motorTargetY = 0
        this.motorTargetZ = 0

        this.updateCone = function () {
          if (controls.enableConeTwistMotor) {
            coneTwistConstraint.enableMotor()
            coneTwistConstraint.setMotorTarget(
              new THREE.Vector3(
                controls.motorTargetX,
                controls.motorTargetY,
                controls.motorTargetZ
              )
            )
          } else {
            coneTwistConstraint.disableMotor()
          }
        }

        this.updateMotor = function () {
          if (controls.enableMotor) {
            // velocity is the velocity we are going for.
            // acceleration is how fast we're going to reach it
            flipperLeftConstraint.disableMotor()
            flipperLeftConstraint.enableAngularMotor(
              controls.velocity,
              controls.acceleration
            )
            flipperRightConstraint.disableMotor()
            flipperRightConstraint.enableAngularMotor(
              -1 * controls.velocity,
              controls.acceleration
            )
          } else {
            flipperLeftConstraint.disableMotor()
            flipperRightConstraint.disableMotor()
          }
        }

        this.sliderLeft = function () {
          sliderBottomConstraint.disableLinearMotor()
          sliderBottomConstraint.enableLinearMotor(
            controls.velocity,
            controls.acceleration
          )
          sliderTopConstraint.disableLinearMotor()
          sliderTopConstraint.enableLinearMotor(
            controls.velocity,
            controls.acceleration
          )
        }

        this.sliderRight = function () {
          sliderBottomConstraint.disableLinearMotor()
          sliderBottomConstraint.enableLinearMotor(
            -1 * controls.velocity,
            controls.acceleration
          )
          sliderTopConstraint.disableLinearMotor()
          sliderTopConstraint.enableLinearMotor(
            -1 * controls.velocity,
            controls.acceleration
          )
        }

        this.clearMeshes = function () {
          meshes.forEach(function (e) {
            scene.remove(e)
          })
          meshes = []
        }

        this.addSpheres = function () {
          var colorSphere = scale(Math.random()).hex()
          for (var i = 0; i < 5; i++) {
            box = new Physijs.SphereMesh(
              new THREE.SphereGeometry(2, 20),
              Physijs.createMaterial(
                new THREE.MeshPhongMaterial({
                  color: colorSphere,
                  opacity: 0.8,
                  transparent: true,
                  //                                                        map: THREE.ImageUtils.loadTexture( '../assets/textures/general/floor-wood.jpg' )
                }),
                controls.sphereFriction,
                controls.sphereRestitution
              ),
              0.1
            )
            box.castShadow = true
            box.receiveShadow = true
            box.position.set(
              Math.random() * 50 - 25,
              20 + Math.random() * 5,
              Math.random() * 5
            )
            meshes.push(box)
            scene.add(box)
          }
        }
      })()

      controls.updateMotor()

      var gui = new dat.GUI()
      gui.domElement.style.position = "absolute"
      gui.domElement.style.top = "20px"
      gui.domElement.style.left = "20px"

      var generalFolder = gui.addFolder("general")
      generalFolder
        .add(controls, "acceleration", 0, 15)
        .onChange(controls.updateMotor)
      generalFolder
        .add(controls, "velocity", -10, 10)
        .onChange(controls.updateMotor)
      
      var hingeFolder = gui.addFolder("hinge")
      hingeFolder.add(controls, "enableMotor").onChange(controls.updateMotor)

      var sliderFolder = gui.addFolder("sliders")
      sliderFolder.add(controls, "sliderLeft").onChange(controls.sliderLeft)
      sliderFolder.add(controls, "sliderRight").onChange(controls.sliderRight)

      var coneTwistFolder = gui.addFolder("coneTwist")
      coneTwistFolder
        .add(controls, "enableConeTwistMotor")
        .onChange(controls.updateCone)
      coneTwistFolder
        .add(controls, "motorTargetX", -Math.PI / 2, Math.PI / 2)
        .onChange(controls.updateCone)
      coneTwistFolder
        .add(controls, "motorTargetY", -Math.PI / 2, Math.PI / 2)
        .onChange(controls.updateCone)
      coneTwistFolder
        .add(controls, "motorTargetZ", -Math.PI / 2, Math.PI / 2)
        .onChange(controls.updateCone)

      var spheresFolder = gui.addFolder("spheres")
      spheresFolder.add(controls, "clearMeshes").onChange(controls.updateMotor)
      spheresFolder.add(controls, "addSpheres").onChange(controls.updateMotor)
      this.$refs.gui.appendChild(gui.domElement)
      render = function () {
        requestAnimationFrame(render)
        renderer.render(scene, camera)
        render_stats.update()
        ground.__dirtyRotation = true
        scene.simulate(undefined, 2)
      }
      requestAnimationFrame(render)
      scene.simulate()

      function createGround() {
        // Materials
        ground_material = Physijs.createMaterial(
          new THREE.MeshPhongMaterial({
            //                                color: 0xaaaaaa,
            map: THREE.ImageUtils.loadTexture(
              "../assets/textures/general/floor-wood.jpg"
            ),
          }),
          0.9, // high friction
          0.7 // low restitution
        )

        // Ground
        ground = new Physijs.BoxMesh(
          new THREE.BoxGeometry(60, 1, 65),
          ground_material,
          0 // mass
        )

        ground.receiveShadow = true

        var borderLeft = new Physijs.BoxMesh(
          new THREE.BoxGeometry(2, 6, 65),
          ground_material,
          0 // mass
        )

        borderLeft.position.x = -31
        borderLeft.position.y = 2
        borderLeft.receiveShadow = true

        ground.add(borderLeft)

        var borderRight = new Physijs.BoxMesh(
          new THREE.BoxGeometry(2, 6, 65),
          ground_material,
          0 // mass
        )
        borderRight.position.x = 31
        borderRight.position.y = 2
        borderRight.receiveShadow = true

        ground.add(borderRight)

        var borderBottom = new Physijs.BoxMesh(
          new THREE.BoxGeometry(64, 6, 2),
          ground_material,
          0 // mass
        )

        borderBottom.position.z = 32
        borderBottom.position.y = 1.5
        borderBottom.receiveShadow = true
        ground.add(borderBottom)

        var borderTop = new Physijs.BoxMesh(
          new THREE.BoxGeometry(64, 6, 2),
          ground_material,
          0 // mass
        )

        borderTop.position.z = -32
        borderTop.position.y = 2
        borderTop.receiveShadow = true

        ground.add(borderTop)

        ground.receiveShadow = true

        scene.add(ground)
      }

      function createConeTwist() {
        var baseMesh = new THREE.SphereGeometry(1)
        var armMesh = new THREE.BoxGeometry(2, 12, 3)

        var objectOne = new Physijs.BoxMesh(
          baseMesh,
          Physijs.createMaterial(
            new THREE.MeshPhongMaterial({
              color: 0x4444ff,
              transparent: true,
              opacity: 0.7,
            }),
            0,
            0
          ),
          0
        )
        objectOne.position.z = 0
        objectOne.position.x = 20
        objectOne.position.y = 15.5
        objectOne.castShadow = true
        scene.add(objectOne)

        var objectTwo = new Physijs.SphereMesh(
          armMesh,
          Physijs.createMaterial(
            new THREE.MeshPhongMaterial({
              color: 0x4444ff,
              transparent: true,
              opacity: 0.7,
            }),
            0,
            0
          ),
          10
        )
        objectTwo.position.z = 0
        objectTwo.position.x = 20
        objectTwo.position.y = 7.5
        scene.add(objectTwo)

        objectTwo.castShadow = true

        //position is the position of the axis, relative to the ref, based on the current position
        var constraint = new Physijs.ConeTwistConstraint(
          objectOne,
          objectTwo,
          objectOne.position
        )

        scene.addConstraint(constraint)
        // set limit to quarter circle for each axis
        constraint.setLimit(0.5 * Math.PI, 0.5 * Math.PI, 0.5 * Math.PI)
        constraint.setMaxMotorImpulse(1)
        constraint.setMotorTarget(new THREE.Vector3(0, 0, 0)) // desired rotation

        return constraint
      }

      function createPointToPoint() {
        var obj1 = new THREE.SphereGeometry(2)
        var obj2 = new THREE.SphereGeometry(2)

        var objectOne = new Physijs.SphereMesh(
          obj1,
          Physijs.createMaterial(
            new THREE.MeshPhongMaterial({
              color: 0xff4444,
              transparent: true,
              opacity: 0.7,
            }),
            0,
            0
          )
        )
        objectOne.position.z = -18
        objectOne.position.x = -10
        objectOne.position.y = 2
        objectOne.castShadow = true
        scene.add(objectOne)

        var objectTwo = new Physijs.SphereMesh(
          obj2,
          Physijs.createMaterial(
            new THREE.MeshPhongMaterial({
              color: 0xff4444,
              transparent: true,
              opacity: 0.7,
            }),
            0,
            0
          )
        )
        objectTwo.position.z = -5
        objectTwo.position.x = -20
        objectTwo.position.y = 2
        objectTwo.castShadow = true
        scene.add(objectTwo)

        // if no position two, its fixed to a position. Else fixed to objectTwo and both will move
        var constraint = new Physijs.PointConstraint(
          objectOne,
          objectTwo,
          objectTwo.position
        )
        scene.addConstraint(constraint)
      }

      function createSliderBottom() {
        var sliderCube = new THREE.BoxGeometry(12, 2, 2)

        var sliderMesh = new Physijs.BoxMesh(
          sliderCube,
          Physijs.createMaterial(
            new THREE.MeshPhongMaterial({
              color: 0x44ff44,
              opacity: 0.6,
              transparent: true,
            }),
            0,
            0
          ),
          0.01
        )
        sliderMesh.position.z = 20
        sliderMesh.position.x = 6
        sliderMesh.position.y = 1.5
        sliderMesh.castShadow = true

        scene.add(sliderMesh)
        var constraint = new Physijs.SliderConstraint(
          sliderMesh,
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(0, 1, 0)
        )

        scene.addConstraint(constraint)
        constraint.setLimits(-10, 10, 0, 0)
        constraint.setRestitution(0.1, 0.1)

        return constraint
      }

      function createSliderTop() {
        var sliderSphere = new THREE.BoxGeometry(7, 2, 7)

        var sliderMesh = new Physijs.BoxMesh(
          sliderSphere,
          Physijs.createMaterial(
            new THREE.MeshPhongMaterial({
              color: 0x44ff44,
              transparent: true,
              opacity: 0.5,
            }),
            0,
            0
          ),
          10
        )
        sliderMesh.position.z = -15
        sliderMesh.position.x = -20
        sliderMesh.position.y = 1.5
        scene.add(sliderMesh)
        sliderMesh.castShadow = true

        //position is the position of the axis, relative to the ref, based on the current position
        var constraint = new Physijs.SliderConstraint(
          sliderMesh,
          new THREE.Vector3(-10, 0, 20),
          new THREE.Vector3(Math.PI / 2, 0, 0)
        )

        scene.addConstraint(constraint)
        constraint.setLimits(-20, 10, 0.5, -0, 5)
        constraint.setRestitution(0.2, 0.1)

        return constraint
      }

      function createLeftFlipper() {
        var flipperLeft = new Physijs.BoxMesh(
          new THREE.BoxGeometry(12, 2, 2),
          Physijs.createMaterial(
            new THREE.MeshPhongMaterial({ opacity: 0.6, transparent: true })
          ),
          0.3
        )
        flipperLeft.position.x = -6
        flipperLeft.position.y = 2
        flipperLeft.position.z = 0
        flipperLeft.castShadow = true
        scene.add(flipperLeft)
        var flipperLeftPivot = new Physijs.SphereMesh(
          new THREE.BoxGeometry(1, 1, 1),
          ground_material,
          0
        )

        flipperLeftPivot.position.y = 1
        flipperLeftPivot.position.x = -15
        flipperLeftPivot.position.z = 0
        flipperLeftPivot.rotation.y = 1.4
        flipperLeftPivot.castShadow = true

        scene.add(flipperLeftPivot)

        // when looking at the axis, the axis of object two are used.
        // so as long as that one is the same as the scene, no problems
        // rotation and axis are relative to object2. If position == cube2.position it works as expected
        var constraint = new Physijs.HingeConstraint(
          flipperLeft,
          flipperLeftPivot,
          flipperLeftPivot.position,
          new THREE.Vector3(0, 1, 0)
        )
        scene.addConstraint(constraint)

        constraint.setLimits(
          -2.2, // minimum angle of motion, in radians, from the point object 1 starts (going back)
          -0.6, // maximum angle of motion, in radians, from the point object 1 starts (going forward)
          0.1, // applied as a factor to constraint error, how big the kantelpunt is moved when a constraint is hit
          0 // controls bounce at limit (0.0 == no bounce)
        )

        return constraint
      }

      function createRightFlipper() {
        var flipperright = new Physijs.BoxMesh(
          new THREE.BoxGeometry(12, 2, 2),
          Physijs.createMaterial(
            new THREE.MeshPhongMaterial({ opacity: 0.6, transparent: true })
          ),
          0.3
        )
        flipperright.position.x = 8
        flipperright.position.y = 2
        flipperright.position.z = 0
        flipperright.castShadow = true
        scene.add(flipperright)
        var flipperLeftPivot = new Physijs.SphereMesh(
          new THREE.BoxGeometry(1, 1, 1),
          ground_material,
          0
        )

        flipperLeftPivot.position.y = 2
        flipperLeftPivot.position.x = 15
        flipperLeftPivot.position.z = 0
        flipperLeftPivot.rotation.y = 1.4
        flipperLeftPivot.castShadow = true

        scene.add(flipperLeftPivot)

        // when looking at the axis, the axis of object two are used.
        // so as long as that one is the same as the scene, no problems
        // rotation and axis are relative to object2. If position == cube2.position it works as expected
        var constraint = new Physijs.HingeConstraint(
          flipperright,
          flipperLeftPivot,
          flipperLeftPivot.position,
          new THREE.Vector3(0, 1, 0)
        )
        //            var constraint = new Physijs.HingeConstraint(cube1, new THREE.Vector3(0,0,0), new THREE.Vector3(0,1,0));
        scene.addConstraint(constraint)

        constraint.setLimits(
          -2.2, // minimum angle of motion, in radians, from the point object 1 starts (going back)
          -0.6, // maximum angle of motion, in radians, from the point object 1 starts (going forward)
          0.1, // applied as a factor to constraint error, how big the kantelpunt is moved when a constraint is hit
          0 // controls bounce at limit (0.0 == no bounce)
        )

        return constraint
      }

      var direction = 1
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 5.dof-constraint

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      Physijs.scripts.worker = this.$withBase("/libs/physijs_worker.js")
      Physijs.scripts.ammo = this.$withBase("/libs/ammo.js")

      var scale = chroma.scale(["white", "blue", "red", "yellow"])

      var initScene,
        render,
        applyForce,
        setMousePosition,
        mouse_position,
        ground_material,
        box_material,
        projector,
        renderer,
        render_stats,
        physics_stats,
        scene,
        ground,
        light,
        camera,
        box,
        boxes = []

      renderer = new THREE.WebGLRenderer({ antialias: true })
      renderer.setSize(window.innerWidth / 2, window.innerHeight / 2)

      renderer.setClearColor(new THREE.Color(0x000000))
      renderer.shadowMapEnabled = true

      this.$refs.example.appendChild(renderer.domElement)

      render_stats = new Stats()
      render_stats.domElement.style.position = "absolute"
      render_stats.domElement.style.top = "1px"
      render_stats.domElement.style.left = "1px"
      render_stats.domElement.style.zIndex = 100
      this.$refs.webgl.appendChild(render_stats.domElement)

      scene = new Physijs.Scene({ reportSize: 10, fixedTimeStep: 1 / 60 })

      scene.setGravity(new THREE.Vector3(0, -40, 0))

      camera = new THREE.PerspectiveCamera(
        35,
        window.innerWidth / window.innerHeight,
        1,
        1000
      )
      camera.position.set(90, 90, 90)
      camera.lookAt(new THREE.Vector3(30, 0, -20))
      scene.add(camera)

      // Light
      light = new THREE.SpotLight(0xffffff)
      light.position.set(120, 70, 100)
      light.castShadow = true
      light.shadowMapDebug = true
      light.shadowCameraNear = 10
      light.shadowCameraFar = 200

      scene.add(light)

      var meshes = []

      createGround(this.$withBase("/assets/textures/general/floor-wood.jpg"))
      var car = createCar()

      var controls = new (function () {
        this.velocity = -2
        this.wheelAngle = 0.5

        this.loosenXRight = 0.0001
        this.loosenXLeft = 0.0001

        this.changeVelocity = function () {
          // if you add a motor, the current constraint is overridden
          // if you want to rotate set min higher then max
          car.flConstraint.configureAngularMotor(
            2,
            0.1,
            0,
            controls.velocity,
            15000
          )
          car.frConstraint.configureAngularMotor(
            2,
            0.1,
            0,
            controls.velocity,
            15000
          )

          // motor one is for left and right
          //                frConstraint.enableAngularMotor(1);

          // motor two is forward and backwards
          car.flConstraint.enableAngularMotor(2)
          car.frConstraint.enableAngularMotor(2)
        }

        this.changeOrientation = function () {
          car.rrConstraint.setAngularLowerLimit({
            x: 0,
            y: controls.wheelAngle,
            z: 0.1,
          })
          car.rrConstraint.setAngularUpperLimit({
            x: controls.loosenXRight,
            y: controls.wheelAngle,
            z: 0,
          })
          car.rlConstraint.setAngularLowerLimit({
            x: controls.loosenXLeft,
            y: controls.wheelAngle,
            z: 0.1,
          })
          car.rlConstraint.setAngularUpperLimit({
            x: 0,
            y: controls.wheelAngle,
            z: 0,
          })
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "velocity", -10, 10).onChange(controls.changeVelocity)
      gui
        .add(controls, "wheelAngle", -1, 1)
        .onChange(controls.changeOrientation)
      gui
        .add(controls, "loosenXRight", 0, 0.5)
        .step(0.01)
        .onChange(controls.changeOrientation)
      gui
        .add(controls, "loosenXLeft", 0, 0.6)
        .step(-0.01)
        .onChange(controls.changeOrientation)
      this.$refs.gui.appendChild(gui.domElement)
      controls.loosenXLeft = 0
      controls.loosenXRight = 0
      render = function () {
        requestAnimationFrame(render)
        renderer.render(scene, camera)
        render_stats.update()
        scene.simulate(undefined, 2)
      }
      requestAnimationFrame(render)
      scene.simulate()

      function createWheel(position) {
        var wheel_material = Physijs.createMaterial(
          new THREE.MeshLambertMaterial({
            color: 0x444444,
            opacity: 0.9,
            transparent: true,
          }),
          1.0, // high friction
          0.5 // medium restitution
        )

        var wheel_geometry = new THREE.CylinderGeometry(4, 4, 2, 10)
        var wheel = new Physijs.CylinderMesh(
          wheel_geometry,
          wheel_material,
          100
        )

        wheel.rotation.x = Math.PI / 2
        wheel.castShadow = true
        wheel.position.copy(position)
        return wheel
      }

      function createCar() {
        var car = {}
        var car_material = Physijs.createMaterial(
          new THREE.MeshLambertMaterial({
            color: 0xff4444,
            opacity: 0.9,
            transparent: true,
          }),
          0.5, // high friction
          0.5 // medium restitution
        )

        // create the car body
        var geom = new THREE.BoxGeometry(15, 4, 4)
        var body = new Physijs.BoxMesh(geom, car_material, 500)
        body.position.set(5, 5, 5)
        body.castShadow = true
        scene.add(body)

        // create the wheels
        var fr = createWheel(new THREE.Vector3(0, 4, 10))
        var fl = createWheel(new THREE.Vector3(0, 4, 0))
        var rr = createWheel(new THREE.Vector3(10, 4, 10))
        var rl = createWheel(new THREE.Vector3(10, 4, 0))

        // add the wheels to the scene
        scene.add(fr)
        scene.add(fl)
        scene.add(rr)
        scene.add(rl)

        var frConstraint = createWheelConstraint(
          fr,
          body,
          new THREE.Vector3(0, 4, 8)
        )
        scene.addConstraint(frConstraint)

        var flConstraint = createWheelConstraint(
          fl,
          body,
          new THREE.Vector3(0, 4, 2)
        )
        scene.addConstraint(flConstraint)

        var rrConstraint = createWheelConstraint(
          rr,
          body,
          new THREE.Vector3(10, 4, 8)
        )
        scene.addConstraint(rrConstraint)

        var rlConstraint = createWheelConstraint(
          rl,
          body,
          new THREE.Vector3(10, 4, 2)
        )
        scene.addConstraint(rlConstraint)

        // backwheels don't move themselves and are restriced in their
        // movement. They should be able to rotate along the z-axis
        // same here, if the complete angle is allowed set lower higher
        // than upper.
        // by setting the lower and upper to the same value you can
        // fix the position
        // we can set the x position to 'loosen' the axis for the directional
        rrConstraint.setAngularLowerLimit({ x: 0, y: 0.5, z: 0.1 })
        rrConstraint.setAngularUpperLimit({ x: 0, y: 0.5, z: 0 })
        rlConstraint.setAngularLowerLimit({ x: 0, y: 0.5, z: 0.1 })
        rlConstraint.setAngularUpperLimit({ x: 0, y: 0.5, z: 0 })

        // front wheels should only move along the z axis.
        // we don't need to specify anything here, since
        // that value is overridden by the motors
        frConstraint.setAngularLowerLimit({ x: 0, y: 0, z: 0 })
        frConstraint.setAngularUpperLimit({ x: 0, y: 0, z: 0 })
        flConstraint.setAngularLowerLimit({ x: 0, y: 0, z: 0 })
        flConstraint.setAngularUpperLimit({ x: 0, y: 0, z: 0 })

        // if you add a motor, the current constraint is overridden
        // if you want to rotate set min higher then max
        flConstraint.configureAngularMotor(2, 0.1, 0, -2, 1500)
        frConstraint.configureAngularMotor(2, 0.1, 0, -2, 1500)

        // motor one is for left and right
        //                frConstraint.enableAngularMotor(1);

        // motor two is forward and backwards
        flConstraint.enableAngularMotor(2)
        frConstraint.enableAngularMotor(2)

        car.flConstraint = flConstraint
        car.frConstraint = frConstraint
        car.rlConstraint = rlConstraint
        car.rrConstraint = rrConstraint

        return car
      }

      function createWheelConstraint(wheel, body, position) {
        var constraint = new Physijs.DOFConstraint(wheel, body, position)

        return constraint
      }

      function createGround(jpg) {
        var length = 120
        var width = 120
        // Materials
        ground_material = Physijs.createMaterial(
          new THREE.MeshPhongMaterial({
            //                                color: 0xaaaaaa,
            map: THREE.ImageUtils.loadTexture(jpg),
          }),
          1, // high friction
          0.7 // low restitution
        )

        // Ground
        ground = new Physijs.BoxMesh(
          new THREE.BoxGeometry(length, 1, width),
          ground_material,
          0 // mass
        )

        ground.receiveShadow = true

        var borderLeft = new Physijs.BoxMesh(
          new THREE.BoxGeometry(2, 6, width),
          ground_material,
          0 // mass
        )

        borderLeft.position.x = (-1 * length) / 2 - 1
        borderLeft.position.y = 2
        borderLeft.receiveShadow = true

        ground.add(borderLeft)

        var borderRight = new Physijs.BoxMesh(
          new THREE.BoxGeometry(2, 6, width),
          ground_material,
          0 // mass
        )
        borderRight.position.x = length / 2 + 1
        borderRight.position.y = 2
        borderRight.receiveShadow = true

        ground.add(borderRight)

        var borderBottom = new Physijs.BoxMesh(
          new THREE.BoxGeometry(width - 1, 6, 2),
          ground_material,
          0 // mass
        )

        borderBottom.position.z = width / 2
        borderBottom.position.y = 1.5
        borderBottom.receiveShadow = true
        ground.add(borderBottom)

        var borderTop = new Physijs.BoxMesh(
          new THREE.BoxGeometry(width, 6, 2),
          ground_material,
          0 // mass
        )

        borderTop.position.z = -width / 2
        borderTop.position.y = 2

        borderTop.receiveShadow = true

        ground.position.x = 20
        ground.position.z = -20
        ground.add(borderTop)

        ground.receiveShadow = true

        scene.add(ground)
      }
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::
