---
lang: zh-CN
sidebarDepth: 0
meta:
  - name: description
    content: 个人总结的vuepress学习技术文档-主题
  - name: keywords
    content: vuepress,最新技术文档,vuepress主题
---

# 五.二维几何

## 1.平面

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      var plane = createMesh(new THREE.PlaneGeometry(10, 14, 4, 4))
      // add the sphere to the scene
      scene.add(plane)

      // position and point the camera to the center of the scene
      camera.position.x = -20
      camera.position.y = 30
      camera.position.z = 40
      camera.lookAt(new THREE.Vector3(10, 0, 0))

      // add spotlight for the shadows
      var spotLight = new THREE.SpotLight(0xffffff)
      spotLight.position.set(-40, 60, -10)
      scene.add(spotLight)

      // add the output of the renderer to the html element
      document
        .getElementById("WebGL-output")
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      // setup the control gui
      var controls = new (function () {
        // we need the first child, since it's a multimaterial

        this.width = plane.children[0].geometry.parameters.width
        this.height = plane.children[0].geometry.parameters.height

        this.widthSegments = plane.children[0].geometry.parameters.widthSegments
        this.heightSegments =
          plane.children[0].geometry.parameters.heightSegments

        this.redraw = function () {
          // remove the old plane
          scene.remove(plane)
          // create a new one
          plane = createMesh(
            new THREE.PlaneGeometry(
              controls.width,
              controls.height,
              Math.round(controls.widthSegments),
              Math.round(controls.heightSegments)
            )
          )
          // add it to the scene.
          scene.add(plane)
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "width", 0, 40).onChange(controls.redraw)
      gui.add(controls, "height", 0, 40).onChange(controls.redraw)
      gui.add(controls, "widthSegments", 0, 10).onChange(controls.redraw)
      gui.add(controls, "heightSegments", 0, 10).onChange(controls.redraw)
      render()

      function createMesh(geom) {
        // assign two materials
        var meshMaterial = new THREE.MeshNormalMaterial()
        meshMaterial.side = THREE.DoubleSide
        var wireFrameMat = new THREE.MeshBasicMaterial()
        wireFrameMat.wireframe = true

        // create a multimaterial
        var plane = THREE.SceneUtils.createMultiMaterialObject(geom, [
          meshMaterial,
          wireFrameMat,
        ])

        return plane
      }

      function render() {
        stats.update()

        plane.rotation.y = step += 0.01

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 2.圆圈

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      var scene = new THREE.Scene()

      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      var circle = createMesh(
        new THREE.CircleGeometry(4, 10, 0.3 * Math.PI * 2, 0.3 * Math.PI * 2)
      )
      // add the sphere to the scene
      scene.add(circle)

      // position and point the camera to the center of the scene
      camera.position.x = -20
      camera.position.y = 30
      camera.position.z = 40
      camera.lookAt(new THREE.Vector3(10, 0, 0))

      // add spotlight for the shadows
      var spotLight = new THREE.SpotLight(0xffffff)
      spotLight.position.set(-40, 60, -10)
      scene.add(spotLight)

      // add the output of the renderer to the html element
      document
        .getElementById("WebGL-output")
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      // setup the control gui
      var controls = new (function () {
        // we need the first child, since it's a multimaterial

        console.log(circle.children[0].geometry)
        this.radius = 4

        this.thetaStart = 0.3 * Math.PI * 2
        this.thetaLength = 0.3 * Math.PI * 2
        this.segments = 10

        this.redraw = function () {
          // remove the old plane
          scene.remove(circle)
          // create a new one
          circle = createMesh(
            new THREE.CircleGeometry(
              controls.radius,
              controls.segments,
              controls.thetaStart,
              controls.thetaLength
            )
          )
          // add it to the scene.
          scene.add(circle)
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "radius", 0, 40).onChange(controls.redraw)
      gui.add(controls, "segments", 0, 40).onChange(controls.redraw)
      gui.add(controls, "thetaStart", 0, 2 * Math.PI).onChange(controls.redraw)
      gui.add(controls, "thetaLength", 0, 2 * Math.PI).onChange(controls.redraw)
      render()

      function createMesh(geom) {
        // assign two materials
        var meshMaterial = new THREE.MeshNormalMaterial()
        meshMaterial.side = THREE.DoubleSide
        var wireFrameMat = new THREE.MeshBasicMaterial()
        wireFrameMat.wireframe = true

        // create a multimaterial
        var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [
          meshMaterial,
          wireFrameMat,
        ])

        return mesh
      }

      function render() {
        stats.update()

        circle.rotation.y = step += 0.01

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 3.形状

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      var shape = createMesh(new THREE.ShapeGeometry(drawShape()))
      // add the sphere to the scene
      scene.add(shape)

      // position and point the camera to the center of the scene
      camera.position.x = -30
      camera.position.y = 70
      camera.position.z = 70
      camera.lookAt(new THREE.Vector3(10, 0, 0))

      // add spotlight for the shadows
      var spotLight = new THREE.SpotLight(0xffffff)
      spotLight.position.set(-40, 60, -10)
      scene.add(spotLight)

      // add the output of the renderer to the html element
      document
        .getElementById("WebGL-output")
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      // setup the control gui
      var controls = new (function () {
        this.asGeom = function () {
          // remove the old plane
          scene.remove(shape)
          // create a new one
          shape = createMesh(new THREE.ShapeGeometry(drawShape()))
          // add it to the scene.
          scene.add(shape)
        }

        this.asPoints = function () {
          // remove the old plane
          scene.remove(shape)
          // create a new one
          shape = createLine(drawShape(), false)
          // add it to the scene.
          scene.add(shape)
        }

        this.asSpacedPoints = function () {
          // remove the old plane
          scene.remove(shape)
          // create a new one
          shape = createLine(drawShape(), true)
          // add it to the scene.
          scene.add(shape)
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "asGeom")
      gui.add(controls, "asPoints")
      gui.add(controls, "asSpacedPoints")

      render()

      function drawShape() {
        // create a basic shape
        var shape = new THREE.Shape()

        // startpoint
        shape.moveTo(10, 10)

        // straight line upwards
        shape.lineTo(10, 40)

        // the top of the figure, curve to the right
        shape.bezierCurveTo(15, 25, 25, 25, 30, 40)

        // spline back down
        shape.splineThru([
          new THREE.Vector2(32, 30),
          new THREE.Vector2(28, 20),
          new THREE.Vector2(30, 10),
        ])

        // curve at the bottom
        shape.quadraticCurveTo(20, 15, 10, 10)

        // add 'eye' hole one
        var hole1 = new THREE.Path()
        hole1.absellipse(16, 24, 2, 3, 0, Math.PI * 2, true)
        shape.holes.push(hole1)

        // add 'eye hole 2'
        var hole2 = new THREE.Path()
        hole2.absellipse(23, 24, 2, 3, 0, Math.PI * 2, true)
        shape.holes.push(hole2)

        // add 'mouth'
        var hole3 = new THREE.Path()
        hole3.absarc(20, 16, 2, 0, Math.PI, true)
        shape.holes.push(hole3)

        // return the shape
        return shape
      }

      function createMesh(geom) {
        // assign two materials
        var meshMaterial = new THREE.MeshNormalMaterial()
        meshMaterial.side = THREE.DoubleSide
        var wireFrameMat = new THREE.MeshBasicMaterial()
        wireFrameMat.wireframe = true

        // create a multimaterial
        var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [
          meshMaterial,
          wireFrameMat,
        ])

        return mesh
      }

      function createLine(shape, spaced) {
        console.log(shape)
        if (!spaced) {
          var mesh = new THREE.Line(
            shape.createPointsGeometry(10),
            new THREE.LineBasicMaterial({
              color: 0xff3333,
              linewidth: 2,
            })
          )
          return mesh
        } else {
          var mesh = new THREE.Line(
            shape.createSpacedPointsGeometry(3),
            new THREE.LineBasicMaterial({
              color: 0xff3333,
              linewidth: 2,
            })
          )
          return mesh
        }
      }

      function render() {
        stats.update()

        shape.rotation.y = step += 0.01

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 4.戒指

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      var torus = createMesh(new THREE.RingGeometry())
      // add the sphere to the scene
      scene.add(torus)

      // position and point the camera to the center of the scene
      camera.position.x = -30
      camera.position.y = 40
      camera.position.z = 50
      camera.lookAt(new THREE.Vector3(10, 0, 0))

      // add the output of the renderer to the html element
      document
        .getElementById("WebGL-output")
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      // setup the control gui
      var controls = new (function () {
        // we need the first child, since it's a multimaterial

        this.innerRadius = 0
        this.outerRadius = 50
        this.thetaSegments = 8
        this.phiSegments = 8
        this.thetaStart = 0
        this.thetaLength = Math.PI * 2

        this.redraw = function () {
          // remove the old plane
          scene.remove(torus)
          // create a new one

          torus = createMesh(
            new THREE.RingGeometry(
              controls.innerRadius,
              controls.outerRadius,
              controls.thetaSegments,
              controls.phiSegments,
              controls.thetaStart,
              controls.thetaLength
            )
          )
          // add it to the scene.
          scene.add(torus)
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "innerRadius", 0, 40).onChange(controls.redraw)
      gui.add(controls, "outerRadius", 0, 100).onChange(controls.redraw)
      gui
        .add(controls, "thetaSegments", 1, 40)
        .step(1)
        .onChange(controls.redraw)
      gui.add(controls, "phiSegments", 1, 20).step(1).onChange(controls.redraw)
      gui.add(controls, "thetaStart", 0, Math.PI * 2).onChange(controls.redraw)
      gui.add(controls, "thetaLength", 0, Math.PI * 2).onChange(controls.redraw)

      render()

      function createMesh(geom) {
        // assign two materials
        var meshMaterial = new THREE.MeshNormalMaterial()
        meshMaterial.side = THREE.DoubleSide
        var wireFrameMat = new THREE.MeshBasicMaterial()
        wireFrameMat.wireframe = true

        // create a multimaterial
        var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [
          meshMaterial,
          wireFrameMat,
        ])

        return mesh
      }

      function render() {
        stats.update()

        torus.rotation.y = step += 0.01

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 5.立方体

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      var cube = createMesh(new THREE.BoxGeometry(10, 10, 10, 1, 1, 1))
      // add the sphere to the scene
      scene.add(cube)

      // position and point the camera to the center of the scene
      camera.position.x = -20
      camera.position.y = 30
      camera.position.z = 40
      camera.lookAt(new THREE.Vector3(10, 0, 0))

      // add spotlight for the shadows
      var spotLight = new THREE.SpotLight(0xffffff)
      spotLight.position.set(-40, 60, -10)
      scene.add(spotLight)

      // add the output of the renderer to the html element
      document
        .getElementById("WebGL-output")
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      // setup the control gui
      var controls = new (function () {
        this.width = cube.children[0].geometry.parameters.width
        this.height = cube.children[0].geometry.parameters.height
        this.depth = cube.children[0].geometry.parameters.depth

        this.widthSegments = cube.children[0].geometry.parameters.widthSegments
        this.heightSegments =
          cube.children[0].geometry.parameters.heightSegments
        this.depthSegments = cube.children[0].geometry.parameters.depthSegments

        this.redraw = function () {
          // remove the old plane
          scene.remove(cube)
          // create a new one
          cube = createMesh(
            new THREE.BoxGeometry(
              controls.width,
              controls.height,
              controls.depth,
              Math.round(controls.widthSegments),
              Math.round(controls.heightSegments),
              Math.round(controls.depthSegments)
            )
          )
          // add it to the scene.
          scene.add(cube)
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "width", 0, 40).onChange(controls.redraw)
      gui.add(controls, "height", 0, 40).onChange(controls.redraw)
      gui.add(controls, "depth", 0, 40).onChange(controls.redraw)
      gui.add(controls, "widthSegments", 0, 10).onChange(controls.redraw)
      gui.add(controls, "heightSegments", 0, 10).onChange(controls.redraw)
      gui.add(controls, "depthSegments", 0, 10).onChange(controls.redraw)
      render()

      function createMesh(geom) {
        // assign two materials
        var meshMaterial = new THREE.MeshNormalMaterial()
        meshMaterial.side = THREE.DoubleSide
        var wireFrameMat = new THREE.MeshBasicMaterial()
        wireFrameMat.wireframe = true

        // create a multimaterial
        var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [
          meshMaterial,
          wireFrameMat,
        ])

        return mesh
      }

      function render() {
        stats.update()

        cube.rotation.y = step += 0.01

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 6.球

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      var sphere = createMesh(new THREE.SphereGeometry(4, 10, 10))
      // add the sphere to the scene
      scene.add(sphere)

      // position and point the camera to the center of the scene
      camera.position.x = -20
      camera.position.y = 30
      camera.position.z = 40
      camera.lookAt(new THREE.Vector3(10, 0, 0))

      // add the output of the renderer to the html element
      document
        .getElementById("WebGL-output")
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      // setup the control gui
      var controls = new (function () {
        // we need the first child, since it's a multimaterial
        this.radius = sphere.children[0].geometry.parameters.radius
        this.widthSegments =
          sphere.children[0].geometry.parameters.widthSegments
        this.heightSegments =
          sphere.children[0].geometry.parameters.heightSegments
        this.phiStart = 0
        this.phiLength = Math.PI * 2
        this.thetaStart = 0
        this.thetaLength = Math.PI

        this.redraw = function () {
          // remove the old plane
          scene.remove(sphere)
          // create a new one
          sphere = createMesh(
            new THREE.SphereGeometry(
              controls.radius,
              controls.widthSegments,
              controls.heightSegments,
              controls.phiStart,
              controls.phiLength,
              controls.thetaStart,
              controls.thetaLength
            )
          )
          // add it to the scene.
          scene.add(sphere)
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "radius", 0, 40).onChange(controls.redraw)
      gui.add(controls, "widthSegments", 0, 20).onChange(controls.redraw)
      gui.add(controls, "heightSegments", 0, 20).onChange(controls.redraw)
      gui.add(controls, "phiStart", 0, 2 * Math.PI).onChange(controls.redraw)
      gui.add(controls, "phiLength", 0, 2 * Math.PI).onChange(controls.redraw)
      gui.add(controls, "thetaStart", 0, 2 * Math.PI).onChange(controls.redraw)
      gui.add(controls, "thetaLength", 0, 2 * Math.PI).onChange(controls.redraw)

      render()

      function createMesh(geom) {
        // assign two materials
        var meshMaterial = new THREE.MeshNormalMaterial()
        meshMaterial.side = THREE.DoubleSide
        var wireFrameMat = new THREE.MeshBasicMaterial()
        wireFrameMat.wireframe = true

        // create a multimaterial
        var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [
          meshMaterial,
          wireFrameMat,
        ])

        return mesh
      }

      function render() {
        stats.update()

        sphere.rotation.y = step += 0.01

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 7.圆柱

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()
      var scene = new THREE.Scene()
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      var cylinder = createMesh(new THREE.CylinderGeometry(20, 20, 20))
      scene.add(cylinder)
      camera.position.x = -30
      camera.position.y = 40
      camera.position.z = 50
      camera.lookAt(new THREE.Vector3(10, 0, 0))
      document
        .getElementById("WebGL-output")
        .appendChild(webGLRenderer.domElement)
      var step = 0
      var controls = new (function () {
        this.radiusTop = 20
        this.radiusBottom = 20
        this.height = 20
        this.radialSegments = 8
        this.heightSegments = 8
        this.openEnded = false
        this.redraw = function () {
          scene.remove(cylinder)
          cylinder = createMesh(
            new THREE.CylinderGeometry(
              controls.radiusTop,
              controls.radiusBottom,
              controls.height,
              controls.radialSegments,
              controls.heightSegments,
              controls.openEnded
            )
          )
          scene.add(cylinder)
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "radiusTop", -40, 40).onChange(controls.redraw)
      gui.add(controls, "radiusBottom", -40, 40).onChange(controls.redraw)
      gui.add(controls, "height", 0, 40).onChange(controls.redraw)
      gui
        .add(controls, "radialSegments", 1, 20)
        .step(1)
        .onChange(controls.redraw)
      gui
        .add(controls, "heightSegments", 1, 20)
        .step(1)
        .onChange(controls.redraw)
      gui.add(controls, "openEnded").onChange(controls.redraw)

      render()

      function createMesh(geom) {
        var meshMaterial = new THREE.MeshNormalMaterial()
        meshMaterial.side = THREE.DoubleSide
        var wireFrameMat = new THREE.MeshBasicMaterial()
        wireFrameMat.wireframe = true
        var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [
          meshMaterial,
          wireFrameMat,
        ])

        return mesh
      }

      function render() {
        stats.update()

        cylinder.rotation.y = step += 0.01

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 8.环面

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      var torus = createMesh(new THREE.TorusGeometry(10, 10, 8, 6, Math.PI * 2))
      // add the sphere to the scene
      scene.add(torus)

      // position and point the camera to the center of the scene
      camera.position.x = -30
      camera.position.y = 40
      camera.position.z = 50
      camera.lookAt(new THREE.Vector3(10, 0, 0))

      // add the output of the renderer to the html element
      document
        .getElementById("WebGL-output")
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      // setup the control gui
      var controls = new (function () {
        // we need the first child, since it's a multimaterial

        this.radius = torus.children[0].geometry.parameters.radius
        this.tube = torus.children[0].geometry.parameters.tube
        this.radialSegments =
          torus.children[0].geometry.parameters.radialSegments
        this.tubularSegments =
          torus.children[0].geometry.parameters.tubularSegments
        this.arc = torus.children[0].geometry.parameters.arc

        this.redraw = function () {
          // remove the old plane
          scene.remove(torus)
          // create a new one

          torus = createMesh(
            new THREE.TorusGeometry(
              controls.radius,
              controls.tube,
              Math.round(controls.radialSegments),
              Math.round(controls.tubularSegments),
              controls.arc
            )
          )
          // add it to the scene.
          scene.add(torus)
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "radius", 0, 40).onChange(controls.redraw)
      gui.add(controls, "tube", 0, 40).onChange(controls.redraw)
      gui.add(controls, "radialSegments", 0, 40).onChange(controls.redraw)
      gui.add(controls, "tubularSegments", 1, 20).onChange(controls.redraw)
      gui.add(controls, "arc", 0, Math.PI * 2).onChange(controls.redraw)

      render()

      function createMesh(geom) {
        // assign two materials
        var meshMaterial = new THREE.MeshNormalMaterial()
        meshMaterial.side = THREE.DoubleSide
        var wireFrameMat = new THREE.MeshBasicMaterial()
        wireFrameMat.wireframe = true

        // create a multimaterial
        var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [
          meshMaterial,
          wireFrameMat,
        ])

        return mesh
      }

      function render() {
        stats.update()

        torus.rotation.y = step += 0.01

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 9.戒指

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      var torus = createMesh(new THREE.RingGeometry())
      // add the sphere to the scene
      scene.add(torus)

      // position and point the camera to the center of the scene
      camera.position.x = -30
      camera.position.y = 40
      camera.position.z = 50
      camera.lookAt(new THREE.Vector3(10, 0, 0))

      // add the output of the renderer to the html element
      document
        .getElementById("WebGL-output")
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      // setup the control gui
      var controls = new (function () {
        // we need the first child, since it's a multimaterial

        this.innerRadius = 0
        this.outerRadius = 50
        this.thetaSegments = 8
        this.phiSegments = 8
        this.thetaStart = 0
        this.thetaLength = Math.PI * 2

        this.redraw = function () {
          // remove the old plane
          scene.remove(torus)
          // create a new one

          torus = createMesh(
            new THREE.RingGeometry(
              controls.innerRadius,
              controls.outerRadius,
              controls.thetaSegments,
              controls.phiSegments,
              controls.thetaStart,
              controls.thetaLength
            )
          )
          // add it to the scene.
          scene.add(torus)
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "innerRadius", 0, 40).onChange(controls.redraw)
      gui.add(controls, "outerRadius", 0, 100).onChange(controls.redraw)
      gui
        .add(controls, "thetaSegments", 1, 40)
        .step(1)
        .onChange(controls.redraw)
      gui.add(controls, "phiSegments", 1, 20).step(1).onChange(controls.redraw)
      gui.add(controls, "thetaStart", 0, Math.PI * 2).onChange(controls.redraw)
      gui.add(controls, "thetaLength", 0, Math.PI * 2).onChange(controls.redraw)

      render()

      function createMesh(geom) {
        // assign two materials
        var meshMaterial = new THREE.MeshNormalMaterial()
        meshMaterial.side = THREE.DoubleSide
        var wireFrameMat = new THREE.MeshBasicMaterial()
        wireFrameMat.wireframe = true

        // create a multimaterial
        var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [
          meshMaterial,
          wireFrameMat,
        ])

        return mesh
      }

      function render() {
        stats.update()

        torus.rotation.y = step += 0.01

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 10.圆环结

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      var knot = createMesh(new THREE.TorusKnotGeometry(10, 1, 64, 8, 2, 3, 1))
      // add the sphere to the scene
      scene.add(knot)

      // position and point the camera to the center of the scene
      camera.position.x = -30
      camera.position.y = 40
      camera.position.z = 50
      camera.lookAt(new THREE.Vector3(10, 0, 0))

      // add the output of the renderer to the html element
      document
        .getElementById("WebGL-output")
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      // setup the control gui
      var controls = new (function () {
        // we need the first child, since it's a multimaterial
        this.radius = knot.children[0].geometry.parameters.radius
        this.tube = 0.3
        this.radialSegments =
          knot.children[0].geometry.parameters.radialSegments
        this.tubularSegments =
          knot.children[0].geometry.parameters.tubularSegments
        this.p = knot.children[0].geometry.parameters.p
        this.q = knot.children[0].geometry.parameters.q
        this.heightScale = knot.children[0].geometry.parameters.heightScale

        this.redraw = function () {
          // remove the old plane
          scene.remove(knot)
          // create a new one

          knot = createMesh(
            new THREE.TorusKnotGeometry(
              controls.radius,
              controls.tube,
              Math.round(controls.radialSegments),
              Math.round(controls.tubularSegments),
              Math.round(controls.p),
              Math.round(controls.q),
              controls.heightScale
            )
          )
          // add it to the scene.
          scene.add(knot)
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "radius", 0, 40).onChange(controls.redraw)
      gui.add(controls, "tube", 0, 40).onChange(controls.redraw)
      gui
        .add(controls, "radialSegments", 0, 400)
        .step(1)
        .onChange(controls.redraw)
      gui
        .add(controls, "tubularSegments", 1, 20)
        .step(1)
        .onChange(controls.redraw)
      gui.add(controls, "p", 1, 10).step(1).onChange(controls.redraw)
      gui.add(controls, "q", 1, 15).step(1).onChange(controls.redraw)
      gui.add(controls, "heightScale", 0, 5).onChange(controls.redraw)

      render()

      function createMesh(geom) {
        // assign two materials
        var meshMaterial = new THREE.MeshNormalMaterial({})
        meshMaterial.side = THREE.DoubleSide

        // create a multimaterial
        var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [
          meshMaterial,
        ])

        return mesh
      }

      function render() {
        stats.update()

        knot.rotation.y = step += 0.01

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 11.多面体

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      var polyhedron = createMesh(new THREE.IcosahedronGeometry(10, 0))
      // add the sphere to the scene
      scene.add(polyhedron)

      // position and point the camera to the center of the scene
      camera.position.x = -30
      camera.position.y = 40
      camera.position.z = 50
      camera.lookAt(new THREE.Vector3(10, 0, 0))

      // add the output of the renderer to the html element
      document
        .getElementById("WebGL-output")
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      // setup the control gui
      var controls = new (function () {
        // we need the first child, since it's a multimaterial
        this.radius = 10
        this.detail = 0
        this.type = "Icosahedron"

        this.redraw = function () {
          // remove the old plane
          scene.remove(polyhedron)
          // create a new one

          switch (controls.type) {
            case "Icosahedron":
              polyhedron = createMesh(
                new THREE.IcosahedronGeometry(controls.radius, controls.detail)
              )
              break
            case "Tetrahedron":
              polyhedron = createMesh(
                new THREE.TetrahedronGeometry(controls.radius, controls.detail)
              )
              break
            case "Octahedron":
              polyhedron = createMesh(
                new THREE.OctahedronGeometry(controls.radius, controls.detail)
              )
              break
            case "Dodecahedron":
              polyhedron = createMesh(
                new THREE.DodecahedronGeometry(controls.radius, controls.detail)
              )
              break
            case "Custom":
              var vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1]

              var indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1]

              polyhedron = createMesh(
                new THREE.PolyhedronGeometry(
                  vertices,
                  indices,
                  controls.radius,
                  controls.detail
                )
              )
              break
          }

          // add it to the scene.
          scene.add(polyhedron)
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "radius", 0, 40).step(1).onChange(controls.redraw)
      gui.add(controls, "detail", 0, 3).step(1).onChange(controls.redraw)
      gui
        .add(controls, "type", [
          "Icosahedron",
          "Tetrahedron",
          "Octahedron",
          "Dodecahedron",
          "Custom",
        ])
        .onChange(controls.redraw)

      render()

      function createMesh(geom) {
        // assign two materials
        var meshMaterial = new THREE.MeshNormalMaterial()
        meshMaterial.side = THREE.DoubleSide
        var wireFrameMat = new THREE.MeshBasicMaterial()
        wireFrameMat.wireframe = true

        // create a multimaterial
        var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [
          meshMaterial,
          wireFrameMat,
        ])

        return mesh
      }

      function render() {
        stats.update()

        polyhedron.rotation.y = step += 0.01

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::
