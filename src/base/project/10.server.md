---
lang: zh-CN
sidebarDepth: 0
meta:
  - name: description
    content: 个人总结的vuepress学习技术文档-主题
  - name: keywords
    content: vuepress,最新技术文档,vuepress主题
---

# 十.纹理

## 1.基本纹理 dds

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth/2, window.innerHeight/2)
      webGLRenderer.shadowMapEnabled = true

      var polyhedron = createMesh(new THREE.IcosahedronGeometry(5, 0))
      polyhedron.position.x = 12
      scene.add(polyhedron)

      var sphere = createMesh(new THREE.SphereGeometry(5, 20, 20))
      scene.add(sphere)

      var cube = createMesh(new THREE.BoxGeometry(5, 5, 5))
      cube.position.x = -12
      scene.add(cube)
      console.log(cube.geometry.faceVertexUvs)

      // position and point the camera to the center of the scene
      camera.position.x = 0
      camera.position.y = 12
      camera.position.z = 28
      camera.lookAt(new THREE.Vector3(0, 0, 0))

      var ambiLight = new THREE.AmbientLight(0x141414)
      scene.add(ambiLight)

      var light = new THREE.DirectionalLight()
      light.position.set(0, 30, 20)
      scene.add(light)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      // setup the control gui
      var controls = new (function () {})()

      var gui = new dat.GUI()

      render()

      function createMesh(geom, imageFile) {
        var loader = new THREE.DDSLoader()
        var texture = loader.load("/assets/textures/seafloor.dds")
        var mat = new THREE.MeshPhongMaterial()
        mat.map = texture

        var mesh = new THREE.Mesh(geom, mat)
        return mesh
      }

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        polyhedron.rotation.y = step += 0.01
        polyhedron.rotation.x = step
        cube.rotation.y = step
        cube.rotation.x = step
        sphere.rotation.y = step
        sphere.rotation.x = step

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 2.基本纹理 pvr

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth/2, window.innerHeight/2)
      webGLRenderer.shadowMapEnabled = true

      var polyhedron = createMesh(new THREE.IcosahedronGeometry(5, 0))
      polyhedron.position.x = 12
      scene.add(polyhedron)

      var sphere = createMesh(new THREE.SphereGeometry(5, 20, 20))
      scene.add(sphere)

      var cube = createMesh(new THREE.BoxGeometry(5, 5, 5))
      cube.position.x = -12
      scene.add(cube)
      console.log(cube.geometry.faceVertexUvs)

      // position and point the camera to the center of the scene
      camera.position.x = 0
      camera.position.y = 12
      camera.position.z = 28
      camera.lookAt(new THREE.Vector3(0, 0, 0))

      var ambiLight = new THREE.AmbientLight(0x141414)
      scene.add(ambiLight)

      var light = new THREE.DirectionalLight()
      light.position.set(0, 30, 20)
      scene.add(light)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      // setup the control gui
      var controls = new (function () {})()

      var gui = new dat.GUI()

      render()

      function createMesh(geom, imageFile) {
        var loader = new THREE.PVRLoader()
        var texture = loader.load("/assets/textures/tex_base.pvr")
        var mat = new THREE.MeshPhongMaterial()
        mat.map = texture

        var mesh = new THREE.Mesh(geom, mat)
        return mesh
      }

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        polyhedron.rotation.y = step += 0.01
        polyhedron.rotation.x = step
        cube.rotation.y = step
        cube.rotation.x = step
        sphere.rotation.y = step
        sphere.rotation.x = step

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 3.基本纹理 tga

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth/2, window.innerHeight/2)
      webGLRenderer.shadowMapEnabled = true

      var polyhedron = createMesh(new THREE.IcosahedronGeometry(5, 0))
      polyhedron.position.x = 12
      scene.add(polyhedron)

      var sphere = createMesh(new THREE.SphereGeometry(5, 20, 20))
      scene.add(sphere)

      var cube = createMesh(new THREE.BoxGeometry(5, 5, 5))
      cube.position.x = -12
      scene.add(cube)

      // position and point the camera to the center of the scene
      camera.position.x = 0
      camera.position.y = 12
      camera.position.z = 28
      camera.lookAt(new THREE.Vector3(0, 0, 0))

      var ambiLight = new THREE.AmbientLight(0x141414)
      scene.add(ambiLight)

      var light = new THREE.DirectionalLight()
      light.position.set(0, 30, 20)
      scene.add(light)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      // setup the control gui
      var controls = new (function () {})()

      var gui = new dat.GUI()

      render()

      function createMesh(geom, imageFile) {
        var loader = new THREE.TGALoader()
        var texture = loader.load("/assets/textures/crate_color8.tga")
        var mat = new THREE.MeshPhongMaterial()
        mat.map = texture

        var mesh = new THREE.Mesh(geom, mat)
        return mesh
      }

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        polyhedron.rotation.y = step += 0.01
        polyhedron.rotation.x = step
        cube.rotation.y = step
        cube.rotation.x = step
        sphere.rotation.y = step
        sphere.rotation.x = step

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 4.基本纹理

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth/2, window.innerHeight/2)
      webGLRenderer.shadowMapEnabled = true

      var polyhedron = createMesh(
        new THREE.IcosahedronGeometry(5, 0),
        "metal-rust.jpg"
      )
      polyhedron.position.x = 12
      scene.add(polyhedron)

      var sphere = createMesh(
        new THREE.SphereGeometry(5, 20, 20),
        "floor-wood.jpg"
      )
      scene.add(sphere)

      var cube = createMesh(new THREE.BoxGeometry(5, 5, 5), "brick-wall.jpg")
      cube.position.x = -12
      scene.add(cube)
      console.log(cube.geometry.faceVertexUvs)

      // position and point the camera to the center of the scene
      camera.position.x = 0
      camera.position.y = 12
      camera.position.z = 28
      camera.lookAt(new THREE.Vector3(0, 0, 0))

      var ambiLight = new THREE.AmbientLight(0x141414)
      scene.add(ambiLight)

      var light = new THREE.DirectionalLight()
      light.position.set(0, 30, 20)
      scene.add(light)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      //        var polyhedron = createMesh(new THREE.PolyhedronGeometry(vertices, faces, controls.radius, controls.detail));

      // setup the control gui
      var controls = new (function () {})()

      var gui = new dat.GUI()

      render()

      function createMesh(geom, imageFile) {
        var texture = THREE.ImageUtils.loadTexture(
          "/assets/textures/general/" + imageFile
        )
        var mat = new THREE.MeshPhongMaterial()
        mat.map = texture

        var mesh = new THREE.Mesh(geom, mat)
        return mesh
      }

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        polyhedron.rotation.y = step += 0.01
        polyhedron.rotation.x = step
        cube.rotation.y = step
        cube.rotation.x = step
        sphere.rotation.y = step
        sphere.rotation.x = step

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 5.凹凸图

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth/2, window.innerHeight/2)
      webGLRenderer.shadowMapEnabled = true

      var sphere1 = createMesh(new THREE.BoxGeometry(15, 15, 2), "stone.jpg")
      sphere1.rotation.y = -0.5
      sphere1.position.x = 12
      scene.add(sphere1)

      var sphere2 = createMesh(
        new THREE.BoxGeometry(15, 15, 2),
        "stone.jpg",
        "stone-bump.jpg"
      )
      sphere2.rotation.y = 0.5
      sphere2.position.x = -12
      scene.add(sphere2)
      console.log(sphere2.geometry.faceVertexUvs)

      var floorTex = THREE.ImageUtils.loadTexture(
        "/assets/textures/general/floor-wood.jpg"
      )
      var plane = new THREE.Mesh(
        new THREE.BoxGeometry(200, 100, 0.1, 30),
        new THREE.MeshPhongMaterial({
          color: 0x3c3c3c,
          map: floorTex,
        })
      )
      plane.position.y = -7.5
      plane.rotation.x = -0.5 * Math.PI
      scene.add(plane)

      // position and point the camera to the center of the scene
      camera.position.x = 0
      camera.position.y = 12
      camera.position.z = 28
      camera.lookAt(new THREE.Vector3(0, 0, 0))

      var ambiLight = new THREE.AmbientLight(0x242424)
      scene.add(ambiLight)

      var light = new THREE.SpotLight()
      light.position.set(0, 30, 30)
      light.intensity = 1.2
      scene.add(light)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      //        var polyhedron = createMesh(new THREE.PolyhedronGeometry(vertices, faces, controls.radius, controls.detail));

      // setup the control gui
      var controls = new (function () {
        this.bumpScale = 0.2
        this.changeTexture = "weave"
        this.rotate = false

        this.changeTexture = function (e) {
          var texture = THREE.ImageUtils.loadTexture(
            "/assets/textures/general/" + e + ".jpg"
          )
          sphere2.material.map = texture
          sphere1.material.map = texture

          var bump = THREE.ImageUtils.loadTexture(
            "/assets/textures/general/" + e + "-bump.jpg"
          )
          sphere2.material.bumpMap = bump
        }

        this.updateBump = function (e) {
          console.log(sphere2.material.bumpScale)
          sphere2.material.bumpScale = e
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "bumpScale", -2, 2).onChange(controls.updateBump)
      gui
        .add(controls, "changeTexture", ["stone", "weave"])
        .onChange(controls.changeTexture)
      gui.add(controls, "rotate")

      render()

      function createMesh(geom, imageFile, bump) {
        var texture = THREE.ImageUtils.loadTexture(
          "/assets/textures/general/" + imageFile
        )
        geom.computeVertexNormals()
        var mat = new THREE.MeshPhongMaterial()
        mat.map = texture

        if (bump) {
          var bump = THREE.ImageUtils.loadTexture(
            "/assets/textures/general/" + bump
          )
          mat.bumpMap = bump
          mat.bumpScale = 0.2
          console.log("d")
        }

        // create a multimaterial
        var mesh = new THREE.Mesh(geom, mat)

        return mesh
      }

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        if (controls.rotate) {
          sphere1.rotation.y -= 0.01
          sphere2.rotation.y += 0.01
        }

        //            sphere1.rotation.y=step+=0.01;
        //            sphere1.rotation.x=step;
        //            sphere2.rotation.y=step;
        //            sphere2.rotation.x=step;

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 6.法线贴图

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth/2, window.innerHeight/2)
      webGLRenderer.shadowMapEnabled = true

      var sphere1 = createMesh(new THREE.BoxGeometry(15, 15, 15), "plaster.jpg")
      sphere1.rotation.y = -0.5
      sphere1.position.x = 12
      scene.add(sphere1)

      var sphere2 = createMesh(
        new THREE.BoxGeometry(15, 15, 15),
        "plaster.jpg",
        "plaster-normal.jpg"
      )
      sphere2.rotation.y = 0.5
      sphere2.position.x = -12
      scene.add(sphere2)
      console.log(sphere2.geometry.faceVertexUvs)

      var floorTex = THREE.ImageUtils.loadTexture(
        "/assets/textures/general/floor-wood.jpg"
      )
      var plane = new THREE.Mesh(
        new THREE.BoxGeometry(200, 100, 0.1, 30),
        new THREE.MeshPhongMaterial({
          color: 0x3c3c3c,
          map: floorTex,
        })
      )
      plane.position.y = -7.5
      plane.rotation.x = -0.5 * Math.PI
      scene.add(plane)

      // position and point the camera to the center of the scene
      camera.position.x = 0
      camera.position.y = 12
      camera.position.z = 38
      camera.lookAt(new THREE.Vector3(0, 0, 0))

      var ambiLight = new THREE.AmbientLight(0x242424)
      scene.add(ambiLight)

      var light = new THREE.SpotLight()
      light.position.set(0, 30, 30)
      light.intensity = 1.2
      scene.add(light)

      //        var pointColor = "#ff5808";
      var pointColor = "#ff5808"
      var directionalLight = new THREE.PointLight(pointColor)

      //        directionalLight.distance = 0;
      //        directionalLight.intensity = 0.5;

      scene.add(directionalLight)

      // add a small sphere simulating the pointlight
      var sphereLight = new THREE.SphereGeometry(0.2)
      var sphereLightMaterial = new THREE.MeshBasicMaterial({ color: 0xac6c25 })
      var sphereLightMesh = new THREE.Mesh(sphereLight, sphereLightMaterial)
      sphereLightMesh.castShadow = true

      sphereLightMesh.position.set(new THREE.Vector3(3, 3, 3))
      scene.add(sphereLightMesh)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      //        var polyhedron = createMesh(new THREE.PolyhedronGeometry(vertices, faces, controls.radius, controls.detail));

      // setup the control gui
      var controls = new (function () {
        this.normalScale = 1
        this.changeTexture = "plaster"
        this.rotate = false

        this.changeTexture = function (e) {
          var texture = THREE.ImageUtils.loadTexture(
            "/assets/textures/general/" + e + ".jpg"
          )
          sphere2.material.map = texture
          sphere1.material.map = texture

          var bump = THREE.ImageUtils.loadTexture(
            "/assets/textures/general/" + e + "-normal.jpg"
          )
          sphere2.material.normalMap = bump
        }

        this.updateBump = function (e) {
          sphere2.material.normalScale.set(e, e)
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "normalScale", -2, 2).onChange(controls.updateBump)
      gui
        .add(controls, "changeTexture", ["plaster", "bathroom", "metal-floor"])
        .onChange(controls.changeTexture)
      gui.add(controls, "rotate")

      render()

      function createMesh(geom, imageFile, normal) {
        if (normal) {
          var t = THREE.ImageUtils.loadTexture(
            "/assets/textures/general/" + imageFile
          )
          var m = THREE.ImageUtils.loadTexture(
            "/assets/textures/general/" + normal
          )
          var mat2 = new THREE.MeshPhongMaterial()
          mat2.map = t
          mat2.normalMap = m

          var mesh = new THREE.Mesh(geom, mat2)
          return mesh
        } else {
          var t = THREE.ImageUtils.loadTexture(
            "/assets/textures/general/" + imageFile
          )
          var mat1 = new THREE.MeshPhongMaterial({
            map: t,
          })
          var mesh = new THREE.Mesh(geom, mat1)
          return mesh
        }

        return mesh
      }

      function createNormalmapShaderMaterial(diffuseMap, normalMap) {
        var shader = THREE.ShaderLib["normalmap"]
        var uniforms = THREE.UniformsUtils.clone(shader.uniforms)

        var dT = THREE.ImageUtils.loadTexture(diffuseMap)
        var nT = THREE.ImageUtils.loadTexture(normalMap)

        uniforms["uShininess"].value = 50
        uniforms["enableDiffuse"].value = true
        uniforms["uDiffuseColor"].value.setHex(0xffffff)
        uniforms["tDiffuse"].value = dT
        uniforms["tNormal"].value = nT

        uniforms["uNormalScale"].value.set(1, 1)
        uniforms["uSpecularColor"].value.setHex(0xffffff)
        uniforms["enableSpecular"].value = true

        return new THREE.ShaderMaterial({
          fragmentShader: shader.fragmentShader,
          vertexShader: shader.vertexShader,
          uniforms: uniforms,
          lights: true,
        })
      }

      var invert = 1
      var phase = 0

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()
        step += 0.1

        if (controls.rotate) {
          sphere1.rotation.y -= 0.01
          sphere2.rotation.y += 0.01
        }

        if (phase > 2 * Math.PI) {
          invert = invert * -1
          phase -= 2 * Math.PI
        } else {
          phase += 0.03
        }

        sphereLightMesh.position.z = +(21 * Math.sin(phase))
        sphereLightMesh.position.x = -14 + 14 * Math.cos(phase)

        if (invert < 0) {
          var pivot = 0
          sphereLightMesh.position.x =
            invert * (sphereLightMesh.position.x - pivot) + pivot
        }

        directionalLight.position.copy(sphereLightMesh.position)

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 7.光照图

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var renderer
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth/2, window.innerHeight/2)
      webGLRenderer.shadowMapEnabled = true

      renderer = webGLRenderer

      var groundGeom = new THREE.PlaneGeometry(95, 95, 1, 1)
      var lm = THREE.ImageUtils.loadTexture(
        "/assets/textures/lightmap/lm-1.png"
      )
      var wood = THREE.ImageUtils.loadTexture(
        "/assets/textures/general/floor-wood.jpg"
      )
      var groundMaterial = new THREE.MeshBasicMaterial({
        color: 0x777777,
        lightMap: lm,
        map: wood,
      })

      //        console.log(groundGeom.faceVertexUvs[1]);
      // http://stackoverflow.com/questions/15137695/three-js-lightmap-causes-an-error-webglrenderingcontext-gl-error-gl-invalid-op
      // https://github.com/mrdoob/three.js/pull/2372
      // lightmaps use own mapping of uvs (faceVertexUvs[1])
      // so need to create those. Reason is explained
      // here. So we can use a low res map for lightmap
      // and a high res map for textures.
      groundGeom.faceVertexUvs[1] = groundGeom.faceVertexUvs[0]
      //        console.log(groundGeom.faceVertexUvs[1]);

      var groundMesh = new THREE.Mesh(groundGeom, groundMaterial)

      groundMesh.rotation.x = -Math.PI / 2
      groundMesh.position.y = 0
      scene.add(groundMesh)

      var cubeGeometry = new THREE.BoxGeometry(12, 12, 12)
      var cubeGeometry2 = new THREE.BoxGeometry(6, 6, 6)

      var meshMaterial = new THREE.MeshBasicMaterial()
      meshMaterial.map = THREE.ImageUtils.loadTexture(
        "/assets/textures/general/stone.jpg"
      )

      var cube = new THREE.Mesh(cubeGeometry, meshMaterial)
      var cube2 = new THREE.Mesh(cubeGeometry2, meshMaterial)
      cube.position.set(0.9, 6, -12)
      cube2.position.set(-13.2, 3, -6)

      // add the sphere to the scene
      scene.add(cube)
      scene.add(cube2)

      // position and point the camera to the center of the scene
      camera.position.x = -20
      camera.position.y = 20
      camera.position.z = 30
      camera.lookAt(new THREE.Vector3(0, 0, 0))

      // add subtle ambient lighting
      var ambientLight = new THREE.AmbientLight(0x0c0c0c)
      scene.add(ambientLight)

      // add the output of the renderer to the html element
      this.$refs.example.appendChild(renderer.domElement)

      render()

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        renderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 8.动态环境地图

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      scene: "",
    }
  },
  methods: {
    init() {
      this.scene = new THREE.Scene()
      camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        10000
      )
      orbit = new THREE.OrbitControls(camera)
      renderer = new THREE.WebGLRenderer()
      renderer.setClearColor(0x000000, 1.0)
      renderer.setSize(window.innerWidth/2, window.innerHeight/2)
      var textureCube = this.createCubeMap()
      textureCube.format = THREE.RGBFormat
      var shader = THREE.ShaderLib["cube"]
      shader.uniforms["tCube"].value = textureCube
      var material = new THREE.ShaderMaterial({
        fragmentShader: shader.fragmentShader,
        vertexShader: shader.vertexShader,
        uniforms: shader.uniforms,
        depthWrite: false,
        side: THREE.DoubleSide,
      })
      var skybox = new THREE.Mesh(
        new THREE.BoxGeometry(10000, 10000, 10000),
        material
      )
      this.scene.add(skybox)
      cubeCamera = new THREE.CubeCamera(0.1, 20000, 256)
      this.scene.add(cubeCamera)
      var sphereGeometry = new THREE.SphereGeometry(4, 15, 15)
      var boxGeometry = new THREE.BoxGeometry(5, 5, 5)
      var cylinderGeometry = new THREE.CylinderGeometry(2, 4, 10, 20, 20, false)
      var dynamicEnvMaterial = new THREE.MeshBasicMaterial({
        envMap: cubeCamera.renderTarget,
        side: THREE.DoubleSide,
      })
      var envMaterial = new THREE.MeshBasicMaterial({
        envMap: textureCube,
        side: THREE.DoubleSide,
      })
      sphere = new THREE.Mesh(sphereGeometry, dynamicEnvMaterial)
      sphere.name = "sphere"
      this.scene.add(sphere)

      var cylinder = new THREE.Mesh(cylinderGeometry, envMaterial)
      cylinder.name = "cylinder"
      this.scene.add(cylinder)
      cylinder.position.set(10, 0, 0)

      var cube = new THREE.Mesh(boxGeometry, envMaterial)
      cube.name = "cube"
      this.scene.add(cube)
      cube.position.set(-10, 0, 0)
      camera.position.x = 0
      camera.position.y = 5
      camera.position.z = 33
      camera.lookAt(this.scene.position)
      document.body.appendChild(renderer.domElement)
      control = new (function () {
        this.rotationSpeed = 0.005
        this.scale = 1
      })()
      this.addControls(control)
      this.render()
    },
    addControls(controlObject) {
      var gui = new dat.GUI()
      gui.add(controlObject, "rotationSpeed", -0.1, 0.1)
    },
    createCubeMap() {
      var path = "/assets/textures/cubemap/parliament/"
      var format = ".jpg"
      var urls = [
        path + "posx" + format,
        path + "negx" + format,
        path + "posy" + format,
        path + "negy" + format,
        path + "posz" + format,
        path + "negz" + format,
      ]
      var textureCube = THREE.ImageUtils.loadTextureCube(
        urls,
        new THREE.CubeReflectionMapping()
      )
      return textureCube
    },
    render() {
      orbit.update()
      sphere.visible = false
      cubeCamera.updateCubeMap(renderer, this.scene)
      sphere.visible = true
      renderer.render(this.scene, camera)
      this.scene.getObjectByName("cube").rotation.x += control.rotationSpeed
      this.scene.getObjectByName("cube").rotation.y += control.rotationSpeed
      this.scene.getObjectByName("cylinder").rotation.x += control.rotationSpeed
      requestAnimationFrame(render)
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 9.环境地图

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()
      var sceneCube = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )
      var cameraCube = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth/2, window.innerHeight/2)
      webGLRenderer.shadowMapEnabled = false
      webGLRenderer.autoClear = false

      var textureCube = createCubeMap()
      var shader = THREE.ShaderLib["cube"]
      shader.uniforms["tCube"].value = textureCube
      var material = new THREE.ShaderMaterial({
        fragmentShader: shader.fragmentShader,
        vertexShader: shader.vertexShader,
        uniforms: shader.uniforms,
        depthWrite: false,
        side: THREE.BackSide,
      })

      cubeMesh = new THREE.Mesh(new THREE.BoxGeometry(100, 100, 100), material)
      sceneCube.add(cubeMesh)

      // create the spheres
      var sphere1 = createMesh(
        new THREE.SphereGeometry(10, 15, 15),
        "plaster.jpg"
      )
      sphere1.material.envMap = textureCube
      sphere1.rotation.y = -0.5
      sphere1.position.x = 12
      sphere1.position.y = 5
      scene.add(sphere1)

      var sphere2 = createMesh(
        new THREE.BoxGeometry(10, 15, 15),
        "plaster.jpg",
        "plaster-normal.jpg"
      )
      sphere2.material.envMap = textureCube

      sphere2.rotation.y = 0.5
      sphere2.position.x = -12
      sphere2.position.y = 5
      scene.add(sphere2)
      console.log(sphere2.geometry.faceVertexUvs)

      // position and point the camera to the center of the scene
      camera.position.x = 0
      camera.position.y = 12
      camera.position.z = 68
      camera.lookAt(new THREE.Vector3(0, 0, 0))

      var ambiLight = new THREE.AmbientLight(0xffffff)
      scene.add(ambiLight)

      var light = new THREE.SpotLight()
      light.position.set(0, 30, 30)
      light.intensity = 1.2
      scene.add(light)

      var pointColor = "#ff5808"
      var directionalLight = new THREE.PointLight(pointColor)
      directionalLight.intensity = 4.5

      scene.add(directionalLight)

      // add a small sphere simulating the pointlight
      var sphereLight = new THREE.SphereGeometry(0.2)
      var sphereLightMaterial = new THREE.MeshBasicMaterial({ color: 0xac6c25 })
      var sphereLightMesh = new THREE.Mesh(sphereLight, sphereLightMaterial)
      sphereLightMesh.castShadow = true

      sphereLightMesh.position.copy(new THREE.Vector3(3, 3, 3))
      scene.add(sphereLightMesh)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      //        var polyhedron = createMesh(new THREE.PolyhedronGeometry(vertices, faces, controls.radius, controls.detail));

      // setup the control gui
      var controls = new (function () {
        this.normalScale = 1
        this.reflectivity = 1
        this.changeTexture = "plaster"
        this.rotate = false

        this.changeTexture = function (e) {
          var texture = THREE.ImageUtils.loadTexture(
            "/assets/textures/general/" + e + ".jpg"
          )
          sphere2.material.map = texture
          sphere1.material.map = texture

          var bump = THREE.ImageUtils.loadTexture(
            "/assets/textures/general/" + e + "-normal.jpg"
          )
          sphere2.material.normalMap = bump
        }

        this.updateBump = function (e) {
          sphere2.material.normalScale.set(
            controls.normalScale,
            controls.normalScale
          )
          sphere2.material.reflectivity = controls.reflectivity

          sphere1.material.reflectivity = controls.reflectivity
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "normalScale", -2, 2).onChange(controls.updateBump)

      gui.add(controls, "reflectivity", 0, 2).onChange(controls.updateBump)
      gui
        .add(controls, "changeTexture", [
          "plaster",
          "bathroom",
          "metal-floor",
          "none",
        ])
        .onChange(controls.changeTexture)
      gui.add(controls, "rotate")

      render()

      function createMesh(geom, texture, normal) {
        geom.computeVertexNormals()

        if (normal) {
          var t = THREE.ImageUtils.loadTexture(
            "/assets/textures/general/" + texture
          )
          var m = THREE.ImageUtils.loadTexture(
            "/assets/textures/general/" + normal
          )
          var mat2 = new THREE.MeshPhongMaterial({
            map: t,
            normalMap: m,
          })
          var mesh = new THREE.Mesh(geom, mat2)
          return mesh
        } else {
          var t = THREE.ImageUtils.loadTexture(
            "/assets/textures/general/" + texture
          )
          var mat1 = new THREE.MeshPhongMaterial({})
          var mesh = new THREE.Mesh(geom, mat1)
          return mesh
        }

        // create a multimaterial
        //            geom.computeTangents();

        return mesh
      }

      function createCubeMap() {
        var path = "/assets/textures/cubemap/parliament/"
        var format = ".jpg"
        var urls = [
          path + "posx" + format,
          path + "negx" + format,
          path + "posy" + format,
          path + "negy" + format,
          path + "posz" + format,
          path + "negz" + format,
        ]

        //        var textureCube = THREE.ImageUtils.loadTextureCube( urls );
        var textureCube = THREE.ImageUtils.loadTextureCube(
          urls,
          new THREE.CubeReflectionMapping()
        )
        return textureCube
      }

      function createNormalmapShaderMaterial(diffuseMap, normalMap) {
        var shader = THREE.ShaderLib["normalmap"]
        var uniforms = THREE.UniformsUtils.clone(shader.uniforms)

        var dT = THREE.ImageUtils.loadTexture(diffuseMap)
        var nT = THREE.ImageUtils.loadTexture(normalMap)

        uniforms["uShininess"].value = 50
        uniforms["enableDiffuse"].value = true
        uniforms["uDiffuseColor"].value.setHex(0xffffff)
        uniforms["tDiffuse"].value = dT
        uniforms["tNormal"].value = nT

        uniforms["uNormalScale"].value.set(1, 1)
        uniforms["uSpecularColor"].value.setHex(0xffffff)
        uniforms["enableSpecular"].value = true

        return new THREE.ShaderMaterial({
          fragmentShader: shader.fragmentShader,
          vertexShader: shader.vertexShader,
          uniforms: uniforms,
          lights: true,
        })
      }

      var invert = 1
      var phase = 0

      var mouseX = 0
      var mouseY = 0

      document.addEventListener("mousemove", onDocumentMouseMove, false)
      function onDocumentMouseMove(event) {
        mouseX = (event.clientX - window.innerWidth / 2) * 10
        mouseY = (event.clientY - window.innerHeight / 2) * 10
      }

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()
        step += 0.1

        if (controls.rotate) {
          sphere1.rotation.y -= 0.01
          sphere2.rotation.y += 0.01
        }

        if (phase > 2 * Math.PI) {
          invert = invert * -1
          phase -= 2 * Math.PI
        } else {
          phase += 0.03
        }

        sphereLightMesh.position.z = +(21 * Math.sin(phase))
        sphereLightMesh.position.x = -14 + 14 * Math.cos(phase)

        if (invert < 0) {
          var pivot = 0
          sphereLightMesh.position.x =
            invert * (sphereLightMesh.position.x - pivot) + pivot
        }

        directionalLight.position.copy(sphereLightMesh.position)

        camera.position.x = mouseX * 0.018
        camera.position.y = 6 + mouseY * 0.018
        //        camera.position.y += ( - mouseY - camera.position.y ) * .005;

        //        console.log(mouseX + "," + mouseY);

        camera.lookAt(scene.position)
        cameraCube.rotation = camera.rotation

        //            sphere1.rotation.y=step+=0.01;
        //            sphere1.rotation.x=step;
        //            sphere2.rotation.y=step;
        //            sphere2.rotation.x=step;

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(sceneCube, cameraCube)
        webGLRenderer.render(scene, camera)
        //
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 10.镜面反射贴图

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0x000, 1.0))
      webGLRenderer.setSize(window.innerWidth/2, window.innerHeight/2)
      webGLRenderer.shadowMapEnabled = true

      var sphere = createMesh(new THREE.SphereGeometry(10, 40, 40))
      // add the sphere to the scene
      scene.add(sphere)

      // position and point the camera to the center of the scene
      camera.position.x = 15
      camera.position.y = 15
      camera.position.z = 15

      camera.lookAt(new THREE.Vector3(0, 0, 0))

      var orbitControls = new THREE.OrbitControls(camera)
      orbitControls.autoRotate = false
      var clock = new THREE.Clock()

      var ambi = new THREE.AmbientLight(0x3300000)
      scene.add(ambi)

      var spotLight = new THREE.DirectionalLight(0xffffff)
      spotLight.position.set(350, 350, 150)
      spotLight.intensity = 0.4

      scene.add(spotLight)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      render()

      function createMesh(geom) {
        var planetTexture = THREE.ImageUtils.loadTexture(
          "/assets/textures/planets/Earth.png"
        )
        var specularTexture = THREE.ImageUtils.loadTexture(
          "/assets/textures/planets/EarthSpec.png"
        )
        var normalTexture = THREE.ImageUtils.loadTexture(
          "/assets/textures/planets/EarthNormal.png"
        )

        var planetMaterial = new THREE.MeshPhongMaterial()
        planetMaterial.specularMap = specularTexture
        planetMaterial.specular = new THREE.Color(0xff0000)
        planetMaterial.shininess = 2

        planetMaterial.normalMap = normalTexture
        //            planetMaterial.map = planetTexture;
        //   planetMaterial.shininess = 150;

        // create a multimaterial
        var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [
          planetMaterial,
        ])

        return mesh
      }

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        //sphere.rotation.y=step+=0.01;
        var delta = clock.getDelta()
        orbitControls.update(delta)

        sphere.rotation.y += 0.005

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 11.UV 映射

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xffffff, 1.0))
      webGLRenderer.setSize(window.innerWidth/2, window.innerHeight/2)
      webGLRenderer.shadowMapEnabled = true

      // position and point the camera to the center of the scene
      camera.position.x = -30
      camera.position.y = 40
      camera.position.z = 50
      camera.lookAt(new THREE.Vector3(0, 0, 0))

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      var texture = THREE.ImageUtils.loadTexture(
        "/assets/textures/ash_uvgrid01.jpg"
      )
      //        var mat = new THREE.MeshBasicMaterial();
      var mat = new THREE.MeshBasicMaterial({ map: texture })
      var geom = new THREE.BoxGeometry(24, 24, 24)
      var mesh = new THREE.Mesh(geom, mat)

      mesh.rotation.z = 0.5 * Math.PI
      mesh.rotation.y = 0.2 * Math.PI
      mesh.rotation.x = 0.2 * Math.PI
      scene.add(mesh)

      console.log(geom.faceVertexUvs[0][0])

      // setup the control gui
      var controls = new (function () {
        // we need the first child, since it's a multimaterial
        this.uv1 = geom.faceVertexUvs[0][0][0].x
        this.uv2 = geom.faceVertexUvs[0][0][0].y
        this.uv3 = geom.faceVertexUvs[0][0][1].x
        this.uv4 = geom.faceVertexUvs[0][0][1].y
        this.uv5 = geom.faceVertexUvs[0][0][2].x
        this.uv6 = geom.faceVertexUvs[0][0][2].y
      })()

      var gui = new dat.GUI()
      gui.add(controls, "uv1", 0, 1).onChange(function (e) {
        geom.faceVertexUvs[0][0][0].x = e
        geom.uvsNeedUpdate = true
      })
      gui.add(controls, "uv2", 0, 1).onChange(function (e) {
        geom.faceVertexUvs[0][0][0].y = e
        geom.uvsNeedUpdate = true
      })
      gui.add(controls, "uv3", 0, 1).onChange(function (e) {
        geom.faceVertexUvs[0][0][1].x = e
        geom.uvsNeedUpdate = true
      })
      gui.add(controls, "uv4", 0, 1).onChange(function (e) {
        geom.faceVertexUvs[0][0][1].y = e
        geom.uvsNeedUpdate = true
      })
      gui.add(controls, "uv5", 0, 1).onChange(function (e) {
        geom.faceVertexUvs[0][0][2].x = e
        geom.uvsNeedUpdate = true
      })
      gui.add(controls, "uv6", 0, 1).onChange(function (e) {
        geom.faceVertexUvs[0][0][2].y = e
        geom.uvsNeedUpdate = true
      })

      //        controls.loadCube1();

      render()

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        if (mesh) {
          //                mesh.rotation.y += 0.006;
          //                mesh.rotation.x += 0.006;
          //                mesh.rotation.y+=0.006;
        }

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 12.UV 映射

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xffffff, 1.0))
      webGLRenderer.setSize(window.innerWidth/2, window.innerHeight/2)
      webGLRenderer.shadowMapEnabled = true

      // position and point the camera to the center of the scene
      camera.position.x = -30
      camera.position.y = 40
      camera.position.z = 50
      camera.lookAt(new THREE.Vector3(0, 0, 0))

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      // setup the control gui
      var controls = new (function () {
        // we need the first child, since it's a multimaterial
        this.loadCube1 = function () {
          var loader = new THREE.OBJLoader()
          loader.load("/assets/models/UVCube1.obj", function (geometry) {
            if (mesh) scene.remove(mesh)
            var material = new THREE.MeshBasicMaterial({ color: 0xffffff })
            var texture = THREE.ImageUtils.loadTexture(
              "/assets/textures/ash_uvgrid01.jpg"
            )
            material.map = texture

            geometry.children[0].material = material
            mesh = geometry

            geometry.scale.set(15, 15, 15)

            scene.add(geometry)
          })
        }

        this.loadCube2 = function () {
          var loader = new THREE.OBJLoader()
          loader.load("/assets/models/UVCube2.obj", function (geometry) {
            if (mesh) scene.remove(mesh)
            var material = new THREE.MeshBasicMaterial({ color: 0xffffff })
            var texture = THREE.ImageUtils.loadTexture(
              "/assets/textures/ash_uvgrid01.jpg"
            )
            material.map = texture

            geometry.children[0].material = material

            mesh = geometry
            geometry.scale.set(15, 15, 15)
            geometry.rotation.x = -0.3

            scene.add(geometry)
          })
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "loadCube1")
      gui.add(controls, "loadCube2")
      var mesh

      controls.loadCube1()

      render()

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        if (mesh) {
          mesh.rotation.y += 0.006
          mesh.rotation.x += 0.006
          //                mesh.rotation.y+=0.006;
        }

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 13.重复映射

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth/2, window.innerHeight/2)
      webGLRenderer.shadowMapEnabled = true

      var sphere = createMesh(
        new THREE.SphereGeometry(5, 20, 20),
        "floor-wood.jpg"
      )
      scene.add(sphere)
      sphere.position.x = 7

      var cube = createMesh(new THREE.BoxGeometry(6, 6, 6), "brick-wall.jpg")
      cube.position.x = -7
      scene.add(cube)
      console.log(cube.geometry.faceVertexUvs)

      // position and point the camera to the center of the scene
      camera.position.x = 0
      camera.position.y = 12
      camera.position.z = 20
      camera.lookAt(new THREE.Vector3(0, 0, 0))

      var ambiLight = new THREE.AmbientLight(0x141414)
      scene.add(ambiLight)

      var light = new THREE.DirectionalLight()
      light.position.set(0, 30, 20)
      scene.add(light)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      //        var polyhedron = createMesh(new THREE.PolyhedronGeometry(vertices, faces, controls.radius, controls.detail));

      // setup the control gui
      var controls = new (function () {
        this.repeatX = 1
        this.repeatY = 1
        this.repeatWrapping = true

        this.updateRepeat = function (e) {
          cube.material.map.repeat.set(controls.repeatX, controls.repeatY)
          sphere.material.map.repeat.set(controls.repeatX, controls.repeatY)

          if (controls.repeatWrapping) {
            cube.material.map.wrapS = THREE.RepeatWrapping
            cube.material.map.wrapT = THREE.RepeatWrapping
            sphere.material.map.wrapS = THREE.RepeatWrapping
            sphere.material.map.wrapT = THREE.RepeatWrapping
          } else {
            cube.material.map.wrapS = THREE.ClampToEdgeWrapping
            cube.material.map.wrapT = THREE.ClampToEdgeWrapping
            sphere.material.map.wrapS = THREE.ClampToEdgeWrapping
            sphere.material.map.wrapT = THREE.ClampToEdgeWrapping
          }

          cube.material.map.needsUpdate = true
          sphere.material.map.needsUpdate = true
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "repeatX", -4, 4).onChange(controls.updateRepeat)
      gui.add(controls, "repeatY", -4, 4).onChange(controls.updateRepeat)
      gui.add(controls, "repeatWrapping").onChange(controls.updateRepeat)

      render()

      function createMesh(geom, texture) {
        var texture = THREE.ImageUtils.loadTexture(
          "/assets/textures/general/" + texture
        )
        texture.wrapS = THREE.RepeatWrapping
        texture.wrapT = THREE.RepeatWrapping

        geom.computeVertexNormals()
        var mat = new THREE.MeshPhongMaterial()
        mat.map = texture

        // create a multimaterial
        var mesh = new THREE.Mesh(geom, mat)

        return mesh
      }

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()
        step += 0.01
        cube.rotation.y = step
        cube.rotation.x = step
        sphere.rotation.y = step
        sphere.rotation.x = step

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 14.画布纹理

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xbbbbbb, 1.0))
      webGLRenderer.setSize(window.innerWidth/2, window.innerHeight/2)
      webGLRenderer.shadowMapEnabled = true

      var cube = createMesh(new THREE.BoxGeometry(10, 10, 10), "floor-wood.jpg")
      cube.position.x = 0
      scene.add(cube)

      // position and point the camera to the center of the scene
      camera.position.x = 0
      camera.position.y = 12
      camera.position.z = 28
      camera.lookAt(new THREE.Vector3(0, 0, 0))

      var ambiLight = new THREE.AmbientLight(0x141414)
      scene.add(ambiLight)

      var light = new THREE.DirectionalLight()
      light.position.set(0, 30, 20)
      scene.add(light)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      //        var polyhedron = createMesh(new THREE.PolyhedronGeometry(vertices, faces, controls.radius, controls.detail));

      // setup the control gui
      var controls = new (function () {
        this.showTexture = true

        this.showCanvas = function () {
          if (controls.showTexture) {
            $(".fs-container").show()
          } else {
            $(".fs-container").hide()
          }
        }

        this.regenerateMap = function () {
          var date = new Date()
          pn = new Perlin("rnd" + date.getTime())
          fillWithPerlin(pn, ctx)
          cube.material.map.needsUpdate = true
          $("#cv").sketch()
        }

        this.applyTexture = function () {
          cube.material.map.needsUpdate = true
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "showTexture").onChange(controls.showCanvas)

      render()

      function createMesh(geom) {
        var canvasMap = new THREE.Texture(canvas)
        var mat = new THREE.MeshPhongMaterial()
        mat.map = canvasMap
        var mesh = new THREE.Mesh(geom, mat)

        return mesh
      }

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        cube.rotation.y += 0.01
        cube.rotation.x += 0.01

        cube.material.map.needsUpdate = true
        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 15.画布纹理凹凸贴图

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {},
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 16.视频纹理

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      texture: "",
    }
  },
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth/2, window.innerHeight/2)
      webGLRenderer.shadowMapEnabled = true

      var video = document.getElementById("video")
      this.texture = new THREE.Texture(video)
      this.texture.minFilter = THREE.LinearFilter
      this.texture.magFilter = THREE.LinearFilter
      this.texture.format = THREE.RGBFormat
      this.texture.generateMipmaps = false

      var cube

      cube = createMesh(new THREE.BoxGeometry(22, 16, 0.2), "floor-wood.jpg")
      cube.position.y = 2
      scene.add(cube)

      // position and point the camera to the center of the scene
      camera.position.x = 0
      camera.position.y = 1
      camera.position.z = 28
      camera.lookAt(new THREE.Vector3(0, 0, 0))

      var ambiLight = new THREE.AmbientLight(0x141414)
      scene.add(ambiLight)

      var light = new THREE.DirectionalLight()
      light.position.set(0, 30, 20)
      scene.add(light)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      //        var polyhedron = createMesh(new THREE.PolyhedronGeometry(vertices, faces, controls.radius, controls.detail));

      // setup the control gui
      var controls = new (function () {
        this.showVideo = false
        this.rotate = false

        this.showCanvas = function () {
          if (controls.showVideo) {
            $("#video").show()
          } else {
            $("#video").hide()
          }
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "rotate")
      gui.add(controls, "showVideo").onChange(controls.showCanvas)

      render()

      function createMesh(geom) {
        var materialArray = []
        materialArray.push(new THREE.MeshBasicMaterial({ color: 0x0051ba }))
        materialArray.push(new THREE.MeshBasicMaterial({ color: 0x0051ba }))
        materialArray.push(new THREE.MeshBasicMaterial({ color: 0x0051ba }))
        materialArray.push(new THREE.MeshBasicMaterial({ color: 0x0051ba }))
        materialArray.push(new THREE.MeshBasicMaterial({ map: texture }))
        materialArray.push(new THREE.MeshBasicMaterial({ color: 0xff51ba }))
        var faceMaterial = new THREE.MeshFaceMaterial(materialArray)

        // create a multimaterial
        var mesh = new THREE.Mesh(geom, faceMaterial)

        return mesh
      }

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        if (video.readyState === video.HAVE_ENOUGH_DATA) {
          if (texture) texture.needsUpdate = true
        }

        if (controls.rotate) {
          cube.rotation.x += -0.01
          cube.rotation.y += -0.01
          cube.rotation.z += -0.01
        }

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 17.视频纹理-非画布

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth/2, window.innerHeight/2)
      webGLRenderer.shadowMapEnabled = true

      var video = document.getElementById("video")
      texture = new THREE.VideoTexture(video)
      var cube

      cube = createMesh(new THREE.BoxGeometry(22, 16, 0.2), "floor-wood.jpg")
      cube.position.y = 2
      scene.add(cube)

      // position and point the camera to the center of the scene
      camera.position.x = 0
      camera.position.y = 1
      camera.position.z = 28
      camera.lookAt(new THREE.Vector3(0, 0, 0))

      var ambiLight = new THREE.AmbientLight(0x141414)
      scene.add(ambiLight)

      var light = new THREE.DirectionalLight()
      light.position.set(0, 30, 20)
      scene.add(light)

      // add the output of the renderer to the html element
      this.$refs.example.appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      //        var polyhedron = createMesh(new THREE.PolyhedronGeometry(vertices, faces, controls.radius, controls.detail));

      // setup the control gui
      var controls = new (function () {
        this.showVideo = false
        this.rotate = false

        this.showCanvas = function () {
          if (controls.showVideo) {
            $("#video").show()
          } else {
            $("#video").hide()
          }
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "rotate")
      gui.add(controls, "showVideo").onChange(controls.showCanvas)

      render()

      function createMesh(geom) {
        var materialArray = []
        materialArray.push(new THREE.MeshBasicMaterial({ color: 0x0051ba }))
        materialArray.push(new THREE.MeshBasicMaterial({ color: 0x0051ba }))
        materialArray.push(new THREE.MeshBasicMaterial({ color: 0x0051ba }))
        materialArray.push(new THREE.MeshBasicMaterial({ color: 0x0051ba }))
        materialArray.push(new THREE.MeshBasicMaterial({ map: texture }))
        materialArray.push(new THREE.MeshBasicMaterial({ color: 0xff51ba }))
        var faceMaterial = new THREE.MeshFaceMaterial(materialArray)

        // create a multimaterial
        var mesh = new THREE.Mesh(geom, faceMaterial)

        return mesh
      }

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        if (controls.rotate) {
          cube.rotation.x += -0.01
          cube.rotation.y += -0.01
          cube.rotation.z += -0.01
        }

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::
