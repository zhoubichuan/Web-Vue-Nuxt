---
lang: zh-CN
sidebarDepth: 0
meta:
  - name: description
    content: 个人总结的vuepress学习技术文档-主题
  - name: keywords
    content: vuepress,最新技术文档,vuepress主题
---

# 三.光源

## 1.环境光

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()
      var scene = new THREE.Scene()
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )
      var renderer = new THREE.WebGLRenderer()
      renderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      renderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      renderer.shadowMapEnabled = true
      var planeGeometry = new THREE.PlaneGeometry(60, 20, 1, 1)
      var planeMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff })
      var plane = new THREE.Mesh(planeGeometry, planeMaterial)
      plane.receiveShadow = true
      plane.rotation.x = -0.5 * Math.PI
      plane.position.x = 15
      plane.position.y = 0
      plane.position.z = 0
      scene.add(plane)
      var cubeGeometry = new THREE.BoxGeometry(4, 4, 4)
      var cubeMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 })
      var cube = new THREE.Mesh(cubeGeometry, cubeMaterial)
      cube.castShadow = true
      cube.position.x = -4
      cube.position.y = 3
      cube.position.z = 0
      scene.add(cube)
      var sphereGeometry = new THREE.SphereGeometry(4, 20, 20)
      var sphereMaterial = new THREE.MeshLambertMaterial({ color: 0x7777ff })
      var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial)
      sphere.position.x = 20
      sphere.position.y = 0
      sphere.position.z = 2
      sphere.castShadow = true
      scene.add(sphere)
      camera.position.x = -25
      camera.position.y = 30
      camera.position.z = 25
      camera.lookAt(new THREE.Vector3(10, 0, 0))
      var ambiColor = "#0c0c0c"
      var ambientLight = new THREE.AmbientLight(ambiColor)
      scene.add(ambientLight)
      var spotLight = new THREE.SpotLight(0xffffff)
      spotLight.position.set(-40, 60, -10)
      spotLight.castShadow = true
      scene.add(spotLight)
      this.$refs.example.appendChild(renderer.domElement)
      var step = 0
      var controls = new (function () {
        this.rotationSpeed = 0.02
        this.bouncingSpeed = 0.03
        this.ambientColor = ambiColor
        this.disableSpotlight = false
      })()

      var gui = new dat.GUI()
      gui.addColor(controls, "ambientColor").onChange(function (e) {
        ambientLight.color = new THREE.Color(e)
      })
      gui.add(controls, "disableSpotlight").onChange(function (e) {
        spotLight.visible = !e
      })
      this.$refs.gui.appendChild(gui.domElement)
      render()

      function render() {
        stats.update()
        cube.rotation.x += controls.rotationSpeed
        cube.rotation.y += controls.rotationSpeed
        cube.rotation.z += controls.rotationSpeed
        step += controls.bouncingSpeed
        sphere.position.x = 20 + 10 * Math.cos(step)
        sphere.position.y = 2 + 10 * Math.abs(Math.sin(step))
        requestAnimationFrame(render)
        renderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"

      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 2.点光源

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var renderer = new THREE.WebGLRenderer()

      renderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      renderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      // renderer.shadowMapEnabled = true;

      // create the ground plane
      var planeGeometry = new THREE.PlaneGeometry(60, 20, 20, 20)
      var planeMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff })
      var plane = new THREE.Mesh(planeGeometry, planeMaterial)
      plane.receiveShadow = true

      // rotate and position the plane
      plane.rotation.x = -0.5 * Math.PI
      plane.position.x = 15
      plane.position.y = 0
      plane.position.z = 0

      // add the plane to the scene
      scene.add(plane)

      // create a cube
      var cubeGeometry = new THREE.BoxGeometry(4, 4, 4)
      var cubeMaterial = new THREE.MeshLambertMaterial({ color: 0xff7777 })
      var cube = new THREE.Mesh(cubeGeometry, cubeMaterial)
      cube.castShadow = true

      // position the cube
      cube.position.x = -4
      cube.position.y = 3
      cube.position.z = 0

      // add the cube to the scene
      scene.add(cube)

      var sphereGeometry = new THREE.SphereGeometry(4, 20, 20)
      var sphereMaterial = new THREE.MeshLambertMaterial({ color: 0x7777ff })
      var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial)

      // position the sphere
      sphere.position.x = 20
      sphere.position.y = 0
      sphere.position.z = 2
      sphere.castShadow = true

      // add the sphere to the scene
      scene.add(sphere)

      // position and point the camera to the center of the scene
      camera.position.x = -25
      camera.position.y = 30
      camera.position.z = 25
      camera.lookAt(new THREE.Vector3(10, 0, 0))

      // add subtle ambient lighting
      var ambiColor = "#0c0c0c"
      var ambientLight = new THREE.AmbientLight(ambiColor)
      scene.add(ambientLight)

      // add spotlight for the shadows
      // add spotlight for the shadows
      var spotLight = new THREE.SpotLight(0xffffff)
      spotLight.position.set(-40, 60, -10)
      spotLight.castShadow = true
      // scene.add( spotLight );

      var pointColor = "#ccffcc"
      var pointLight = new THREE.PointLight(pointColor)
      pointLight.distance = 100
      scene.add(pointLight)

      // add a small sphere simulating the pointlight
      var sphereLight = new THREE.SphereGeometry(0.2)
      var sphereLightMaterial = new THREE.MeshBasicMaterial({ color: 0xac6c25 })
      var sphereLightMesh = new THREE.Mesh(sphereLight, sphereLightMaterial)
      sphereLightMesh.castShadow = true

      sphereLightMesh.position = new THREE.Vector3(3, 0, 3)
      scene.add(sphereLightMesh)

      // add the output of the renderer to the html element
      this.$refs.example.appendChild(renderer.domElement)

      // call the render function
      var step = 0

      // used to determine the switch point for the light animation
      var invert = 1
      var phase = 0

      var controls = new (function () {
        this.rotationSpeed = 0.03
        this.bouncingSpeed = 0.03
        this.ambientColor = ambiColor
        this.pointColor = pointColor
        this.intensity = 1
        this.distance = 100
      })()

      var gui = new dat.GUI()
      gui.addColor(controls, "ambientColor").onChange(function (e) {
        ambientLight.color = new THREE.Color(e)
      })

      gui.addColor(controls, "pointColor").onChange(function (e) {
        pointLight.color = new THREE.Color(e)
      })

      gui.add(controls, "intensity", 0, 3).onChange(function (e) {
        pointLight.intensity = e
      })

      gui.add(controls, "distance", 0, 100).onChange(function (e) {
        pointLight.distance = e
      })
      this.$refs.gui.appendChild(gui.domElement)
      render()

      function render() {
        stats.update()
        // rotate the cube around its axes
        cube.rotation.x += controls.rotationSpeed
        cube.rotation.y += controls.rotationSpeed
        cube.rotation.z += controls.rotationSpeed

        // bounce the sphere up and down
        step += controls.bouncingSpeed
        sphere.position.x = 20 + 10 * Math.cos(step)
        sphere.position.y = 2 + 10 * Math.abs(Math.sin(step))

        // move the light simulation
        if (phase > 2 * Math.PI) {
          invert = invert * -1
          phase -= 2 * Math.PI
        } else {
          phase += controls.rotationSpeed
        }
        sphereLightMesh.position.z = +(7 * Math.sin(phase))
        sphereLightMesh.position.x = +(14 * Math.cos(phase))
        sphereLightMesh.position.y = 5

        if (invert < 0) {
          var pivot = 14
          sphereLightMesh.position.x =
            invert * (sphereLightMesh.position.x - pivot) + pivot
        }

        pointLight.position.copy(sphereLightMesh.position)

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        renderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()

      stats.setMode(0) // 0: fps, 1: ms

      // Align top-left
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"

      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 3.聚光灯

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stopMovingLight = false

      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var renderer = new THREE.WebGLRenderer()

      renderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      renderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      renderer.shadowMapEnabled = true
      renderer.shadowMapType = THREE.PCFShadowMap

      // create the ground plane
      var planeGeometry = new THREE.PlaneGeometry(60, 20, 1, 1)
      var planeMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff })
      var plane = new THREE.Mesh(planeGeometry, planeMaterial)
      plane.receiveShadow = true

      // rotate and position the plane
      plane.rotation.x = -0.5 * Math.PI
      plane.position.x = 15
      plane.position.y = 0
      plane.position.z = 0

      // add the plane to the scene
      scene.add(plane)

      // create a cube
      var cubeGeometry = new THREE.BoxGeometry(4, 4, 4)
      var cubeMaterial = new THREE.MeshLambertMaterial({ color: 0xff3333 })
      var cube = new THREE.Mesh(cubeGeometry, cubeMaterial)
      cube.castShadow = true

      // position the cube
      cube.position.x = -4
      cube.position.y = 3
      cube.position.z = 0

      // add the cube to the scene
      scene.add(cube)

      var sphereGeometry = new THREE.SphereGeometry(4, 20, 20)
      var sphereMaterial = new THREE.MeshLambertMaterial({ color: 0x7777ff })
      var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial)

      // position the sphere
      sphere.position.x = 20
      sphere.position.y = 0
      sphere.position.z = 2
      sphere.castShadow = true

      // add the sphere to the scene
      scene.add(sphere)

      // position and point the camera to the center of the scene
      camera.position.x = -35
      camera.position.y = 30
      camera.position.z = 25
      camera.lookAt(new THREE.Vector3(10, 0, 0))

      // add subtle ambient lighting
      var ambiColor = "#1c1c1c"
      var ambientLight = new THREE.AmbientLight(ambiColor)
      scene.add(ambientLight)

      // add spotlight for a bit of light
      var spotLight0 = new THREE.SpotLight(0xcccccc)
      spotLight0.position.set(-40, 30, -10)
      spotLight0.lookAt(plane)
      scene.add(spotLight0)

      var target = new THREE.Object3D()
      target.position = new THREE.Vector3(5, 0, 0)

      var pointColor = "#ffffff"
      var spotLight = new THREE.SpotLight(pointColor)
      spotLight.position.set(-40, 60, -10)
      spotLight.castShadow = true
      spotLight.shadowCameraNear = 2
      spotLight.shadowCameraFar = 200
      spotLight.shadowCameraFov = 30
      spotLight.target = plane
      spotLight.distance = 0
      spotLight.angle = 0.4

      scene.add(spotLight)

      // add a small sphere simulating the pointlight
      var sphereLight = new THREE.SphereGeometry(0.2)
      var sphereLightMaterial = new THREE.MeshBasicMaterial({ color: 0xac6c25 })
      var sphereLightMesh = new THREE.Mesh(sphereLight, sphereLightMaterial)
      sphereLightMesh.castShadow = true

      sphereLightMesh.position = new THREE.Vector3(3, 20, 3)
      scene.add(sphereLightMesh)

      // add the output of the renderer to the html element
      this.$refs.example.appendChild(renderer.domElement)

      // call the render function
      var step = 0

      // used to determine the switch point for the light animation
      var invert = 1
      var phase = 0

      var controls = new (function () {
        this.rotationSpeed = 0.03
        this.bouncingSpeed = 0.03
        this.ambientColor = ambiColor
        this.pointColor = pointColor
        this.intensity = 1
        this.distance = 0
        this.exponent = 30
        this.angle = 0.1
        this.debug = false
        this.castShadow = true
        this.onlyShadow = false
        this.target = "Plane"
        this.stopMovingLight = false
      })()

      var gui = new dat.GUI()
      gui.addColor(controls, "ambientColor").onChange(function (e) {
        ambientLight.color = new THREE.Color(e)
      })

      gui.addColor(controls, "pointColor").onChange(function (e) {
        spotLight.color = new THREE.Color(e)
      })

      gui.add(controls, "angle", 0, Math.PI * 2).onChange(function (e) {
        spotLight.angle = e
      })

      gui.add(controls, "intensity", 0, 5).onChange(function (e) {
        spotLight.intensity = e
      })

      gui.add(controls, "distance", 0, 200).onChange(function (e) {
        spotLight.distance = e
      })

      gui.add(controls, "exponent", 0, 100).onChange(function (e) {
        spotLight.exponent = e
      })

      gui.add(controls, "debug").onChange(function (e) {
        spotLight.shadowCameraVisible = e
      })

      gui.add(controls, "castShadow").onChange(function (e) {
        spotLight.castShadow = e
      })

      gui.add(controls, "onlyShadow").onChange(function (e) {
        spotLight.onlyShadow = e
      })

      gui
        .add(controls, "target", ["Plane", "Sphere", "Cube"])
        .onChange(function (e) {
          console.log(e)
          switch (e) {
            case "Plane":
              spotLight.target = plane
              break
            case "Sphere":
              spotLight.target = sphere
              break
            case "Cube":
              spotLight.target = cube
              break
          }
        })

      gui.add(controls, "stopMovingLight").onChange(function (e) {
        stopMovingLight = e
      })
      this.$refs.gui.appendChild(gui.domElement)
      render()

      function render() {
        stats.update()
        // rotate the cube around its axes
        cube.rotation.x += controls.rotationSpeed
        cube.rotation.y += controls.rotationSpeed
        cube.rotation.z += controls.rotationSpeed

        // bounce the sphere up and down
        step += controls.bouncingSpeed
        sphere.position.x = 20 + 10 * Math.cos(step)
        sphere.position.y = 2 + 10 * Math.abs(Math.sin(step))

        // move the light simulation
        if (!stopMovingLight) {
          if (phase > 2 * Math.PI) {
            invert = invert * -1
            phase -= 2 * Math.PI
          } else {
            phase += controls.rotationSpeed
          }
          sphereLightMesh.position.z = +(7 * Math.sin(phase))
          sphereLightMesh.position.x = +(14 * Math.cos(phase))
          sphereLightMesh.position.y = 10

          if (invert < 0) {
            var pivot = 14
            sphereLightMesh.position.x =
              invert * (sphereLightMesh.position.x - pivot) + pivot
          }

          spotLight.position.copy(sphereLightMesh.position)
        }

        // render using requestAnimationFrame
        requestAnimationFrame(render)

        renderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()

      stats.setMode(0) // 0: fps, 1: ms

      // Align top-left
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"

      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 4.平行光

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var renderer = new THREE.WebGLRenderer()

      renderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      renderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      renderer.shadowMapEnabled = true

      // create the ground plane
      var planeGeometry = new THREE.PlaneGeometry(600, 200, 20, 20)
      var planeMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff })
      var plane = new THREE.Mesh(planeGeometry, planeMaterial)
      plane.receiveShadow = true

      // rotate and position the plane
      plane.rotation.x = -0.5 * Math.PI
      plane.position.x = 15
      plane.position.y = -5
      plane.position.z = 0

      // add the plane to the scene
      scene.add(plane)

      // create a cube
      var cubeGeometry = new THREE.BoxGeometry(4, 4, 4)
      var cubeMaterial = new THREE.MeshLambertMaterial({ color: 0xff3333 })
      var cube = new THREE.Mesh(cubeGeometry, cubeMaterial)
      cube.castShadow = true

      // position the cube
      cube.position.x = -4
      cube.position.y = 3
      cube.position.z = 0

      // add the cube to the scene
      scene.add(cube)

      var sphereGeometry = new THREE.SphereGeometry(4, 20, 20)
      var sphereMaterial = new THREE.MeshLambertMaterial({ color: 0x7777ff })
      var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial)

      // position the sphere
      sphere.position.x = 20
      sphere.position.y = 0
      sphere.position.z = 2
      sphere.castShadow = true

      // add the sphere to the scene
      scene.add(sphere)

      // position and point the camera to the center of the scene
      camera.position.x = -35
      camera.position.y = 30
      camera.position.z = 25
      camera.lookAt(new THREE.Vector3(10, 0, 0))

      // add subtle ambient lighting
      var ambiColor = "#1c1c1c"
      var ambientLight = new THREE.AmbientLight(ambiColor)
      scene.add(ambientLight)

      var target = new THREE.Object3D()
      target.position = new THREE.Vector3(5, 0, 0)

      var pointColor = "#ff5808"
      var directionalLight = new THREE.DirectionalLight(pointColor)
      directionalLight.position.set(-40, 60, -10)
      directionalLight.castShadow = true
      directionalLight.shadowCameraNear = 2
      directionalLight.shadowCameraFar = 200
      directionalLight.shadowCameraLeft = -50
      directionalLight.shadowCameraRight = 50
      directionalLight.shadowCameraTop = 50
      directionalLight.shadowCameraBottom = -50

      directionalLight.distance = 0
      directionalLight.intensity = 0.5
      directionalLight.shadowMapHeight = 1024
      directionalLight.shadowMapWidth = 1024

      scene.add(directionalLight)

      // add a small sphere simulating the pointlight
      var sphereLight = new THREE.SphereGeometry(0.2)
      var sphereLightMaterial = new THREE.MeshBasicMaterial({ color: 0xac6c25 })
      var sphereLightMesh = new THREE.Mesh(sphereLight, sphereLightMaterial)
      sphereLightMesh.castShadow = true

      sphereLightMesh.position = new THREE.Vector3(3, 20, 3)
      scene.add(sphereLightMesh)

      // add the output of the renderer to the html element
      this.$refs.example.appendChild(renderer.domElement)

      // call the render function
      var step = 0

      // used to determine the switch point for the light animation
      var invert = 1
      var phase = 0

      var controls = new (function () {
        this.rotationSpeed = 0.03
        this.bouncingSpeed = 0.03
        this.ambientColor = ambiColor
        this.pointColor = pointColor
        this.intensity = 0.5
        this.distance = 0
        this.exponent = 30
        this.angle = 0.1
        this.debug = false
        this.castShadow = true
        this.onlyShadow = false
        this.target = "Plane"
      })()

      var gui = new dat.GUI()
      gui.addColor(controls, "ambientColor").onChange(function (e) {
        ambientLight.color = new THREE.Color(e)
      })

      gui.addColor(controls, "pointColor").onChange(function (e) {
        directionalLight.color = new THREE.Color(e)
      })

      gui.add(controls, "intensity", 0, 5).onChange(function (e) {
        directionalLight.intensity = e
      })

      gui.add(controls, "distance", 0, 200).onChange(function (e) {
        directionalLight.distance = e
      })

      gui.add(controls, "debug").onChange(function (e) {
        directionalLight.shadowCameraVisible = e
      })

      gui.add(controls, "castShadow").onChange(function (e) {
        directionalLight.castShadow = e
      })

      gui.add(controls, "onlyShadow").onChange(function (e) {
        directionalLight.onlyShadow = e
      })

      gui
        .add(controls, "target", ["Plane", "Sphere", "Cube"])
        .onChange(function (e) {
          console.log(e)
          switch (e) {
            case "Plane":
              directionalLight.target = plane
              break
            case "Sphere":
              directionalLight.target = sphere
              break
            case "Cube":
              directionalLight.target = cube
              break
          }
        })
      this.$refs.gui.appendChild(gui.domElement)
      render()

      function render() {
        stats.update()
        // rotate the cube around its axes
        cube.rotation.x += controls.rotationSpeed
        cube.rotation.y += controls.rotationSpeed
        cube.rotation.z += controls.rotationSpeed

        // bounce the sphere up and down
        step += controls.bouncingSpeed
        sphere.position.x = 20 + 10 * Math.cos(step)
        sphere.position.y = 2 + 10 * Math.abs(Math.sin(step))

        sphereLightMesh.position.z = -8
        sphereLightMesh.position.y = +(27 * Math.sin(step / 3))
        sphereLightMesh.position.x = 10 + 26 * Math.cos(step / 3)

        directionalLight.position.copy(sphereLightMesh.position)

        // render using requestAnimationFrame
        requestAnimationFrame(render)

        renderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()

      stats.setMode(0) // 0: fps, 1: ms

      // Align top-left
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"

      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 5.半球光

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()
      scene.fog = new THREE.Fog(0xaaaaaa, 0.01, 200)

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var renderer = new THREE.WebGLRenderer()

      renderer.setClearColor(new THREE.Color(0xaaaaff, 1.0))
      renderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      renderer.shadowMapEnabled = true

      // create the ground plane
      var textureGrass = THREE.ImageUtils.loadTexture(
        "../assets/textures/ground/grasslight-big.jpg"
      )
      textureGrass.wrapS = THREE.RepeatWrapping
      textureGrass.wrapT = THREE.RepeatWrapping
      textureGrass.repeat.set(4, 4)

      var planeGeometry = new THREE.PlaneGeometry(1000, 200, 20, 20)
      var planeMaterial = new THREE.MeshLambertMaterial({ map: textureGrass })
      //        var planeMaterial = new THREE.MeshLambertMaterial();
      var plane = new THREE.Mesh(planeGeometry, planeMaterial)
      plane.receiveShadow = true

      // rotate and position the plane
      plane.rotation.x = -0.5 * Math.PI
      plane.position.x = 15
      plane.position.y = 0
      plane.position.z = 0

      // add the plane to the scene
      scene.add(plane)

      // create a cube
      var cubeGeometry = new THREE.BoxGeometry(4, 4, 4)
      var cubeMaterial = new THREE.MeshLambertMaterial({ color: 0xff3333 })
      var cube = new THREE.Mesh(cubeGeometry, cubeMaterial)
      cube.castShadow = true

      // position the cube
      cube.position.x = -4
      cube.position.y = 3
      cube.position.z = 0

      // add the cube to the scene
      scene.add(cube)

      var sphereGeometry = new THREE.SphereGeometry(4, 25, 25)
      var sphereMaterial = new THREE.MeshLambertMaterial({ color: 0x7777ff })
      var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial)

      // position the sphere
      sphere.position.x = 10
      sphere.position.y = 5
      sphere.position.z = 10
      sphere.castShadow = true

      // add the sphere to the scene
      scene.add(sphere)

      // position and point the camera to the center of the scene
      camera.position.x = -20
      camera.position.y = 15
      camera.position.z = 45
      //        camera.position.x = -120;
      //        camera.position.y = 165;
      //        camera.position.z = 145;
      camera.lookAt(new THREE.Vector3(10, 0, 0))

      // add spotlight for a bit of light
      var spotLight0 = new THREE.SpotLight(0xcccccc)
      spotLight0.position.set(-40, 60, -10)
      spotLight0.lookAt(plane)
      scene.add(spotLight0)

      var target = new THREE.Object3D()
      target.position = new THREE.Vector3(5, 0, 0)

      var hemiLight = new THREE.HemisphereLight(0x0000ff, 0x00ff00, 0.6)
      hemiLight.position.set(0, 500, 0)
      scene.add(hemiLight)

      var pointColor = "#ffffff"
      //    var dirLight = new THREE.SpotLight( pointColor);
      var dirLight = new THREE.DirectionalLight(pointColor)
      dirLight.position.set(30, 10, -50)
      dirLight.castShadow = true
      //        dirLight.shadowCameraNear = 0.1;
      //        dirLight.shadowCameraFar = 100;
      //        dirLight.shadowCameraFov = 50;
      dirLight.target = plane
      dirLight.shadowCameraNear = 0.1
      dirLight.shadowCameraFar = 200
      dirLight.shadowCameraLeft = -50
      dirLight.shadowCameraRight = 50
      dirLight.shadowCameraTop = 50
      dirLight.shadowCameraBottom = -50
      dirLight.shadowMapWidth = 2048
      dirLight.shadowMapHeight = 2048

      scene.add(dirLight)

      // add the output of the renderer to the html element
      this.$refs.example.appendChild(renderer.domElement)

      // call the render function
      var step = 0

      // used to determine the switch point for the light animation
      var invert = 1
      var phase = 0

      var controls = new (function () {
        this.rotationSpeed = 0.03
        this.bouncingSpeed = 0.03

        this.hemisphere = true
        this.color = 0x00ff00
        this.skyColor = 0x0000ff
        this.intensity = 0.6
      })()

      var gui = new dat.GUI()

      gui.add(controls, "hemisphere").onChange(function (e) {
        if (!e) {
          hemiLight.intensity = 0
        } else {
          hemiLight.intensity = controls.intensity
        }
      })
      gui.addColor(controls, "color").onChange(function (e) {
        hemiLight.groundColor = new THREE.Color(e)
      })
      gui.addColor(controls, "skyColor").onChange(function (e) {
        hemiLight.color = new THREE.Color(e)
      })
      gui.add(controls, "intensity", 0, 5).onChange(function (e) {
        hemiLight.intensity = e
      })
      this.$refs.gui.appendChild(gui.domElement)
      render()

      function render() {
        stats.update()
        // rotate the cube around its axes
        cube.rotation.x += controls.rotationSpeed
        cube.rotation.y += controls.rotationSpeed
        cube.rotation.z += controls.rotationSpeed

        // bounce the sphere up and down
        step += controls.bouncingSpeed
        sphere.position.x = 20 + 10 * Math.cos(step)
        sphere.position.y = 2 + 10 * Math.abs(Math.sin(step))

        requestAnimationFrame(render)
        renderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()

      stats.setMode(0) // 0: fps, 1: ms

      // Align top-left
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"

      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 6.区域光

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )
      scene.add(camera)

      // create a render and set the size
      //        var renderer = new THREE.WebGLRenderer();
      var renderer = new THREE.WebGLDeferredRenderer({
        width: window.innerWidth,
        height: window.innerHeight,
        scale: 1,
        antialias: true,
        tonemapping: THREE.FilmicOperator,
        brightness: 2.5,
      })

      //        renderer.setSize(window.innerWidth / 2, window.innerHeight / 2);
      //        renderer.shadowMapEnabled = true;

      // create the ground plane
      var planeGeometry = new THREE.PlaneGeometry(70, 70, 1, 1)
      var planeMaterial = new THREE.MeshPhongMaterial({
        color: 0xffffff,
        specular: 0xffffff,
        shininess: 200,
      })
      var plane = new THREE.Mesh(planeGeometry, planeMaterial)
      // plane.receiveShadow  = true;

      // rotate and position the plane
      plane.rotation.x = -0.5 * Math.PI
      plane.position.x = 0
      plane.position.y = 0
      plane.position.z = 0

      // add the plane to the scene
      scene.add(plane)

      // position and point the camera to the center of the scene
      camera.position.x = 20
      camera.position.y = 30
      camera.position.z = 21
      camera.lookAt(new THREE.Vector3(0, 0, -30))

      // add the output of the renderer to the html element
      this.$refs.example.appendChild(renderer.domElement)

      // call the render function
      var step = 0

      var spotLight0 = new THREE.SpotLight(0xcccccc)
      spotLight0.position.set(-40, 60, -10)
      spotLight0.intensity = 0.1
      spotLight0.lookAt(plane)
      scene.add(spotLight0)

      var areaLight1 = new THREE.AreaLight(0xff0000, 3)
      areaLight1.position.set(-10, 10, -35)
      areaLight1.rotation.set(-Math.PI / 2, 0, 0)
      areaLight1.width = 4
      areaLight1.height = 9.9
      scene.add(areaLight1)

      var areaLight2 = new THREE.AreaLight(0x00ff00, 3)
      areaLight2.position.set(0, 10, -35)
      areaLight2.rotation.set(-Math.PI / 2, 0, 0)
      areaLight2.width = 4
      areaLight2.height = 9.9
      scene.add(areaLight2)

      var areaLight3 = new THREE.AreaLight(0x0000ff, 3)
      areaLight3.position.set(10, 10, -35)
      areaLight3.rotation.set(-Math.PI / 2, 0, 0)
      areaLight3.width = 4
      areaLight3.height = 9.9
      scene.add(areaLight3)

      var planeGeometry1 = new THREE.BoxGeometry(4, 10, 0)
      var planeGeometry1Mat = new THREE.MeshBasicMaterial({ color: 0xff0000 })
      var plane1 = new THREE.Mesh(planeGeometry1, planeGeometry1Mat)
      plane1.position.copy(areaLight1.position)
      scene.add(plane1)

      var planeGeometry2 = new THREE.BoxGeometry(4, 10, 0)
      var planeGeometry2Mat = new THREE.MeshBasicMaterial({ color: 0x00ff00 })
      var plane2 = new THREE.Mesh(planeGeometry2, planeGeometry2Mat)

      plane2.position.copy(areaLight2.position)
      scene.add(plane2)

      var planeGeometry3 = new THREE.BoxGeometry(4, 10, 0)
      var planeGeometry3Mat = new THREE.MeshBasicMaterial({ color: 0x0000ff })
      var plane3 = new THREE.Mesh(planeGeometry3, planeGeometry3Mat)

      plane3.position.copy(areaLight3.position)
      scene.add(plane3)

      var controls = new (function () {
        this.rotationSpeed = 0.02
        this.color1 = 0xff0000
        this.intensity1 = 2
        this.color2 = 0x00ff00
        this.intensity2 = 2
        this.color3 = 0x0000ff
        this.intensity3 = 2
      })()

      var gui = new dat.GUI()
      gui.addColor(controls, "color1").onChange(function (e) {
        areaLight1.color = new THREE.Color(e)
        planeGeometry1Mat.color = new THREE.Color(e)
        scene.remove(plane1)
        plane1 = new THREE.Mesh(planeGeometry1, planeGeometry1Mat)
        plane1.position.copy(areaLight1.position)
        scene.add(plane1)
      })
      gui.add(controls, "intensity1", 0, 5).onChange(function (e) {
        areaLight1.intensity = e
      })
      gui.addColor(controls, "color2").onChange(function (e) {
        areaLight2.color = new THREE.Color(e)
        planeGeometry2Mat.color = new THREE.Color(e)
        scene.remove(plane2)
        plane2 = new THREE.Mesh(planeGeometry2, planeGeometry2Mat)
        plane2.position.copy(areaLight2.position)
        scene.add(plane2)
      })
      gui.add(controls, "intensity2", 0, 5).onChange(function (e) {
        areaLight2.intensity = e
      })
      gui.addColor(controls, "color3").onChange(function (e) {
        areaLight3.color = new THREE.Color(e)
        planeGeometry3Mat.color = new THREE.Color(e)
        scene.remove(plane3)
        plane3 = new THREE.Mesh(planeGeometry1, planeGeometry3Mat)
        plane3.position.copy(areaLight3.position)
        scene.add(plane3)
      })
      gui.add(controls, "intensity3", 0, 5).onChange(function (e) {
        areaLight3.intensity = e
      })
      this.$refs.gui.appendChild(gui.domElement)
      render()

      function render() {
        stats.update()

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        renderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()

      stats.setMode(0) // 0: fps, 1: ms

      // Align top-left
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"

      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 7.只读

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()
      scene.fog = new THREE.Fog(0xaaaaaa, 0.01, 200)

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true })

      renderer.setClearColor(new THREE.Color(0xaaaaff, 1.0))
      renderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      renderer.shadowMapEnabled = true

      // create the ground plane
      var textureGrass = THREE.ImageUtils.loadTexture(
        "../assets/textures/ground/grasslight-big.jpg"
      )
      textureGrass.wrapS = THREE.RepeatWrapping
      textureGrass.wrapT = THREE.RepeatWrapping
      textureGrass.repeat.set(4, 4)

      var planeGeometry = new THREE.PlaneGeometry(1000, 200, 20, 20)
      var planeMaterial = new THREE.MeshLambertMaterial({ map: textureGrass })
      var plane = new THREE.Mesh(planeGeometry, planeMaterial)
      plane.receiveShadow = true

      // rotate and position the plane
      plane.rotation.x = -0.5 * Math.PI
      plane.position.x = 15
      plane.position.y = 0
      plane.position.z = 0

      // add the plane to the scene
      scene.add(plane)

      // create a cube
      var cubeGeometry = new THREE.BoxGeometry(4, 4, 4)
      var cubeMaterial = new THREE.MeshLambertMaterial({ color: 0xff3333 })
      var cube = new THREE.Mesh(cubeGeometry, cubeMaterial)
      cube.castShadow = true

      // position the cube
      cube.position.x = -4
      cube.position.y = 3
      cube.position.z = 0

      // add the cube to the scene
      scene.add(cube)

      var sphereGeometry = new THREE.SphereGeometry(4, 25, 25)
      var sphereMaterial = new THREE.MeshLambertMaterial({ color: 0x7777ff })
      var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial)

      // position the sphere
      sphere.position.x = 10
      sphere.position.y = 5
      sphere.position.z = 10
      sphere.castShadow = true

      // add the sphere to the scene
      scene.add(sphere)

      // position and point the camera to the center of the scene
      camera.position.x = -20
      camera.position.y = 15
      camera.position.z = 45
      camera.lookAt(new THREE.Vector3(10, 0, 0))

      // add subtle ambient lighting
      var ambiColor = "#1c1c1c"
      var ambientLight = new THREE.AmbientLight(ambiColor)
      scene.add(ambientLight)

      // add spotlight for a bit of light
      var spotLight0 = new THREE.SpotLight(0xcccccc)
      spotLight0.position.set(-40, 60, -10)
      spotLight0.lookAt(plane)
      scene.add(spotLight0)

      var target = new THREE.Object3D()
      target.position = new THREE.Vector3(5, 0, 0)

      var pointColor = "#ffffff"
      //    var spotLight = new THREE.SpotLight( pointColor);
      var spotLight = new THREE.DirectionalLight(pointColor)
      spotLight.position.set(30, 10, -50)
      spotLight.castShadow = true
      spotLight.shadowCameraNear = 0.1
      spotLight.shadowCameraFar = 100
      spotLight.shadowCameraFov = 50
      spotLight.target = plane
      spotLight.distance = 0
      spotLight.shadowCameraNear = 2
      spotLight.shadowCameraFar = 200
      spotLight.shadowCameraLeft = -100
      spotLight.shadowCameraRight = 100
      spotLight.shadowCameraTop = 100
      spotLight.shadowCameraBottom = -100
      spotLight.shadowMapWidth = 2048
      spotLight.shadowMapHeight = 2048

      scene.add(spotLight)

      // add the output of the renderer to the html element
      this.$refs.example.appendChild(renderer.domElement)

      // call the render function
      var step = 0

      // used to determine the switch point for the light animation
      var invert = 1
      var phase = 0

      var controls = new (function () {
        this.rotationSpeed = 0.03
        this.bouncingSpeed = 0.03
        this.ambientColor = ambiColor
        this.pointColor = pointColor
        this.intensity = 0.1
        this.distance = 0
        this.exponent = 30
        this.angle = 0.1
        this.debug = false
        this.castShadow = true
        this.onlyShadow = false
        this.target = "Plane"
      })()

      var gui = new dat.GUI()
      gui.addColor(controls, "ambientColor").onChange(function (e) {
        ambientLight.color = new THREE.Color(e)
      })

      gui.addColor(controls, "pointColor").onChange(function (e) {
        spotLight.color = new THREE.Color(e)
      })

      gui.add(controls, "intensity", 0, 5).onChange(function (e) {
        spotLight.intensity = e
      })

      var textureFlare0 = THREE.ImageUtils.loadTexture(
        "../assets/textures/lensflare/lensflare0.png"
      )
      var textureFlare3 = THREE.ImageUtils.loadTexture(
        "../assets/textures/lensflare/lensflare3.png"
      )

      var flareColor = new THREE.Color(0xffaacc)
      var lensFlare = new THREE.LensFlare(
        textureFlare0,
        350,
        0.0,
        THREE.AdditiveBlending,
        flareColor
      )

      lensFlare.add(textureFlare3, 60, 0.6, THREE.AdditiveBlending)
      lensFlare.add(textureFlare3, 70, 0.7, THREE.AdditiveBlending)
      lensFlare.add(textureFlare3, 120, 0.9, THREE.AdditiveBlending)
      lensFlare.add(textureFlare3, 70, 1.0, THREE.AdditiveBlending)

      lensFlare.position.copy(spotLight.position)
      scene.add(lensFlare)
      this.$refs.gui.appendChild(gui.domElement)
      render()

      function render() {
        stats.update()
        // rotate the cube around its axes
        cube.rotation.x += controls.rotationSpeed
        cube.rotation.y += controls.rotationSpeed
        cube.rotation.z += controls.rotationSpeed

        // bounce the sphere up and down
        step += controls.bouncingSpeed
        sphere.position.x = 20 + 10 * Math.cos(step)
        sphere.position.y = 2 + 10 * Math.abs(Math.sin(step))

        requestAnimationFrame(render)
        renderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()

      stats.setMode(0) // 0: fps, 1: ms

      // Align top-left
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"

      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::
