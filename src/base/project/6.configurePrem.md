---
lang: zh-CN
sidebarDepth: 0
meta:
  - name: description
    content: 个人总结的vuepress学习技术文档-主题
  - name: keywords
    content: vuepress,最新技术文档,vuepress主题
---

# 六.三维

## 1.凸包

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      // position and point the camera to the center of the scene
      camera.position.x = -30
      camera.position.y = 40
      camera.position.z = 50
      camera.lookAt(new THREE.Vector3(10, 0, 0))

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      // the points group
      var spGroup
      // the mesh
      var hullMesh

      generatePoints()

      // setup the control gui
      var controls = new (function () {
        // we need the first child, since it's a multimaterial

        this.redraw = function () {
          scene.remove(spGroup)
          scene.remove(hullMesh)
          generatePoints()
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "redraw")

      render()

      function generatePoints() {
        // add 10 random spheres
        var points = []
        for (var i = 0; i < 20; i++) {
          var randomX = -15 + Math.round(Math.random() * 30)
          var randomY = -15 + Math.round(Math.random() * 30)
          var randomZ = -15 + Math.round(Math.random() * 30)

          points.push(new THREE.Vector3(randomX, randomY, randomZ))
        }

        spGroup = new THREE.Object3D()
        var material = new THREE.MeshBasicMaterial({
          color: 0xff0000,
          transparent: false,
        })
        points.forEach(function (point) {
          var spGeom = new THREE.SphereGeometry(0.2)
          var spMesh = new THREE.Mesh(spGeom, material)
          spMesh.position.copy(point)
          spGroup.add(spMesh)
        })
        // add the points as a group to the scene
        scene.add(spGroup)

        // use the same points to create a convexgeometry
        var hullGeometry = new THREE.ConvexGeometry(points)
        hullMesh = createMesh(hullGeometry)
        scene.add(hullMesh)
      }

      function createMesh(geom) {
        // assign two materials
        var meshMaterial = new THREE.MeshBasicMaterial({
          color: 0x00ff00,
          transparent: true,
          opacity: 0.2,
        })
        meshMaterial.side = THREE.DoubleSide
        var wireFrameMat = new THREE.MeshBasicMaterial()
        wireFrameMat.wireframe = true

        // create a multimaterial
        var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [
          meshMaterial,
          wireFrameMat,
        ])

        return mesh
      }

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        spGroup.rotation.y = step
        hullMesh.rotation.y = step += 0.01

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 2.车床

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      // position and point the camera to the center of the scene
      camera.position.x = -30
      camera.position.y = 40
      camera.position.z = 50
      camera.lookAt(new THREE.Vector3(10, 0, 0))

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      // the points group
      var spGroup
      // the mesh
      var latheMesh

      generatePoints(12, 2, 2 * Math.PI)

      // setup the control gui
      var controls = new (function () {
        // we need the first child, since it's a multimaterial

        this.segments = 12
        this.phiStart = 0
        this.phiLength = 2 * Math.PI

        this.redraw = function () {
          scene.remove(spGroup)
          scene.remove(latheMesh)
          generatePoints(
            controls.segments,
            controls.phiStart,
            controls.phiLength
          )
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "segments", 0, 50).step(1).onChange(controls.redraw)
      gui.add(controls, "phiStart", 0, 2 * Math.PI).onChange(controls.redraw)
      gui.add(controls, "phiLength", 0, 2 * Math.PI).onChange(controls.redraw)

      render()

      function generatePoints(segments, phiStart, phiLength) {
        // add 10 random spheres
        var points = []
        var height = 5
        var count = 30
        for (var i = 0; i < count; i++) {
          points.push(
            new THREE.Vector3(
              (Math.sin(i * 0.2) + Math.cos(i * 0.3)) * height + 12,
              0,
              i - count + count / 2
            )
          )
        }

        spGroup = new THREE.Object3D()
        var material = new THREE.MeshBasicMaterial({
          color: 0xff0000,
          transparent: false,
        })
        points.forEach(function (point) {
          var spGeom = new THREE.SphereGeometry(0.2)
          var spMesh = new THREE.Mesh(spGeom, material)
          spMesh.position.copy(point)
          spGroup.add(spMesh)
        })
        // add the points as a group to the scene
        scene.add(spGroup)

        // use the same points to create a LatheGeometry
        var latheGeometry = new THREE.LatheGeometry(
          points,
          segments,
          phiStart,
          phiLength
        )
        latheMesh = createMesh(latheGeometry)

        scene.add(latheMesh)
      }

      function createMesh(geom) {
        // assign two materials
        //  var meshMaterial = new THREE.MeshBasicMaterial({color:0x00ff00, transparent:true, opacity:0.6});
        var meshMaterial = new THREE.MeshNormalMaterial()
        meshMaterial.side = THREE.DoubleSide
        var wireFrameMat = new THREE.MeshBasicMaterial()
        wireFrameMat.wireframe = true

        // create a multimaterial
        var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [
          meshMaterial,
          wireFrameMat,
        ])

        return mesh
      }

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        spGroup.rotation.x = step
        latheMesh.rotation.x = step += 0.01

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 3.挤出几何体

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      var shape = createMesh(new THREE.ShapeGeometry(drawShape()))
      // add the sphere to the scene
      scene.add(shape)

      // position and point the camera to the center of the scene
      camera.position.x = -20
      camera.position.y = 60
      camera.position.z = 60
      camera.lookAt(new THREE.Vector3(20, 20, 0))

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      // setup the control gui
      var controls = new (function () {
        this.amount = 2
        this.bevelThickness = 2
        this.bevelSize = 0.5
        this.bevelEnabled = true
        this.bevelSegments = 3
        this.bevelEnabled = true
        this.curveSegments = 12
        this.steps = 1

        this.asGeom = function () {
          // remove the old plane
          scene.remove(shape)
          // create a new one

          var options = {
            amount: controls.amount,
            bevelThickness: controls.bevelThickness,
            bevelSize: controls.bevelSize,
            bevelSegments: controls.bevelSegments,
            bevelEnabled: controls.bevelEnabled,
            curveSegments: controls.curveSegments,
            steps: controls.steps,
          }

          shape = createMesh(new THREE.ExtrudeGeometry(drawShape(), options))
          // add it to the scene.
          scene.add(shape)
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "amount", 0, 20).onChange(controls.asGeom)
      gui.add(controls, "bevelThickness", 0, 10).onChange(controls.asGeom)
      gui.add(controls, "bevelSize", 0, 10).onChange(controls.asGeom)
      gui
        .add(controls, "bevelSegments", 0, 30)
        .step(1)
        .onChange(controls.asGeom)
      gui.add(controls, "bevelEnabled").onChange(controls.asGeom)
      gui
        .add(controls, "curveSegments", 1, 30)
        .step(1)
        .onChange(controls.asGeom)
      gui.add(controls, "steps", 1, 5).step(1).onChange(controls.asGeom)

      controls.asGeom()
      render()

      function drawShape() {
        // create a basic shape
        var shape = new THREE.Shape()

        // startpoint
        shape.moveTo(10, 10)

        // straight line upwards
        shape.lineTo(10, 40)

        // the top of the figure, curve to the right
        shape.bezierCurveTo(15, 25, 25, 25, 30, 40)

        // spline back down
        shape.splineThru([
          new THREE.Vector2(32, 30),
          new THREE.Vector2(28, 20),
          new THREE.Vector2(30, 10),
        ])

        // curve at the bottom
        shape.quadraticCurveTo(20, 15, 10, 10)

        // add 'eye' hole one
        var hole1 = new THREE.Path()
        hole1.absellipse(16, 24, 2, 3, 0, Math.PI * 2, true)
        shape.holes.push(hole1)

        // add 'eye hole 2'
        var hole2 = new THREE.Path()
        hole2.absellipse(23, 24, 2, 3, 0, Math.PI * 2, true)
        shape.holes.push(hole2)

        // add 'mouth'
        var hole3 = new THREE.Path()
        hole3.absarc(20, 16, 2, 0, Math.PI, true)
        shape.holes.push(hole3)

        // return the shape
        return shape
      }

      function createMesh(geom) {
        geom.applyMatrix(new THREE.Matrix4().makeTranslation(-20, 0, 0))

        // assign two materials
        var meshMaterial = new THREE.MeshNormalMaterial({
          shading: THREE.FlatShading,
          transparent: true,
          opacity: 0.7,
        })

        //  meshMaterial.side = THREE.DoubleSide;
        var wireFrameMat = new THREE.MeshBasicMaterial()
        wireFrameMat.wireframe = true

        // create a multimaterial
        var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [
          meshMaterial,
        ])

        return mesh
      }

      function createLine(shape, spaced) {
        if (!spaced) {
          var mesh = new THREE.Line(
            shape.createPointsGeometry(),
            new THREE.LineBasicMaterial({
              color: 0xff3333,
              linewidth: 2,
            })
          )
          return mesh
        } else {
          var mesh = new THREE.Line(
            shape.createSpacedPointsGeometry(20),
            new THREE.LineBasicMaterial({
              color: 0xff3333,
              linewidth: 2,
            })
          )
          return mesh
        }
      }

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        shape.rotation.y = step += 0.01

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 4.挤出管几何

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      // position and point the camera to the center of the scene
      camera.position.x = -30
      camera.position.y = 40
      camera.position.z = 50
      camera.lookAt(new THREE.Vector3(10, 0, 0))

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      // the points group
      var spGroup
      // the mesh
      var tubeMesh

      // setup the control gui
      var controls = new (function () {
        this.numberOfPoints = 5
        this.segments = 64
        this.radius = 1
        this.radiusSegments = 8
        this.closed = false
        this.points = []
        // we need the first child, since it's a multimaterial

        this.newPoints = function () {
          var points = []
          for (var i = 0; i < controls.numberOfPoints; i++) {
            var randomX = -20 + Math.round(Math.random() * 50)
            var randomY = -15 + Math.round(Math.random() * 40)
            var randomZ = -20 + Math.round(Math.random() * 40)

            points.push(new THREE.Vector3(randomX, randomY, randomZ))
          }
          controls.points = points
          controls.redraw()
        }

        this.redraw = function () {
          scene.remove(spGroup)
          scene.remove(tubeMesh)
          generatePoints(
            controls.points,
            controls.segments,
            controls.radius,
            controls.radiusSegments,
            controls.closed
          )
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "newPoints")
      gui
        .add(controls, "numberOfPoints", 2, 15)
        .step(1)
        .onChange(controls.newPoints)
      gui.add(controls, "segments", 0, 200).step(1).onChange(controls.redraw)
      gui.add(controls, "radius", 0, 10).onChange(controls.redraw)
      gui
        .add(controls, "radiusSegments", 0, 100)
        .step(1)
        .onChange(controls.redraw)
      gui.add(controls, "closed").onChange(controls.redraw)

      controls.newPoints()

      render()

      function generatePoints(
        points,
        segments,
        radius,
        radiusSegments,
        closed
      ) {
        // add n random spheres

        spGroup = new THREE.Object3D()
        var material = new THREE.MeshBasicMaterial({
          color: 0xff0000,
          transparent: false,
        })
        points.forEach(function (point) {
          var spGeom = new THREE.SphereGeometry(0.2)
          var spMesh = new THREE.Mesh(spGeom, material)
          spMesh.position.copy(point)
          spGroup.add(spMesh)
        })
        // add the points as a group to the scene
        scene.add(spGroup)

        // use the same points to create a convexgeometry
        var tubeGeometry = new THREE.TubeGeometry(
          new THREE.SplineCurve3(points),
          segments,
          radius,
          radiusSegments,
          closed
        )
        tubeMesh = createMesh(tubeGeometry)
        scene.add(tubeMesh)
      }

      function createMesh(geom) {
        // assign two materials
        //var meshMaterial = new THREE.MeshNormalMaterial();
        var meshMaterial = new THREE.MeshBasicMaterial({
          color: 0x00ff00,
          transparent: true,
          opacity: 0.2,
        })

        var wireFrameMat = new THREE.MeshBasicMaterial()
        wireFrameMat.wireframe = true

        // create a multimaterial
        var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [
          meshMaterial,
          wireFrameMat,
        ])

        return mesh
      }

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        spGroup.rotation.y = step
        tubeMesh.rotation.y = step += 0.01

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 5.挤出 SVG

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      var shape = createMesh(new THREE.ShapeGeometry(drawShape()))
      // add the sphere to the scene
      scene.add(shape)

      // position and point the camera to the center of the scene
      camera.position.x = -80
      camera.position.y = 80
      camera.position.z = 80
      camera.lookAt(new THREE.Vector3(60, -60, 0))

      var spotLight = new THREE.DirectionalLight(0xffffff)
      spotLight.position = new THREE.Vector3(70, 170, 70)
      spotLight.intensity = 0.7

      spotLight.target = shape

      scene.add(spotLight)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      orbit = new THREE.OrbitControls(camera, webGLRenderer.domElement)

      // call the render function
      var step = 0

      // setup the control gui
      var controls = new (function () {
        this.amount = 2
        this.bevelThickness = 2
        this.bevelSize = 0.5
        this.bevelEnabled = true
        this.bevelSegments = 3
        this.bevelEnabled = true
        this.curveSegments = 12
        this.steps = 1

        this.asGeom = function () {
          // remove the old plane
          scene.remove(shape)
          // create a new one

          var options = {
            amount: controls.amount,
            bevelThickness: controls.bevelThickness,
            bevelSize: controls.bevelSize,
            bevelSegments: controls.bevelSegments,
            bevelEnabled: controls.bevelEnabled,
            curveSegments: controls.curveSegments,
            steps: controls.steps,
          }

          shape = createMesh(new THREE.ExtrudeGeometry(drawShape(), options))
          // add it to the scene.
          scene.add(shape)
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "amount", 0, 20).onChange(controls.asGeom)
      gui.add(controls, "bevelThickness", 0, 10).onChange(controls.asGeom)
      gui.add(controls, "bevelSize", 0, 10).onChange(controls.asGeom)
      gui
        .add(controls, "bevelSegments", 0, 30)
        .step(1)
        .onChange(controls.asGeom)
      gui.add(controls, "bevelEnabled").onChange(controls.asGeom)
      gui
        .add(controls, "curveSegments", 1, 30)
        .step(1)
        .onChange(controls.asGeom)
      gui.add(controls, "steps", 1, 5).step(1).onChange(controls.asGeom)

      controls.asGeom()
      render()

      function drawShape() {
        var svgString = document.querySelector("#batman-path").getAttribute("d")

        var shape = transformSVGPathExposed(svgString)

        // return the shape
        return shape
      }

      function createMesh(geom) {
        geom.applyMatrix(new THREE.Matrix4().makeTranslation(-390, -74, 0))

        // assign two materials
        var meshMaterial = new THREE.MeshPhongMaterial({
          color: 0x333333,
          shininess: 100,
          metal: true,
        })
        var mesh = new THREE.Mesh(geom, meshMaterial)
        mesh.scale.x = 0.1
        mesh.scale.y = 0.1

        mesh.rotation.z = Math.PI
        mesh.rotation.x = -1.1
        return mesh
      }

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        shape.rotation.y = step += 0.005

        orbit.update()

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 6.参数几何

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      // position and point the camera to the center of the scene
      camera.position.x = -30
      camera.position.y = 50
      camera.position.z = 50
      camera.lookAt(new THREE.Vector3(10, -20, 0))

      var spotLight = new THREE.DirectionalLight()
      spotLight.position = new THREE.Vector3(-20, 250, -50)
      spotLight.target.position.x = 30
      spotLight.target.position.y = -40
      spotLight.target.position.z = -20
      spotLight.intensity = 0.3

      scene.add(spotLight)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      // setup the control gui
      var controls = new (function () {})()

      var gui = new dat.GUI()

      klein = function (u, v) {
        u *= Math.PI
        v *= 2 * Math.PI

        u = u * 2
        var x, y, z
        if (u < Math.PI) {
          x =
            3 * Math.cos(u) * (1 + Math.sin(u)) +
            2 * (1 - Math.cos(u) / 2) * Math.cos(u) * Math.cos(v)
          z =
            -8 * Math.sin(u) -
            2 * (1 - Math.cos(u) / 2) * Math.sin(u) * Math.cos(v)
        } else {
          x =
            3 * Math.cos(u) * (1 + Math.sin(u)) +
            2 * (1 - Math.cos(u) / 2) * Math.cos(v + Math.PI)
          z = -8 * Math.sin(u)
        }

        y = -2 * (1 - Math.cos(u) / 2) * Math.sin(v)

        return new THREE.Vector3(x, y, z)
      }

      radialWave = function (u, v) {
        var r = 50

        var x = Math.sin(u) * r
        var z = Math.sin(v / 2) * 2 * r
        var y = (Math.sin(u * 4 * Math.PI) + Math.cos(v * 2 * Math.PI)) * 2.8

        return new THREE.Vector3(x, y, z)
      }

      var mesh = createMesh(
        new THREE.ParametricGeometry(radialWave, 120, 120, false)
      )
      scene.add(mesh)

      render()

      function createMesh(geom) {
        geom.applyMatrix(new THREE.Matrix4().makeTranslation(-25, 0, -25))
        // assign two materials
        //            var meshMaterial = new THREE.MeshLambertMaterial({color: 0xff5555});
        //var meshMaterial = new THREE.MeshNormalMaterial();
        var meshMaterial = new THREE.MeshPhongMaterial({
          specular: 0xaaaafff,
          color: 0x3399ff,
          shininess: 40,
          metal: true,
        })
        meshMaterial.side = THREE.DoubleSide
        // create a multimaterial
        var plane = THREE.SceneUtils.createMultiMaterialObject(geom, [
          meshMaterial,
        ])

        return plane
      }

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()
        mesh.rotation.y = step += 0.01
        mesh.rotation.x = step
        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 7.文本几何

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0x000000, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      // position and point the camera to the center of the scene
      camera.position.x = 100
      camera.position.y = 300
      camera.position.z = 600
      camera.lookAt(new THREE.Vector3(400, 0, -300))

      var dirLight = new THREE.DirectionalLight()
      dirLight.position.set(25, 23, 15)
      scene.add(dirLight)

      var dirLight2 = new THREE.DirectionalLight()
      dirLight2.position.set(-25, 23, 15)
      scene.add(dirLight2)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      var text1
      var text2

      var controls = new (function () {
        this.size = 90
        this.height = 90
        this.bevelThickness = 2
        this.bevelSize = 0.5
        this.bevelEnabled = true
        this.bevelSegments = 3
        this.bevelEnabled = true
        this.curveSegments = 12
        this.steps = 1
        this.font = "helvetiker"
        this.weight = "normal"
        //            this.style = "italics";

        this.asGeom = function () {
          // remove the old plane
          scene.remove(text1)
          scene.remove(text2)
          // create a new one

          var options = {
            size: controls.size,
            height: controls.height,
            weight: controls.weight,
            font: controls.font,
            bevelThickness: controls.bevelThickness,
            bevelSize: controls.bevelSize,
            bevelSegments: controls.bevelSegments,
            bevelEnabled: controls.bevelEnabled,
            curveSegments: controls.curveSegments,
            steps: controls.steps,
          }

          console.log(THREE.FontUtils.faces)

          text1 = createMesh(new THREE.TextGeometry("Learning", options))
          text1.position.z = -100
          text1.position.y = 100
          scene.add(text1)

          text2 = createMesh(new THREE.TextGeometry("Three.js", options))
          scene.add(text2)
        }
      })()

      controls.asGeom()

      var gui = new dat.GUI()
      gui.add(controls, "size", 0, 200).onChange(controls.asGeom)
      gui.add(controls, "height", 0, 200).onChange(controls.asGeom)
      gui
        .add(controls, "font", ["bitstream vera sans mono", "helvetiker"])
        .onChange(controls.asGeom)
      gui.add(controls, "bevelThickness", 0, 10).onChange(controls.asGeom)
      gui.add(controls, "bevelSize", 0, 10).onChange(controls.asGeom)
      gui
        .add(controls, "bevelSegments", 0, 30)
        .step(1)
        .onChange(controls.asGeom)
      gui.add(controls, "bevelEnabled").onChange(controls.asGeom)
      gui
        .add(controls, "curveSegments", 1, 30)
        .step(1)
        .onChange(controls.asGeom)
      gui.add(controls, "steps", 1, 5).step(1).onChange(controls.asGeom)

      render()

      function createMesh(geom) {
        // assign two materials
        //            var meshMaterial = new THREE.MeshLambertMaterial({color: 0xff5555});
        //            var meshMaterial = new THREE.MeshNormalMaterial();
        var meshMaterial = new THREE.MeshPhongMaterial({
          specular: 0xffffff,
          color: 0xeeffff,
          shininess: 100,
          metal: true,
        })
        //            meshMaterial.side=THREE.DoubleSide;
        // create a multimaterial
        var plane = THREE.SceneUtils.createMultiMaterialObject(geom, [
          meshMaterial,
        ])

        return plane
      }

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 8.二进制运算

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(0x999999, 1.0)
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      var sphere1 = createMesh(new THREE.SphereGeometry(5, 20, 30))
      sphere1.position.x = -2

      var sphere2 = createMesh(new THREE.SphereGeometry(5, 20, 30))
      sphere2.position.set(3, 0, 0)

      var cube = createMesh(new THREE.BoxGeometry(5, 5, 5))
      cube.position.x = -7

      var result

      // add the sphere to the scene
      scene.add(sphere1)
      scene.add(sphere2)
      scene.add(cube)

      // position and point the camera to the center of the scene
      camera.position.x = 0
      camera.position.y = 20
      camera.position.z = 20
      camera.lookAt(new THREE.Vector3(0, 0, 0))

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      // setup the control gui
      var controls = new (function () {
        this.sphere1PosX = sphere1.position.x
        this.sphere1PosY = sphere1.position.y
        this.sphere1PosZ = sphere1.position.z
        this.sphere1Scale = 1

        this.sphere2PosX = sphere2.position.x
        this.sphere2PosY = sphere2.position.y
        this.sphere2PosZ = sphere2.position.z
        this.sphere2Scale = 1

        this.cubePosX = cube.position.x
        this.cubePosY = cube.position.y
        this.cubePosZ = cube.position.z
        this.scaleX = 1
        this.scaleY = 1
        this.scaleZ = 1

        this.actionCube = "subtract" // add, substract, intersect
        this.actionSphere = "subtract"

        this.showResult = function () {
          redrawResult()
        }

        this.hideWireframes = false
        this.rotateResult = false
      })()

      var gui = new dat.GUI()
      var guiSphere1 = gui.addFolder("Sphere1")
      guiSphere1.add(controls, "sphere1PosX", -15, 15).onChange(function () {
        sphere1.position.set(
          controls.sphere1PosX,
          controls.sphere1PosY,
          controls.sphere1PosZ
        )
      })
      guiSphere1.add(controls, "sphere1PosY", -15, 15).onChange(function () {
        sphere1.position.set(
          controls.sphere1PosX,
          controls.sphere1PosY,
          controls.sphere1PosZ
        )
      })
      guiSphere1.add(controls, "sphere1PosZ", -15, 15).onChange(function () {
        sphere1.position.set(
          controls.sphere1PosX,
          controls.sphere1PosY,
          controls.sphere1PosZ
        )
      })
      guiSphere1.add(controls, "sphere1Scale", 0, 10).onChange(function (e) {
        sphere1.scale.set(e, e, e)
      })

      var guiSphere2 = gui.addFolder("Sphere2")
      guiSphere2.add(controls, "sphere2PosX", -15, 15).onChange(function () {
        sphere2.position.set(
          controls.sphere2PosX,
          controls.sphere2PosY,
          controls.sphere2PosZ
        )
      })
      guiSphere2.add(controls, "sphere2PosY", -15, 15).onChange(function () {
        sphere2.position.set(
          controls.sphere2PosX,
          controls.sphere2PosY,
          controls.sphere2PosZ
        )
      })
      guiSphere2.add(controls, "sphere2PosZ", -15, 15).onChange(function () {
        sphere2.position.set(
          controls.sphere2PosX,
          controls.sphere2PosY,
          controls.sphere2PosZ
        )
      })
      guiSphere2.add(controls, "sphere2Scale", 0, 10).onChange(function (e) {
        sphere2.scale.set(e, e, e)
      })
      guiSphere2.add(controls, "actionSphere", [
        "subtract",
        "intersect",
        "union",
        "none",
      ])

      var guiCube = gui.addFolder("cube")
      guiCube.add(controls, "cubePosX", -15, 15).onChange(function () {
        cube.position.set(
          controls.cubePosX,
          controls.cubePosY,
          controls.cubePosZ
        )
      })
      guiCube.add(controls, "cubePosY", -15, 15).onChange(function () {
        cube.position.set(
          controls.cubePosX,
          controls.cubePosY,
          controls.cubePosZ
        )
      })
      guiCube.add(controls, "cubePosZ", -15, 15).onChange(function () {
        cube.position.set(
          controls.cubePosX,
          controls.cubePosY,
          controls.cubePosZ
        )
      })
      guiCube.add(controls, "scaleX", 0, 10).onChange(function (e) {
        cube.scale.x = e
      })
      guiCube.add(controls, "scaleY", 0, 10).onChange(function (e) {
        cube.scale.y = e
      })
      guiCube.add(controls, "scaleZ", 0, 10).onChange(function (e) {
        cube.scale.z = e
      })
      guiCube.add(controls, "actionCube", [
        "subtract",
        "intersect",
        "union",
        "none",
      ])

      gui.add(controls, "showResult")
      gui.add(controls, "rotateResult")
      gui.add(controls, "hideWireframes").onChange(function () {
        if (controls.hideWireframes) {
          sphere1.material.visible = false
          sphere2.material.visible = false
          cube.material.visible = false
        } else {
          sphere1.material.visible = true
          sphere2.material.visible = true
          cube.material.visible = true
        }
      })

      render()

      var spinner

      function redrawResult() {
        showSpinner()

        // make the call async to avoid blocking the thread. Need
        // to set timeout > 1, if not executed immediately.
        setTimeout(function () {
          scene.remove(result)
          var sphere1BSP = new ThreeBSP(sphere1)
          var sphere2BSP = new ThreeBSP(sphere2)
          var cube2BSP = new ThreeBSP(cube)

          var resultBSP

          // first do the sphere
          switch (controls.actionSphere) {
            case "subtract":
              resultBSP = sphere1BSP.subtract(sphere2BSP)
              break
            case "intersect":
              resultBSP = sphere1BSP.intersect(sphere2BSP)
              break
            case "union":
              resultBSP = sphere1BSP.union(sphere2BSP)
              break
            case "none": // noop;
          }

          // next do the cube
          if (!resultBSP) resultBSP = sphere1BSP
          switch (controls.actionCube) {
            case "subtract":
              resultBSP = resultBSP.subtract(cube2BSP)
              break
            case "intersect":
              resultBSP = resultBSP.intersect(cube2BSP)
              break
            case "union":
              resultBSP = resultBSP.union(cube2BSP)
              break
            case "none": // noop;
          }

          if (
            controls.actionCube === "none" &&
            controls.actionSphere === "none"
          ) {
            // do nothing
          } else {
            result = resultBSP.toMesh()
            result.geometry.computeFaceNormals()
            result.geometry.computeVertexNormals()
            scene.add(result)
          }

          hideSpinner(spinner)
        }, 200)
      }

      function createMesh(geom) {
        // assign two materials
        var meshMaterial = new THREE.MeshNormalMaterial()
        meshMaterial.side = THREE.DoubleSide
        var wireFrameMat = new THREE.MeshBasicMaterial({
          transparency: true,
          opacity: 0.5,
          wireframeLinewidth: 0.5,
        })
        wireFrameMat.wireframe = true

        // create a multimaterial
        var mesh = new THREE.Mesh(geom, wireFrameMat)

        return mesh
      }

      function showSpinner() {
        var opts = {
          lines: 13, // The number of lines to draw
          length: 20, // The length of each line
          width: 10, // The line thickness
          radius: 30, // The radius of the inner circle
          corners: 1, // Corner roundness (0..1)
          rotate: 0, // The rotation offset
          direction: 1, // 1: clockwise, -1: counterclockwise
          color: "#000", // #rgb or #rrggbb or array of colors
          speed: 1, // Rounds per second
          trail: 60, // Afterglow percentage
          shadow: false, // Whether to render a shadow
          hwaccel: false, // Whether to use hardware acceleration
          className: "spinner", // The CSS class to assign to the spinner
          zIndex: 2e9, // The z-index (defaults to 2000000000)
          top: "auto", // Top position relative to parent in px
          left: "auto", // Left position relative to parent in px
        }
        var target = this.$refs.example
        spinner = new Spinner(opts).spin(target)
        return spinner
      }

      function hideSpinner(spinner) {
        spinner.stop()
      }

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        //            sphere.rotation.y=step+=0.01;

        //            if (typeof  ThreeBSP!='undefined') {console.log(ThreeBSP)};
        //            console.log(ThreeBSP);

        if (controls.rotateResult && result) {
          result.rotation.y += 0.04
          //      result.rotation.x+=0.04;
          result.rotation.z -= 0.005
        }

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::
