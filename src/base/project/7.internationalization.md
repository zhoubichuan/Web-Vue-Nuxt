---
lang: zh-CN
sidebarDepth: 0
meta:
  - name: description
    content: 个人总结的vuepress学习技术文档-主题
  - name: keywords
    content: vuepress,最新技术文档,vuepress主题
---

# 七.粒子

## 1.画布渲染器

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    // 对象
    geometry() {},
    // 材质
    material() {},
    // 模型
    model() {},
    // 场景
    scene({ model }) {},
    // 相机
    camera() {},
    // 渲染器
    render() {},
    // 挂载
    element(dom) {
      this.$refs.example.appendChild(dom)
    },
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      //        var canvasRenderer = new THREE.CanvasRenderer();
      var canvasRenderer = new THREE.WebGLRenderer()
      canvasRenderer.setClearColor(new THREE.Color(0x000000, 1.0))
      canvasRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)

      // position and point the camera to the center of the scene
      camera.position.x = 0
      camera.position.y = 0
      camera.position.z = 150

      // add the output of the renderer to the html element

      this.$refs.example.appendChild(canvasRenderer.domElement)

      createSprites()
      render()

      function createSprites() {
        var material = new THREE.SpriteMaterial()

        for (var x = -5; x < 5; x++) {
          for (var y = -5; y < 5; y++) {
            var sprite = new THREE.Sprite(material)
            sprite.position.set(x * 10, y * 10, 0)
            scene.add(sprite)
          }
        }
      }

      function render() {
        stats.update()

        requestAnimationFrame(render)
        canvasRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 2.WebGL 渲染器

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0x000000, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)

      // position and point the camera to the center of the scene
      camera.position.x = 0
      camera.position.y = 0
      camera.position.z = 150

      // add the output of the renderer to the html element

      this.$refs.example.appendChild(webGLRenderer.domElement)

      createParticles()
      render()

      function createParticles() {
        var geom = new THREE.Geometry()
        var material = new THREE.PointCloudMaterial({
          size: 4,
          vertexColors: true,
          color: 0xffffff,
        })

        for (var x = -5; x < 5; x++) {
          for (var y = -5; y < 5; y++) {
            var particle = new THREE.Vector3(x * 10, y * 10, 0)
            geom.vertices.push(particle)
            geom.colors.push(new THREE.Color(Math.random() * 0x00ffff))
          }
        }

        var cloud = new THREE.PointCloud(geom, material)
        scene.add(cloud)
      }

      function render() {
        stats.update()

        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 3.基本材料

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    // 对象
    geometry() {},
    // 材质
    material() {},
    // 模型
    model() {},
    // 场景
    scene({ model }) {},
    // 相机
    camera() {},
    // 渲染器
    render() {},
    // 挂载
    element(dom) {
      this.$refs.example.appendChild(dom)
    },
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0x000000, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)

      // position and point the camera to the center of the scene
      camera.position.x = 20
      camera.position.y = 0
      camera.position.z = 150

      // add the output of the renderer to the html element

      this.$refs.example.appendChild(webGLRenderer.domElement)

      var cloud

      var controls = new (function () {
        this.size = 4
        this.transparent = true
        this.opacity = 0.6
        this.vertexColors = true
        this.color = 0xffffff
        this.sizeAttenuation = true
        this.rotateSystem = true

        this.redraw = function () {
          if (scene.getObjectByName("particles")) {
            scene.remove(scene.getObjectByName("particles"))
          }
          createParticles(
            controls.size,
            controls.transparent,
            controls.opacity,
            controls.vertexColors,
            controls.sizeAttenuation,
            controls.color
          )
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "size", 0, 10).onChange(controls.redraw)
      gui.add(controls, "transparent").onChange(controls.redraw)
      gui.add(controls, "opacity", 0, 1).onChange(controls.redraw)
      gui.add(controls, "vertexColors").onChange(controls.redraw)
      gui.addColor(controls, "color").onChange(controls.redraw)
      gui.add(controls, "sizeAttenuation").onChange(controls.redraw)
      gui.add(controls, "rotateSystem")

      controls.redraw()
      render()

      function createParticles(
        size,
        transparent,
        opacity,
        vertexColors,
        sizeAttenuation,
        color
      ) {
        var geom = new THREE.Geometry()
        var material = new THREE.PointCloudMaterial({
          size: size,
          transparent: transparent,
          opacity: opacity,
          vertexColors: vertexColors,

          sizeAttenuation: sizeAttenuation,
          color: color,
        })

        var range = 500
        for (var i = 0; i < 15000; i++) {
          var particle = new THREE.Vector3(
            Math.random() * range - range / 2,
            Math.random() * range - range / 2,
            Math.random() * range - range / 2
          )
          geom.vertices.push(particle)
          var color = new THREE.Color(0x00ff00)
          color.setHSL(
            color.getHSL().h,
            color.getHSL().s,
            Math.random() * color.getHSL().l
          )
          geom.colors.push(color)
        }

        cloud = new THREE.PointCloud(geom, material)
        cloud.name = "particles"
        scene.add(cloud)
      }

      var step = 0

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        if (controls.rotateSystem) {
          step += 0.01

          cloud.rotation.x = step
          cloud.rotation.z = step
        }

        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 4.基于画布的纹理

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    // 对象
    geometry() {},
    // 材质
    material() {},
    // 模型
    model() {},
    // 场景
    scene({ model }) {},
    // 相机
    camera() {},
    // 渲染器
    render() {},
    // 挂载
    element(dom) {
      this.$refs.example.appendChild(dom)
    },
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var canvasRenderer = new THREE.CanvasRenderer()
      //        var canvasRenderer = new THREE.WebGLRenderer();

      canvasRenderer.setClearColor(new THREE.Color(0x000000, 1.0))
      canvasRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)

      // position and point the camera to the center of the scene
      camera.position.x = 20
      camera.position.y = 0
      camera.position.z = 150

      // add the output of the renderer to the html element

      this.$refs.example.appendChild(canvasRenderer.domElement)

      var getTexture = function (ctx) {
        // the body
        ctx.translate(-81, -84)

        ctx.fillStyle = "orange"
        ctx.beginPath()
        ctx.moveTo(83, 116)
        ctx.lineTo(83, 102)
        ctx.bezierCurveTo(83, 94, 89, 88, 97, 88)
        ctx.bezierCurveTo(105, 88, 111, 94, 111, 102)
        ctx.lineTo(111, 116)
        ctx.lineTo(106.333, 111.333)
        ctx.lineTo(101.666, 116)
        ctx.lineTo(97, 111.333)
        ctx.lineTo(92.333, 116)
        ctx.lineTo(87.666, 111.333)
        ctx.lineTo(83, 116)
        ctx.fill()

        // the eyes
        ctx.fillStyle = "white"
        ctx.beginPath()
        ctx.moveTo(91, 96)
        ctx.bezierCurveTo(88, 96, 87, 99, 87, 101)
        ctx.bezierCurveTo(87, 103, 88, 106, 91, 106)
        ctx.bezierCurveTo(94, 106, 95, 103, 95, 101)
        ctx.bezierCurveTo(95, 99, 94, 96, 91, 96)
        ctx.moveTo(103, 96)
        ctx.bezierCurveTo(100, 96, 99, 99, 99, 101)
        ctx.bezierCurveTo(99, 103, 100, 106, 103, 106)
        ctx.bezierCurveTo(106, 106, 107, 103, 107, 101)
        ctx.bezierCurveTo(107, 99, 106, 96, 103, 96)
        ctx.fill()

        // the pupils
        ctx.fillStyle = "blue"
        ctx.beginPath()
        ctx.arc(101, 102, 2, 0, Math.PI * 2, true)
        ctx.fill()
        ctx.beginPath()
        ctx.arc(89, 102, 2, 0, Math.PI * 2, true)
        ctx.fill()
      }

      createSprites()
      render()

      function createSprites() {
        var material = new THREE.SpriteCanvasMaterial({
          program: getTexture,
          color: 0xffffff,
        })

        material.rotation = Math.PI

        var range = 500
        for (var i = 0; i < 1500; i++) {
          var sprite = new THREE.Sprite(material)
          sprite.position.set(
            Math.random() * range - range / 2,
            Math.random() * range - range / 2,
            Math.random() * range - range / 2
          )
          sprite.scale.set(0.1, 0.1, 0.1)
          scene.add(sprite)
        }
      }

      var step = 0

      function render() {
        stats.update()

        requestAnimationFrame(render)
        canvasRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 5.基于画布的纹理-WebGL

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    // 对象
    geometry() {},
    // 材质
    material() {},
    // 模型
    model() {},
    // 场景
    scene({ model }) {},
    // 相机
    camera() {},
    // 渲染器
    render() {},
    // 挂载
    element(dom) {
      this.$refs.example.appendChild(dom)
    },
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0x000000, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)

      // position and point the camera to the center of the scene
      camera.position.x = 20
      camera.position.y = 0
      camera.position.z = 150

      // add the output of the renderer to the html element

      this.$refs.example.appendChild(webGLRenderer.domElement)

      var getTexture = function () {
        var canvas = document.createElement("canvas")
        canvas.width = 32
        canvas.height = 32

        var ctx = canvas.getContext("2d")
        // the body
        ctx.translate(-81, -84)

        ctx.fillStyle = "orange"
        ctx.beginPath()
        ctx.moveTo(83, 116)
        ctx.lineTo(83, 102)
        ctx.bezierCurveTo(83, 94, 89, 88, 97, 88)
        ctx.bezierCurveTo(105, 88, 111, 94, 111, 102)
        ctx.lineTo(111, 116)
        ctx.lineTo(106.333, 111.333)
        ctx.lineTo(101.666, 116)
        ctx.lineTo(97, 111.333)
        ctx.lineTo(92.333, 116)
        ctx.lineTo(87.666, 111.333)
        ctx.lineTo(83, 116)
        ctx.fill()

        // the eyes
        ctx.fillStyle = "white"
        ctx.beginPath()
        ctx.moveTo(91, 96)
        ctx.bezierCurveTo(88, 96, 87, 99, 87, 101)
        ctx.bezierCurveTo(87, 103, 88, 106, 91, 106)
        ctx.bezierCurveTo(94, 106, 95, 103, 95, 101)
        ctx.bezierCurveTo(95, 99, 94, 96, 91, 96)
        ctx.moveTo(103, 96)
        ctx.bezierCurveTo(100, 96, 99, 99, 99, 101)
        ctx.bezierCurveTo(99, 103, 100, 106, 103, 106)
        ctx.bezierCurveTo(106, 106, 107, 103, 107, 101)
        ctx.bezierCurveTo(107, 99, 106, 96, 103, 96)
        ctx.fill()

        // the pupils
        ctx.fillStyle = "blue"
        ctx.beginPath()
        ctx.arc(101, 102, 2, 0, Math.PI * 2, true)
        ctx.fill()
        ctx.beginPath()
        ctx.arc(89, 102, 2, 0, Math.PI * 2, true)
        ctx.fill()

        var texture = new THREE.Texture(canvas)
        texture.needsUpdate = true
        return texture
      }

      var cloud

      var controls = new (function () {
        this.size = 15
        this.transparent = true
        this.opacity = 0.6
        this.color = 0xffffff
        this.rotateSystem = true
        this.sizeAttenuation = true

        this.redraw = function () {
          if (scene.getObjectByName("pointcloud")) {
            scene.remove(scene.getObjectByName("pointcloud"))
          }
          createPointCloud(
            controls.size,
            controls.transparent,
            controls.opacity,
            controls.sizeAttenuation,
            controls.color
          )
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "size", 0, 20).onChange(controls.redraw)
      gui.add(controls, "transparent").onChange(controls.redraw)
      gui.add(controls, "opacity", 0, 1).onChange(controls.redraw)
      gui.addColor(controls, "color").onChange(controls.redraw)
      gui.add(controls, "sizeAttenuation").onChange(controls.redraw)

      gui.add(controls, "rotateSystem")

      controls.redraw()

      render()

      function createPointCloud(
        size,
        transparent,
        opacity,
        sizeAttenuation,
        color
      ) {
        var geom = new THREE.Geometry()

        var material = new THREE.PointCloudMaterial({
          size: size,
          transparent: transparent,
          opacity: opacity,
          map: getTexture(),
          sizeAttenuation: sizeAttenuation,
          color: color,
        })

        var range = 500
        for (var i = 0; i < 5000; i++) {
          var particle = new THREE.Vector3(
            Math.random() * range - range / 2,
            Math.random() * range - range / 2,
            Math.random() * range - range / 2
          )
          geom.vertices.push(particle)
        }

        cloud = new THREE.PointCloud(geom, material)
        cloud.name = "pointcloud"
        cloud.sortParticles = true
        scene.add(cloud)
      }

      var step = 0

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()
        if (controls.rotateSystem) {
          step += 0.01

          cloud.rotation.x = step
          cloud.rotation.z = step
        }

        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 6.基于画布的纹理

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    // 对象
    geometry() {},
    // 材质
    material() {},
    // 模型
    model() {},
    // 场景
    scene({ model }) {},
    // 相机
    camera() {},
    // 渲染器
    render() {},
    // 挂载
    element(dom) {
      this.$refs.example.appendChild(dom)
    },
    init() {
      var stats = this.initStats()
      var scene = new THREE.Scene()
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )
      var canvasRenderer = new THREE.WebGLRenderer()
      canvasRenderer.setClearColor(new THREE.Color(0x000000, 1.0))
      canvasRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      camera.position.x = 20
      camera.position.y = 0
      camera.position.z = 150
      this.$refs.example.appendChild(canvasRenderer.domElement)
      var getTexture = function () {
        var canvas = document.createElement("canvas")
        canvas.width = 32
        canvas.height = 32
        var ctx = canvas.getContext("2d")
        ctx.translate(-81, -84)
        ctx.fillStyle = "orange"
        ctx.beginPath()
        ctx.moveTo(83, 116)
        ctx.lineTo(83, 102)
        ctx.bezierCurveTo(83, 94, 89, 88, 97, 88)
        ctx.bezierCurveTo(105, 88, 111, 94, 111, 102)
        ctx.lineTo(111, 116)
        ctx.lineTo(106.333, 111.333)
        ctx.lineTo(101.666, 116)
        ctx.lineTo(97, 111.333)
        ctx.lineTo(92.333, 116)
        ctx.lineTo(87.666, 111.333)
        ctx.lineTo(83, 116)
        ctx.fill()
        ctx.fillStyle = "white"
        ctx.beginPath()
        ctx.moveTo(91, 96)
        ctx.bezierCurveTo(88, 96, 87, 99, 87, 101)
        ctx.bezierCurveTo(87, 103, 88, 106, 91, 106)
        ctx.bezierCurveTo(94, 106, 95, 103, 95, 101)
        ctx.bezierCurveTo(95, 99, 94, 96, 91, 96)
        ctx.moveTo(103, 96)
        ctx.bezierCurveTo(100, 96, 99, 99, 99, 101)
        ctx.bezierCurveTo(99, 103, 100, 106, 103, 106)
        ctx.bezierCurveTo(106, 106, 107, 103, 107, 101)
        ctx.bezierCurveTo(107, 99, 106, 96, 103, 96)
        ctx.fill()
        ctx.fillStyle = "blue"
        ctx.beginPath()
        ctx.arc(101, 102, 2, 0, Math.PI * 2, true)
        ctx.fill()
        ctx.beginPath()
        ctx.arc(89, 102, 2, 0, Math.PI * 2, true)
        ctx.fill()
        var texture = new THREE.Texture(canvas)
        texture.needsUpdate = true
        return texture
      }
      createSprites()
      render()
      function createSprites() {
        var material = new THREE.SpriteMaterial({
          map: getTexture(),
          color: 0xffffff,
        })
        var range = 500
        for (var i = 0; i < 1500; i++) {
          var sprite = new THREE.Sprite(material)
          sprite.position.set(
            Math.random() * range - range / 2,
            Math.random() * range - range / 2,
            Math.random() * range - range / 2
          )
          sprite.scale.set(4, 4, 4)
          scene.add(sprite)
        }
      }
      var step = 0
      function render() {
        stats.update()
        requestAnimationFrame(render)
        canvasRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)
      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 7.雨景

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    // 对象
    geometry() {},
    // 材质
    material() {},
    // 模型
    model() {},
    // 场景
    scene({ model }) {},
    // 相机
    camera() {},
    // 渲染器
    render() {},
    // 挂载
    element(dom) {
      this.$refs.example.appendChild(dom)
    },
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        200
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0x000000, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)

      // position and point the camera to the center of the scene
      camera.position.x = 20
      camera.position.y = 40
      camera.position.z = 110
      camera.lookAt(new THREE.Vector3(20, 30, 0))

      // add the output of the renderer to the html element

      this.$refs.example.appendChild(webGLRenderer.domElement)

      var system1
      var cloud
      var png = this.$withBase("/assets/textures/particles/raindrop-3.png")
      var controls = new (function () {
        this.size = 3
        this.transparent = true
        this.opacity = 0.6
        this.color = 0xffffff

        this.sizeAttenuation = true

        this.redraw = function () {
          scene.remove(scene.getObjectByName("particles1"))
          scene.remove(scene.getObjectByName("particles2"))

          createPointCloud(
            controls.size,
            controls.transparent,
            controls.opacity,
            controls.sizeAttenuation,
            controls.color,
            png
          )
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "size", 0, 20).onChange(controls.redraw)
      gui.add(controls, "transparent").onChange(controls.redraw)
      gui.add(controls, "opacity", 0, 1).onChange(controls.redraw)
      gui.addColor(controls, "color").onChange(controls.redraw)
      gui.add(controls, "sizeAttenuation").onChange(controls.redraw)

      controls.redraw()

      render()
      function createPointCloud(
        size,
        transparent,
        opacity,
        sizeAttenuation,
        color,
        png
      ) {
        var texture = THREE.ImageUtils.loadTexture(png)
        var geom = new THREE.Geometry()

        var material = new THREE.ParticleBasicMaterial({
          size: size,
          transparent: transparent,
          opacity: opacity,
          map: texture,
          blending: THREE.AdditiveBlending,
          sizeAttenuation: sizeAttenuation,
          color: color,
        })

        var range = 40
        for (var i = 0; i < 1500; i++) {
          var particle = new THREE.Vector3(
            Math.random() * range - range / 2,
            Math.random() * range * 1.5,
            Math.random() * range - range / 2
          )
          particle.velocityY = 0.1 + Math.random() / 5
          particle.velocityX = (Math.random() - 0.5) / 3
          geom.vertices.push(particle)
        }

        cloud = new THREE.ParticleSystem(geom, material)
        cloud.sortParticles = true

        scene.add(cloud)
      }

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()
        var vertices = cloud.geometry.vertices
        vertices.forEach(function (v) {
          v.y = v.y - v.velocityY
          v.x = v.x - v.velocityX

          if (v.y <= 0) v.y = 60
          if (v.x <= -20 || v.x >= 20) v.velocityX = v.velocityX * -1
        })

        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 8.雪景

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    // 对象
    geometry() {},
    // 材质
    material() {},
    // 模型
    model() {},
    // 场景
    scene({ model }) {},
    // 相机
    camera() {},
    // 渲染器
    render() {},
    // 挂载
    element(dom) {
      this.$refs.example.appendChild(dom)
    },
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        200
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0x000000, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)

      // position and point the camera to the center of the scene
      camera.position.x = 20
      camera.position.y = 40
      camera.position.z = 110
      camera.lookAt(new THREE.Vector3(20, 30, 0))

      // add the output of the renderer to the html element

      this.$refs.example.appendChild(webGLRenderer.domElement)

      var system1
      var system2
      var img = [
        this.$withBase("/assets/textures/particles/snowflake1.png"),
        this.$withBase("/assets/textures/particles/snowflake2.png"),
        this.$withBase("/assets/textures/particles/snowflake3.png"),
        this.$withBase("/assets/textures/particles/snowflake5.png"),
      ]
      var controls = new (function () {
        this.size = 10
        this.transparent = true
        this.opacity = 0.6
        this.color = 0xffffff

        this.sizeAttenuation = true

        this.redraw = function () {
          var toRemove = []
          scene.children.forEach(function (child) {
            if (child instanceof THREE.PointCloud) {
              toRemove.push(child)
            }
          })
          toRemove.forEach(function (child) {
            scene.remove(child)
          })
          createPointClouds(
            controls.size,
            controls.transparent,
            controls.opacity,
            controls.sizeAttenuation,
            controls.color,
            img
          )
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "size", 0, 20).onChange(controls.redraw)
      gui.add(controls, "transparent").onChange(controls.redraw)
      gui.add(controls, "opacity", 0, 1).onChange(controls.redraw)
      gui.addColor(controls, "color").onChange(controls.redraw)
      gui.add(controls, "sizeAttenuation").onChange(controls.redraw)

      controls.redraw()

      render()

      function createPointCloud(
        name,
        texture,
        size,
        transparent,
        opacity,
        sizeAttenuation,
        color
      ) {
        var geom = new THREE.Geometry()

        var color = new THREE.Color(color)
        color.setHSL(
          color.getHSL().h,
          color.getHSL().s,
          Math.random() * color.getHSL().l
        )

        var material = new THREE.PointCloudMaterial({
          size: size,
          transparent: transparent,
          opacity: opacity,
          map: texture,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          sizeAttenuation: sizeAttenuation,
          color: color,
        })

        var range = 40
        for (var i = 0; i < 50; i++) {
          var particle = new THREE.Vector3(
            Math.random() * range - range / 2,
            Math.random() * range * 1.5,
            Math.random() * range - range / 2
          )
          particle.velocityY = 0.1 + Math.random() / 5
          particle.velocityX = (Math.random() - 0.5) / 3
          particle.velocityZ = (Math.random() - 0.5) / 3
          geom.vertices.push(particle)
        }

        var system = new THREE.PointCloud(geom, material)
        system.name = name
        system.sortParticles = true
        return system
      }
      function createPointClouds(
        size,
        transparent,
        opacity,
        sizeAttenuation,
        color,
        img
      ) {
        var texture1 = THREE.ImageUtils.loadTexture(img[0])
        var texture2 = THREE.ImageUtils.loadTexture(img[1])
        var texture3 = THREE.ImageUtils.loadTexture(img[2])
        var texture4 = THREE.ImageUtils.loadTexture(img[3])

        scene.add(
          createPointCloud(
            "system1",
            texture1,
            size,
            transparent,
            opacity,
            sizeAttenuation,
            color
          )
        )
        scene.add(
          createPointCloud(
            "system2",
            texture2,
            size,
            transparent,
            opacity,
            sizeAttenuation,
            color
          )
        )
        scene.add(
          createPointCloud(
            "system3",
            texture3,
            size,
            transparent,
            opacity,
            sizeAttenuation,
            color
          )
        )
        scene.add(
          createPointCloud(
            "system4",
            texture4,
            size,
            transparent,
            opacity,
            sizeAttenuation,
            color
          )
        )
      }

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        scene.children.forEach(function (child) {
          if (child instanceof THREE.PointCloud) {
            var vertices = child.geometry.vertices
            vertices.forEach(function (v) {
              v.y = v.y - v.velocityY
              v.x = v.x - v.velocityX
              v.z = v.z - v.velocityZ

              if (v.y <= 0) v.y = 60
              if (v.x <= -20 || v.x >= 20) v.velocityX = v.velocityX * -1
              if (v.z <= -20 || v.z >= 20) v.velocityZ = v.velocityZ * -1
            })
          }
        })

        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 9.精灵

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    // 对象
    geometry() {},
    // 材质
    material() {},
    // 模型
    model() {},
    // 场景
    scene({ model }) {},
    // 相机
    camera() {},
    // 渲染器
    render() {},
    // 挂载
    element(dom) {
      this.$refs.example.appendChild(dom)
    },
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()
      var sceneOrtho = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        250
      )
      var cameraOrtho = new THREE.OrthographicCamera(
        0,
        window.innerWidth,
        window.innerHeight,
        0,
        -10,
        10
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0x000000, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)

      // position and point the camera to the center of the scene
      camera.position.x = 0
      camera.position.y = 0
      camera.position.z = 50

      // add the output of the renderer to the html element

      this.$refs.example.appendChild(webGLRenderer.domElement)

      var material = new THREE.MeshNormalMaterial()
      var geom = new THREE.SphereGeometry(15, 20, 20)
      var mesh = new THREE.Mesh(geom, material)

      scene.add(mesh)
      var that = this
      var getTexture = function () {
        var texture = new THREE.ImageUtils.loadTexture(
          that.$withBase("/assets/textures/particles/sprite-sheet.png")
        )
        return texture
      }

      var controls = new (function () {
        this.size = 150
        this.sprite = 0
        this.transparent = true
        this.opacity = 0.6
        this.color = 0xffffff
        this.rotateSystem = true

        this.redraw = function () {
          sceneOrtho.children.forEach(function (child) {
            if (child instanceof THREE.Sprite) sceneOrtho.remove(child)
          })
          createSprite(
            controls.size,
            controls.transparent,
            controls.opacity,
            controls.color,
            controls.sprite
          )
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "sprite", 0, 4).step(1).onChange(controls.redraw)
      gui.add(controls, "size", 0, 120).onChange(controls.redraw)
      gui.add(controls, "transparent").onChange(controls.redraw)
      gui.add(controls, "opacity", 0, 1).onChange(controls.redraw)
      gui.addColor(controls, "color").onChange(controls.redraw)

      controls.redraw()

      render()

      function createSprite(size, transparent, opacity, color, spriteNumber) {
        var spriteMaterial = new THREE.SpriteMaterial({
          opacity: opacity,
          color: color,
          transparent: transparent,
          map: getTexture(),
        })

        // we have 1 row, with five sprites
        spriteMaterial.map.offset = new THREE.Vector2(0.2 * spriteNumber, 0)
        spriteMaterial.map.repeat = new THREE.Vector2(1 / 5, 1)
        spriteMaterial.depthTest = false

        spriteMaterial.blending = THREE.AdditiveBlending

        var sprite = new THREE.Sprite(spriteMaterial)
        sprite.scale.set(size, size, size)
        sprite.position.set(100, 50, -10)
        sprite.velocityX = 5

        sceneOrtho.add(sprite)
      }

      var step = 0

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        camera.position.y = Math.sin((step += 0.01)) * 20

        sceneOrtho.children.forEach(function (e) {
          if (e instanceof THREE.Sprite) {
            // move the sprite along the bottom
            e.position.x = e.position.x + e.velocityX
            if (e.position.x > window.innerWidth) {
              e.velocityX = -5
              e.material.map.offset.set((1 / 5) * (controls.sprite % 4), 0)
            }
            if (e.position.x < 0) {
              e.velocityX = 5
            }
          }
        })

        requestAnimationFrame(render)

        webGLRenderer.render(scene, camera)
        webGLRenderer.autoClear = false
        webGLRenderer.render(sceneOrtho, cameraOrtho)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 10.3D 精灵

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    // 对象
    geometry() {},
    // 材质
    material() {},
    // 模型
    model() {},
    // 场景
    scene({ model }) {},
    // 相机
    camera() {},
    // 渲染器
    render() {},
    // 挂载
    element(dom) {
      this.$refs.example.appendChild(dom)
    },
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0x000000, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)

      // position and point the camera to the center of the scene
      camera.position.x = 20
      camera.position.y = 0
      camera.position.z = 150

      // add the output of the renderer to the html element

      this.$refs.example.appendChild(webGLRenderer.domElement)

      createSprites()
      render()

      var group

      function createSprites() {
        group = new THREE.Object3D()
        var range = 200
        for (var i = 0; i < 400; i++) {
          group.add(createSprite(10, false, 0.6, 0xffffff, i % 5, range))
        }
        scene.add(group)
      }
      var png = this.$withBase("/assets/textures/particles/sprite-sheet.png")
      function getTexture(png) {
        var texture = new THREE.ImageUtils.loadTexture(png)
        return texture
      }

      function createSprite(
        size,
        transparent,
        opacity,
        color,
        spriteNumber,
        range
      ) {
        var spriteMaterial = new THREE.SpriteMaterial({
          opacity: opacity,
          color: color,
          transparent: transparent,
          map: getTexture(png),
        })

        // we have 1 row, with five sprites
        spriteMaterial.map.offset = new THREE.Vector2(0.2 * spriteNumber, 0)
        spriteMaterial.map.repeat = new THREE.Vector2(1 / 5, 1)
        spriteMaterial.depthTest = false

        spriteMaterial.blending = THREE.AdditiveBlending

        var sprite = new THREE.Sprite(spriteMaterial)
        sprite.scale.set(size, size, size)
        sprite.position.set(
          Math.random() * range - range / 2,
          Math.random() * range - range / 2,
          Math.random() * range - range / 2
        )
        sprite.velocityX = 5

        return sprite
      }

      var step = 0

      function render() {
        stats.update()
        step += 0.01
        group.rotation.x = step

        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 11.3D 圆环结

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    // 对象
    geometry() {},
    // 材质
    material() {},
    // 模型
    model() {},
    // 场景
    scene({ model }) {},
    // 相机
    camera() {},
    // 渲染器
    render() {},
    // 挂载
    element(dom) {
      this.$refs.example.appendChild(dom)
    },
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0x000000, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      // position and point the camera to the center of the scene
      camera.position.x = -30
      camera.position.y = 40
      camera.position.z = 50
      camera.lookAt(new THREE.Vector3(10, 0, 0))

      // add the output of the renderer to the html element

      this.$refs.example.appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      var knot

      // setup the control gui
      var controls = new (function () {
        // we need the first child, since it's a multimaterial
        this.radius = 13
        this.tube = 1.7
        this.radialSegments = 156
        this.tubularSegments = 12
        this.p = 5
        this.q = 4
        this.heightScale = 3.5
        this.asParticles = false
        this.rotate = false

        this.redraw = function () {
          // remove the old plane
          if (knot) scene.remove(knot)
          // create a new one
          var geom = new THREE.TorusKnotGeometry(
            controls.radius,
            controls.tube,
            Math.round(controls.radialSegments),
            Math.round(controls.tubularSegments),
            Math.round(controls.p),
            Math.round(controls.q),
            controls.heightScale
          )

          if (controls.asParticles) {
            knot = createPointCloud(geom)
          } else {
            knot = createMesh(geom)
          }

          // add it to the scene.
          scene.add(knot)
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "radius", 0, 40).onChange(controls.redraw)
      gui.add(controls, "tube", 0, 40).onChange(controls.redraw)
      gui
        .add(controls, "radialSegments", 0, 400)
        .step(1)
        .onChange(controls.redraw)
      gui
        .add(controls, "tubularSegments", 1, 20)
        .step(1)
        .onChange(controls.redraw)
      gui.add(controls, "p", 1, 10).step(1).onChange(controls.redraw)
      gui.add(controls, "q", 1, 15).step(1).onChange(controls.redraw)
      gui.add(controls, "heightScale", 0, 5).onChange(controls.redraw)
      gui.add(controls, "asParticles").onChange(controls.redraw)
      gui.add(controls, "rotate").onChange(controls.redraw)

      controls.redraw()

      render()

      // from THREE.js examples
      function generateSprite() {
        var canvas = document.createElement("canvas")
        canvas.width = 16
        canvas.height = 16

        var context = canvas.getContext("2d")
        var gradient = context.createRadialGradient(
          canvas.width / 2,
          canvas.height / 2,
          0,
          canvas.width / 2,
          canvas.height / 2,
          canvas.width / 2
        )
        gradient.addColorStop(0, "rgba(255,255,255,1)")
        gradient.addColorStop(0.2, "rgba(0,255,255,1)")
        gradient.addColorStop(0.4, "rgba(0,0,64,1)")
        gradient.addColorStop(1, "rgba(0,0,0,1)")

        context.fillStyle = gradient
        context.fillRect(0, 0, canvas.width, canvas.height)

        var texture = new THREE.Texture(canvas)
        texture.needsUpdate = true
        return texture
      }

      function createPointCloud(geom) {
        var material = new THREE.PointCloudMaterial({
          color: 0xffffff,
          size: 3,
          transparent: true,
          blending: THREE.AdditiveBlending,
          map: generateSprite(),
        })

        var cloud = new THREE.PointCloud(geom, material)
        cloud.sortParticles = true
        return cloud
      }

      function createMesh(geom) {
        // assign two materials
        var meshMaterial = new THREE.MeshNormalMaterial({})
        meshMaterial.side = THREE.DoubleSide

        // create a multimaterial
        var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [
          meshMaterial,
        ])

        return mesh
      }

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        if (controls.rotate) {
          knot.rotation.y = step += 0.01
        }

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::
