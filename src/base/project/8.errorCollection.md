---
lang: zh-CN
sidebarDepth: 0
meta:
  - name: description
    content: 个人总结的vuepress学习技术文档-主题
  - name: keywords
    content: vuepress,最新技术文档,vuepress主题
---

# 八.模型

## 1.分组

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      // add the sphere to the scene

      // position and point the camera to the center of the scene
      camera.position.x = 30
      camera.position.y = 30
      camera.position.z = 30
      camera.lookAt(new THREE.Vector3(0, 0, 0))

      var ground = new THREE.PlaneGeometry(100, 100, 50, 50)

      var groundMesh = THREE.SceneUtils.createMultiMaterialObject(ground, [
        new THREE.MeshBasicMaterial({
          wireframe: true,
          overdraw: true,
          color: 0x000000,
        }),
        new THREE.MeshBasicMaterial({
          color: 0x00ff00,
          transparent: true,
          opacity: 0.5,
        }),
      ])
      groundMesh.rotation.x = -0.5 * Math.PI
      scene.add(groundMesh)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0.03

      var sphere
      var cube
      var group
      var bboxMesh

      // setup the control gui
      var controls = new (function () {
        // we need the first child, since it's a multimaterial
        this.cubePosX = 0
        this.cubePosY = 3
        this.cubePosZ = 10

        this.spherePosX = 10
        this.spherePosY = 5
        this.spherePosZ = 0

        this.groupPosX = 10
        this.groupPosY = 5
        this.groupPosZ = 0

        this.grouping = false
        this.rotate = false

        this.groupScale = 1
        this.cubeScale = 1
        this.sphereScale = 1

        this.redraw = function () {
          // remove the old plane
          //scene.remove(sphere);
          //scene.remove(cube);
          scene.remove(group)

          // create a new one
          sphere = createMesh(new THREE.SphereGeometry(5, 10, 10))
          cube = createMesh(new THREE.BoxGeometry(6, 6, 6))

          sphere.position.set(
            controls.spherePosX,
            controls.spherePosY,
            controls.spherePosZ
          )
          cube.position.set(
            controls.cubePosX,
            controls.cubePosY,
            controls.cubePosZ
          )
          // add it to the scene.

          // also create a group, only used for rotating
          group = new THREE.Group()
          group.add(sphere)
          group.add(cube)

          scene.add(group)
          controls.positionBoundingBox()

          var arrow = new THREE.ArrowHelper(
            new THREE.Vector3(0, 1, 0),
            group.position,
            10,
            0x0000ff
          )
          scene.add(arrow)
        }

        this.positionBoundingBox = function () {
          scene.remove(bboxMesh)
          var box = setFromObject(group)
          var width = box.max.x - box.min.x
          var height = box.max.y - box.min.y
          var depth = box.max.z - box.min.z

          var bbox = new THREE.BoxGeometry(width, height, depth)
          bboxMesh = new THREE.Mesh(
            bbox,
            new THREE.MeshBasicMaterial({
              color: 0x000000,
              vertexColors: THREE.VertexColors,
              wireframeLinewidth: 2,
              wireframe: true,
            })
          )
          //            scene.add(bboxMesh);

          bboxMesh.position.x = (box.min.x + box.max.x) / 2
          bboxMesh.position.y = (box.min.y + box.max.y) / 2
          bboxMesh.position.z = (box.min.z + box.max.z) / 2
        }
      })()

      var gui = new dat.GUI()
      var sphereFolder = gui.addFolder("sphere")
      sphereFolder.add(controls, "spherePosX", -20, 20).onChange(function (e) {
        sphere.position.x = e
        controls.positionBoundingBox()
      })
      sphereFolder.add(controls, "spherePosZ", -20, 20).onChange(function (e) {
        sphere.position.z = e
        controls.positionBoundingBox()
      })
      sphereFolder.add(controls, "spherePosY", -20, 20).onChange(function (e) {
        sphere.position.y = e
        controls.positionBoundingBox()
      })
      sphereFolder.add(controls, "sphereScale", 0, 3).onChange(function (e) {
        sphere.scale.set(e, e, e)
        controls.positionBoundingBox()
      })

      var cubeFolder = gui.addFolder("cube")
      cubeFolder.add(controls, "cubePosX", -20, 20).onChange(function (e) {
        cube.position.x = e
        controls.positionBoundingBox()
      })
      cubeFolder.add(controls, "cubePosZ", -20, 20).onChange(function (e) {
        cube.position.z = e
        controls.positionBoundingBox()
      })
      cubeFolder.add(controls, "cubePosY", -20, 20).onChange(function (e) {
        cube.position.y = e
        controls.positionBoundingBox()
      })
      cubeFolder.add(controls, "cubeScale", 0, 3).onChange(function (e) {
        cube.scale.set(e, e, e)
        controls.positionBoundingBox()
      })

      var cubeFolder = gui.addFolder("group")
      cubeFolder.add(controls, "groupPosX", -20, 20).onChange(function (e) {
        group.position.x = e
        controls.positionBoundingBox()
      })
      cubeFolder.add(controls, "groupPosZ", -20, 20).onChange(function (e) {
        group.position.z = e
        controls.positionBoundingBox()
      })
      cubeFolder.add(controls, "groupPosY", -20, 20).onChange(function (e) {
        group.position.y = e
        controls.positionBoundingBox()
      })
      cubeFolder.add(controls, "groupScale", 0, 3).onChange(function (e) {
        group.scale.set(e, e, e)
        controls.positionBoundingBox()
      })

      gui.add(controls, "grouping")
      gui.add(controls, "rotate")
      controls.redraw()
      render()

      function createMesh(geom) {
        // assign two materials
        var meshMaterial = new THREE.MeshNormalMaterial()
        meshMaterial.side = THREE.DoubleSide
        var wireFrameMat = new THREE.MeshBasicMaterial()
        wireFrameMat.wireframe = true

        // create a multimaterial
        var plane = THREE.SceneUtils.createMultiMaterialObject(geom, [
          meshMaterial,
          wireFrameMat,
        ])

        return plane
      }

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        if (controls.grouping && controls.rotate) {
          group.rotation.y += step
        }

        if (controls.rotate && !controls.grouping) {
          sphere.rotation.y += step
          cube.rotation.y += step
        }

        //        controls.positionBoundingBox();
        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
    setFromObject(object) {
      var box = new THREE.Box3()
      var v1 = new THREE.Vector3()
      object.updateMatrixWorld(true)
      box.makeEmpty()
      object.traverse(function (node) {
        if (
          node.geometry !== undefined &&
          node.geometry.vertices !== undefined
        ) {
          var vertices = node.geometry.vertices
          for (var i = 0, il = vertices.length; i < il; i++) {
            v1.copy(vertices[i])
            v1.applyMatrix4(node.matrixWorld)
            box.expandByPoint(v1)
          }
        }
      })
      return box
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 2.合并对象

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        1,
        500
      )

      // create a render and set the size
      var renderer = new THREE.WebGLRenderer()

      renderer.setClearColor(new THREE.Color(0x00000, 1.0))
      renderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      renderer.shadowMapEnabled = true

      // position and point the camera to the center of the scene
      camera.position.x = 0
      camera.position.y = 40
      camera.position.z = 50
      camera.lookAt(scene.position)

      // add the output of the renderer to the html element
      this.$refs.example.appendChild(renderer.domElement)

      // call the render function
      var step = 0

      var cubeMaterial = new THREE.MeshNormalMaterial({
        color: 0x00ff00,
        transparent: true,
        opacity: 0.5,
      })
      var controls = new (function () {
        this.cameraNear = camera.near
        this.cameraFar = camera.far
        this.rotationSpeed = 0.02
        this.combined = false

        this.numberOfObjects = 500

        this.redraw = function () {
          var toRemove = []
          scene.traverse(function (e) {
            if (e instanceof THREE.Mesh) toRemove.push(e)
          })
          toRemove.forEach(function (e) {
            scene.remove(e)
          })

          // add a large number of cubes
          if (controls.combined) {
            var geometry = new THREE.Geometry()
            for (var i = 0; i < controls.numberOfObjects; i++) {
              var cubeMesh = addcube()
              cubeMesh.updateMatrix()
              geometry.merge(cubeMesh.geometry, cubeMesh.matrix)
            }
            scene.add(new THREE.Mesh(geometry, cubeMaterial))
          } else {
            for (var i = 0; i < controls.numberOfObjects; i++) {
              scene.add(controls.addCube())
            }
          }
        }

        this.addCube = addcube

        this.outputObjects = function () {
          console.log(scene.children)
        }
      })()

      var gui = new dat.GUI()

      gui.add(controls, "numberOfObjects", 0, 20000)
      gui.add(controls, "combined").onChange(controls.redraw)
      gui.add(controls, "redraw")

      controls.redraw()

      render()

      var rotation = 0

      function addcube() {
        var cubeSize = 1.0
        var cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize)

        var cube = new THREE.Mesh(cubeGeometry, cubeMaterial)
        cube.castShadow = true

        // position the cube randomly in the scene
        cube.position.x = -60 + Math.round(Math.random() * 100)
        cube.position.y = Math.round(Math.random() * 10)
        cube.position.z = -150 + Math.round(Math.random() * 175)

        // add the cube to the scene
        return cube
      }
      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        rotation += 0.005

        stats.update()

        //            scene.rotation.x+=0.02;

        // rotate the cubes around its axes
        //            scene.traverse(function(e) {
        //                if (e instanceof THREE.Mesh ) {
        //
        //                    e.rotation.x+=controls.rotationSpeed;
        //                    e.rotation.y+=controls.rotationSpeed;
        //                    e.rotation.z+=controls.rotationSpeed;
        //                }
        //            });

        camera.position.x = Math.sin(rotation) * 50
        // camera.position.y = Math.sin(rotation) * 40;
        camera.position.z = Math.cos(rotation) * 50
        camera.lookAt(scene.position)

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        renderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 3.保存并加载

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      var knot = createMesh(new THREE.TorusKnotGeometry(10, 1, 64, 8, 2, 3, 1))
      // add the sphere to the scene
      scene.add(knot)

      // position and point the camera to the center of the scene
      camera.position.x = -30
      camera.position.y = 40
      camera.position.z = 50
      camera.lookAt(new THREE.Vector3(-20, 0, 0))

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      var loadedMesh

      // setup the control gui
      var controls = new (function () {
        console.log(knot.geometry.parameters)
        // we need the first child, since it's a multimaterial
        this.radius = knot.geometry.parameters.radius
        this.tube = 0.3
        this.radialSegments = knot.geometry.parameters.radialSegments
        this.tubularSegments = knot.geometry.parameters.tubularSegments
        this.p = knot.geometry.parameters.p
        this.q = knot.geometry.parameters.q
        this.heightScale = knot.geometry.parameters.heightScale

        this.redraw = function () {
          // remove the old plane
          scene.remove(knot)
          // create a new one
          knot = createMesh(
            new THREE.TorusKnotGeometry(
              controls.radius,
              controls.tube,
              Math.round(controls.radialSegments),
              Math.round(controls.tubularSegments),
              Math.round(controls.p),
              Math.round(controls.q),
              controls.heightScale
            )
          )
          // add it to the scene.
          scene.add(knot)
        }

        this.save = function () {
          var result = knot.toJSON()
          localStorage.setItem("json", JSON.stringify(result))
        }

        this.load = function () {
          scene.remove(loadedMesh)

          var json = localStorage.getItem("json")

          if (json) {
            var loadedGeometry = JSON.parse(json)
            var loader = new THREE.ObjectLoader()

            loadedMesh = loader.parse(loadedGeometry)
            loadedMesh.position.x -= 50
            scene.add(loadedMesh)
          }
        }
      })()

      var gui = new dat.GUI()
      var ioGui = gui.addFolder("Save & Load")
      ioGui.add(controls, "save").onChange(controls.save)
      ioGui.add(controls, "load").onChange(controls.load)
      var meshGui = gui.addFolder("mesh")
      meshGui.add(controls, "radius", 0, 40).onChange(controls.redraw)
      meshGui.add(controls, "tube", 0, 40).onChange(controls.redraw)
      meshGui
        .add(controls, "radialSegments", 0, 400)
        .step(1)
        .onChange(controls.redraw)
      meshGui
        .add(controls, "tubularSegments", 1, 20)
        .step(1)
        .onChange(controls.redraw)
      meshGui.add(controls, "p", 1, 10).step(1).onChange(controls.redraw)
      meshGui.add(controls, "q", 1, 15).step(1).onChange(controls.redraw)
      meshGui.add(controls, "heightScale", 0, 5).onChange(controls.redraw)

      render()

      function createMesh(geom) {
        // assign two materials
        var meshMaterial = new THREE.MeshBasicMaterial({
          vertexColors: THREE.VertexColors,
          wireframe: true,
          wireframeLinewidth: 2,
          color: 0xaaaaaa,
        })
        meshMaterial.side = THREE.DoubleSide

        // create a multimaterial
        var mesh = new THREE.Mesh(geom, meshMaterial)

        return mesh
      }

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        knot.rotation.y = step += 0.01

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 4.加载并保存场景

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var renderer = new THREE.WebGLRenderer()

      renderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      renderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      //    renderer.shadowMapEnabled = true;

      // create the ground plane
      var planeGeometry = new THREE.PlaneGeometry(60, 20, 1, 1)
      var planeMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff })
      var plane = new THREE.Mesh(planeGeometry, planeMaterial)
      //  plane.receiveShadow  = true;

      // rotate and position the plane
      plane.rotation.x = -0.5 * Math.PI
      plane.position.x = 15
      plane.position.y = 0
      plane.position.z = 0

      // add the plane to the scene
      scene.add(plane)

      // create a cube
      var cubeGeometry = new THREE.BoxGeometry(4, 4, 4)
      var cubeMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 })
      var cube = new THREE.Mesh(cubeGeometry, cubeMaterial)
      // cube.castShadow = true;

      // position the cube
      cube.position.x = -4
      cube.position.y = 3
      cube.position.z = 0

      // add the cube to the scene
      scene.add(cube)

      var sphereGeometry = new THREE.SphereGeometry(4, 20, 20)
      var sphereMaterial = new THREE.MeshLambertMaterial({ color: 0x7777ff })
      var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial)

      // position the sphere
      sphere.position.x = 20
      sphere.position.y = 0
      sphere.position.z = 2
      //  sphere.castShadow=true;

      // add the sphere to the scene
      scene.add(sphere)

      // position and point the camera to the center of the scene
      camera.position.x = -30
      camera.position.y = 40
      camera.position.z = 30
      camera.lookAt(scene.position)

      // add subtle ambient lighting
      var ambientLight = new THREE.AmbientLight(0x0c0c0c)
      scene.add(ambientLight)

      // add spotlight for the shadows
      var spotLight = new THREE.PointLight(0xffffff)
      spotLight.position.set(-40, 60, -10)
      //  spotLight.castShadow = true;
      scene.add(spotLight)

      // add the output of the renderer to the html element
      this.$refs.example.appendChild(renderer.domElement)

      // call the render function
      var step = 0

      var controls = new (function () {
        this.exportScene = function () {
          var exporter = new THREE.SceneExporter()
          var sceneJson = JSON.stringify(exporter.parse(scene))
          localStorage.setItem("scene", sceneJson)
        }

        this.clearScene = function () {
          scene = new THREE.Scene()
        }

        this.importScene = function () {
          var json = localStorage.getItem("scene")
          var sceneLoader = new THREE.SceneLoader()

          sceneLoader.parse(
            JSON.parse(json),
            function (e) {
              scene = e.scene
            },
            "."
          )
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "exportScene")
      gui.add(controls, "clearScene")
      gui.add(controls, "importScene")

      render()

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()
        // rotate the cube around its axes

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        renderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 5.负荷混合器模型

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      // position and point the camera to the center of the scene
      camera.position.x = -30
      camera.position.y = 40
      camera.position.z = 50
      camera.lookAt(new THREE.Vector3(0, 10, 0))

      // add spotlight for the shadows
      var spotLight = new THREE.SpotLight(0xffffff)
      spotLight.position.set(0, 50, 30)
      spotLight.intensity = 2
      scene.add(spotLight)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      // setup the control gui
      var controls = new (function () {
        // we need the first child, since it's a multimaterial
      })()

      var gui = new dat.GUI()
      var mesh

      var loader = new THREE.JSONLoader()
      loader.load(
        "../assets/models/misc_chair01.js",
        function (geometry, mat) {
          mesh = new THREE.Mesh(geometry, mat[0])

          mesh.scale.x = 15
          mesh.scale.y = 15
          mesh.scale.z = 15

          scene.add(mesh)
        },
        "../assets/models/"
      )

      render()

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        if (mesh) {
          mesh.rotation.y += 0.02
        }

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 6.负载 OBJ 模型

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xaaaaff, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      // position and point the camera to the center of the scene
      camera.position.x = 130
      camera.position.y = 40
      camera.position.z = 50
      camera.lookAt(scene.position)
      scene.add(camera)

      // add spotlight for the shadows
      var spotLight = new THREE.DirectionalLight(0xffffff)
      spotLight.position.set(30, 40, 50)
      spotLight.intensity = 1
      scene.add(spotLight)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      // setup the control gui
      var controls = new (function () {
        // we need the first child, since it's a multimaterial
      })()

      var gui = new dat.GUI()
      var mesh

      var loader = new THREE.OBJLoader()
      loader.load("../assets/models/pinecone.obj", function (loadedMesh) {
        var material = new THREE.MeshLambertMaterial({ color: 0x5c3a21 })

        // loadedMesh is a group of meshes. For
        // each mesh set the material, and compute the information
        // three.js needs for rendering.
        loadedMesh.children.forEach(function (child) {
          child.material = material
          child.geometry.computeFaceNormals()
          child.geometry.computeVertexNormals()
        })

        mesh = loadedMesh
        loadedMesh.scale.set(100, 100, 100)
        loadedMesh.rotation.x = -0.3
        scene.add(loadedMesh)
      })

      render()

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        if (mesh) {
          mesh.rotation.y += 0.006
          mesh.rotation.x += 0.006
          //                mesh.rotation.y+=0.006;
        }

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 7.加载 OBJ 和 MTL

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xaaaaff, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      // position and point the camera to the center of the scene
      camera.position.x = -30
      camera.position.y = 40
      camera.position.z = 50
      camera.lookAt(new THREE.Vector3(0, 10, 0))

      // add spotlight for the shadows
      var spotLight = new THREE.SpotLight(0xffffff)
      spotLight.position.set(0, 40, 30)
      spotLight.intensity = 2
      scene.add(spotLight)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      // setup the control gui
      var controls = new (function () {
        // we need the first child, since it's a multimaterial
      })()

      var gui = new dat.GUI()
      var mesh

      var loader = new THREE.OBJMTLLoader()

      loader.load(
        "../assets/models/butterfly.obj",
        "../assets/models/butterfly.mtl",
        function (object) {
          // configure the wings
          var wing2 = object.children[5].children[0]
          var wing1 = object.children[4].children[0]

          wing1.material.opacity = 0.6
          wing1.material.transparent = true
          wing1.material.depthTest = false
          wing1.material.side = THREE.DoubleSide

          wing2.material.opacity = 0.6
          wing2.material.depthTest = false
          wing2.material.transparent = true
          wing2.material.side = THREE.DoubleSide

          object.scale.set(140, 140, 140)
          mesh = object
          scene.add(mesh)

          object.rotation.x = 0.2
          object.rotation.y = -1.3
        }
      )

      render()

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        if (mesh) {
          mesh.rotation.y += 0.006
        }

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 8.载荷-科拉达模型

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xcccccc, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      // position and point the camera to the center of the scene
      camera.position.x = 150
      camera.position.y = 150
      camera.position.z = 150
      camera.lookAt(new THREE.Vector3(0, 20, 0))

      // add spotlight for the shadows
      var spotLight = new THREE.SpotLight(0xffffff)
      spotLight.position.set(150, 150, 150)
      spotLight.intensity = 2
      scene.add(spotLight)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // model from http://www.thingiverse.com/thing:69709
      var loader = new THREE.ColladaLoader()

      var mesh
      loader.load("../assets/models/dae/Truck_dae.dae", function (result) {
        mesh = result.scene.children[0].children[0].clone()
        mesh.scale.set(4, 4, 4)
        scene.add(mesh)
      })

      render()

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()
        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 9.加载 stl 模型

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0x000, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      // position and point the camera to the center of the scene
      camera.position.x = 150
      camera.position.y = 150
      camera.position.z = 150
      camera.lookAt(new THREE.Vector3(0, 40, 0))

      // add spotlight for the shadows
      var spotLight = new THREE.SpotLight(0xffffff)
      spotLight.position.set(150, 150, 150)
      scene.add(spotLight)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      // setup the control gui
      var controls = new (function () {
        // we need the first child, since it's a multimaterial
      })()

      var group
      var gui = new dat.GUI()

      // model from http://www.thingiverse.com/thing:69709
      var loader = new THREE.STLLoader()
      var group = new THREE.Object3D()
      loader.load(
        "../assets/models/SolidHead_2_lowPoly_42k.stl",
        function (geometry) {
          console.log(geometry)
          var mat = new THREE.MeshLambertMaterial({ color: 0x7777ff })
          group = new THREE.Mesh(geometry, mat)
          group.rotation.x = -0.5 * Math.PI
          group.scale.set(0.6, 0.6, 0.6)
          scene.add(group)
        }
      )

      render()

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        if (group) {
          group.rotation.z += 0.006
          // group.rotation.x+=0.006;
        }

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 10.加载 ctm 模型

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0x000, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      // position and point the camera to the center of the scene
      camera.position.x = 10
      camera.position.y = 10
      camera.position.z = 10
      camera.lookAt(new THREE.Vector3(0, 0, 0))

      // add spotlight for the shadows
      var spotLight = new THREE.SpotLight(0xffffff)
      spotLight.position.set(20, 20, 20)
      scene.add(spotLight)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      var group
      var gui = new dat.GUI()

      var loader = new THREE.CTMLoader()
      var group = new THREE.Object3D()

      loader.load(
        "../assets/models/auditt_wheel.ctm",
        function (geometry) {
          var mat = new THREE.MeshLambertMaterial({ color: 0xff8888 })
          group = new THREE.Mesh(geometry, mat)
          group.scale.set(20, 20, 20)
          scene.add(group)
        },
        {}
      )

      render()

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        if (group) {
          group.rotation.y += 0.006
          group.rotation.x += 0.009
          // group.rotation.x+=0.006;
        }

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 11.加载 vtk 模型

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0x000, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      // position and point the camera to the center of the scene
      camera.position.x = 10
      camera.position.y = 10
      camera.position.z = 10
      camera.lookAt(new THREE.Vector3(0, 0, 0))

      // add spotlight for the shadows
      var spotLight = new THREE.SpotLight(0xffffff)
      spotLight.position.set(20, 20, 20)
      scene.add(spotLight)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      // setup the control gui
      var controls = new (function () {
        // we need the first child, since it's a multimaterial
      })()

      var group
      var gui = new dat.GUI()

      var loader = new THREE.VTKLoader()
      var group = new THREE.Object3D()
      loader.load("../assets/models/moai_fixed.vtk", function (geometry) {
        var mat = new THREE.MeshLambertMaterial({ color: 0xaaffaa })
        group = new THREE.Mesh(geometry, mat)
        group.scale.set(9, 9, 9)
        scene.add(group)
      })

      render()

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        if (group) {
          group.rotation.y += 0.006
          // group.rotation.x+=0.006;
        }

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 12.加载 pdb 模型

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0x000, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      // position and point the camera to the center of the scene
      camera.position.x = 6
      camera.position.y = 6
      camera.position.z = 6
      camera.lookAt(new THREE.Vector3(0, 0, 0))

      var dir1 = new THREE.DirectionalLight(0.4)
      dir1.position.set(-30, 30, -30)
      scene.add(dir1)

      var dir2 = new THREE.DirectionalLight(0.4)
      dir2.position.set(-30, 30, 30)
      scene.add(dir2)

      var dir3 = new THREE.DirectionalLight(0.4)
      dir3.position.set(30, 30, -30)
      scene.add(dir3)

      // add spotlight for the shadows
      var spotLight = new THREE.SpotLight(0xffffff)
      spotLight.position.set(30, 30, 30)
      scene.add(spotLight)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      // setup the control gui
      var controls = new (function () {
        // we need the first child, since it's a multimaterial
      })()

      var gui = new dat.GUI()
      var mesh

      var loader = new THREE.PDBLoader()
      var group = new THREE.Object3D()
      loader.load(
        "../assets/models/aspirin.pdb",
        function (geometry, geometryBonds) {
          //        loader.load("../assets/models/diamond.pdb", function (geometry, geometryBonds) {
          var i = 0

          geometry.vertices.forEach(function (position) {
            var sphere = new THREE.SphereGeometry(0.2)
            var material = new THREE.MeshPhongMaterial({
              color: geometry.colors[i++],
            })
            var mesh = new THREE.Mesh(sphere, material)
            mesh.position.copy(position)
            group.add(mesh)
          })

          for (var j = 0; j < geometryBonds.vertices.length; j += 2) {
            var path = new THREE.SplineCurve3([
              geometryBonds.vertices[j],
              geometryBonds.vertices[j + 1],
            ])
            var tube = new THREE.TubeGeometry(path, 1, 0.04)
            var material = new THREE.MeshPhongMaterial({ color: 0xcccccc })
            var mesh = new THREE.Mesh(tube, material)
            group.add(mesh)
          }

          scene.add(group)
        }
      )

      render()

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        if (group) {
          group.rotation.y += 0.006
          group.rotation.x += 0.006
        }

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 13.加载 ply 模型

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0x000, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      // position and point the camera to the center of the scene
      camera.position.x = 10
      camera.position.y = 10
      camera.position.z = 10
      camera.lookAt(new THREE.Vector3(0, -2, 0))

      // add spotlight for the shadows
      var spotLight = new THREE.SpotLight(0xffffff)
      spotLight.position.set(20, 20, 20)
      scene.add(spotLight)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      // setup the control gui
      var controls = new (function () {
        // we need the first child, since it's a multimaterial
      })()

      var group
      var gui = new dat.GUI()

      var loader = new THREE.PLYLoader()
      var group = new THREE.Object3D()
      loader.load("../assets/models/test.ply", function (geometry) {
        var material = new THREE.PointCloudMaterial({
          color: 0xffffff,
          size: 0.4,
          opacity: 0.6,
          transparent: true,
          blending: THREE.AdditiveBlending,
          map: generateSprite(),
        })

        group = new THREE.PointCloud(geometry, material)
        group.sortParticles = true

        scene.add(group)
      })

      render()

      // from THREE.js examples
      function generateSprite() {
        var canvas = document.createElement("canvas")
        canvas.width = 16
        canvas.height = 16

        var context = canvas.getContext("2d")
        var gradient = context.createRadialGradient(
          canvas.width / 2,
          canvas.height / 2,
          0,
          canvas.width / 2,
          canvas.height / 2,
          canvas.width / 2
        )
        gradient.addColorStop(0, "rgba(255,255,255,1)")
        gradient.addColorStop(0.2, "rgba(0,255,255,1)")
        gradient.addColorStop(0.4, "rgba(0,0,64,1)")
        gradient.addColorStop(1, "rgba(0,0,0,1)")

        context.fillStyle = gradient
        context.fillRect(0, 0, canvas.width, canvas.height)

        var texture = new THREE.Texture(canvas)
        texture.needsUpdate = true
        return texture
      }

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        if (group) {
          // group.rotation.y+=0.006;
          group.rotation.y += 0.006
          //                if (group.geometry) {
          //                    group.geometry.vertices.forEach(function(v) {
          ////                        var scale = 1.001 + Math.random()/100;
          //                        var sMatrix = new THREE.Matrix3(1.001 + Math.random()/100,0,0,
          //                                0,1.001 + Math.random()/100,0,
          //                                0,0,1.001 + Math.random()/100);
          //                        v.applyMatrix3(sMatrix);
          //                    })
          //                }
        }

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 14.加载 awd 模型

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0x000, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      // position and point the camera to the center of the scene
      camera.position.x = 30
      camera.position.y = 30
      camera.position.z = 30
      camera.lookAt(new THREE.Vector3(0, 0, 0))

      var orbit = new THREE.OrbitControls(camera)

      var dir1 = new THREE.DirectionalLight()
      dir1.position.set(-30, 30, -30)
      scene.add(dir1)

      var dir2 = new THREE.DirectionalLight()
      dir2.position.set(-30, 30, 30)
      scene.add(dir2)

      var dir3 = new THREE.DirectionalLight()
      dir3.position.set(30, 30, -30)
      scene.add(dir3)

      // add spotlight for the shadows
      var spotLight = new THREE.SpotLight(0xffffff)
      spotLight.position.set(30, 30, 30)
      scene.add(spotLight)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      // setup the control gui
      var controls = new (function () {
        // we need the first child, since it's a multimaterial
      })()

      var group
      var gui = new dat.GUI()

      var loader = new THREE.AWDLoader()
      var group = new THREE.Object3D()
      loader.load("../assets/models/awd/PolarBear.awd", function (model) {
        console.log(model)

        model.traverse(function (child) {
          if (child instanceof THREE.Mesh) {
            child.material = new THREE.MeshLambertMaterial({ color: 0xaaaaaa })
            console.log(child.geometry)
          }
        })

        model.scale.set(0.1, 0.1, 0.1)

        scene.add(model)
      })

      render()

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        orbit.update()

        if (group) {
          group.rotation.y += 0.006
          // group.rotation.x+=0.006;
        }

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 15.加载 assimp 模型

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0x000, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      // position and point the camera to the center of the scene
      camera.position.x = 30
      camera.position.y = 30
      camera.position.z = 30
      camera.lookAt(new THREE.Vector3(0, 0, 0))

      var orbit = new THREE.OrbitControls(camera)

      var dir1 = new THREE.DirectionalLight()
      dir1.position.set(-30, 30, -30)
      scene.add(dir1)

      var dir2 = new THREE.DirectionalLight()
      dir2.position.set(-30, 30, 30)
      scene.add(dir2)

      var dir3 = new THREE.DirectionalLight()
      dir3.position.set(30, 30, -30)
      scene.add(dir3)

      // add spotlight for the shadows
      var spotLight = new THREE.SpotLight(0xffffff)
      spotLight.position.set(30, 30, 30)
      scene.add(spotLight)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      // setup the control gui
      var controls = new (function () {
        // we need the first child, since it's a multimaterial
      })()

      var group
      var gui = new dat.GUI()

      var loader = new THREE.AssimpJSONLoader()
      var group = new THREE.Object3D()
      loader.load(
        "../assets/models/assimp/spider.obj.assimp.json",
        function (model) {
          console.log(model)

          model.traverse(function (child) {
            if (child instanceof THREE.Mesh) {
              //                    child.material = new THREE.MeshLambertMaterial({color:0xaaaaaa});
              console.log(child.geometry)
            }
          })

          model.scale.set(0.1, 0.1, 0.1)

          scene.add(model)
        }
      )

      render()

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        orbit.update()

        if (group) {
          group.rotation.y += 0.006
          // group.rotation.x+=0.006;
        }

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 16.加载 vrml 模型

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0x000, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      // position and point the camera to the center of the scene
      camera.position.x = 30
      camera.position.y = 30
      camera.position.z = 30
      camera.lookAt(new THREE.Vector3(0, 0, 0))

      var orbit = new THREE.OrbitControls(camera)

      var dir1 = new THREE.DirectionalLight(0.4)
      dir1.position.set(-30, 30, -30)
      scene.add(dir1)

      var dir2 = new THREE.DirectionalLight(0.4)
      dir2.position.set(-30, 30, 30)
      scene.add(dir2)

      var dir3 = new THREE.DirectionalLight(0.4)
      dir3.position.set(30, 30, -30)
      scene.add(dir3)

      // add spotlight for the shadows
      var spotLight = new THREE.SpotLight(0xffffff)
      spotLight.position.set(30, 30, 30)
      scene.add(spotLight)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      // setup the control gui
      var controls = new (function () {
        // we need the first child, since it's a multimaterial
      })()

      var group
      var gui = new dat.GUI()

      var loader = new THREE.VRMLLoader()
      var group = new THREE.Object3D()
      loader.load("../assets/models/vrml/tree.wrl", function (model) {
        console.log(model)

        model.traverse(function (child) {
          if (child instanceof THREE.Mesh) {
            //                    child.material = new THREE.MeshLambertMaterial({color:0xaaaaaa});
            console.log(child.geometry)
          }
        })

        model.scale.set(10, 10, 10)

        scene.add(model)
      })

      render()

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        orbit.update()

        if (group) {
          group.rotation.y += 0.006
          // group.rotation.x+=0.006;
        }

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 17.加载 vrml 模型

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0x000, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      // position and point the camera to the center of the scene
      camera.position.x = 30
      camera.position.y = 30
      camera.position.z = 30
      camera.lookAt(new THREE.Vector3(0, 0, 0))

      var orbit = new THREE.OrbitControls(camera)

      var dir1 = new THREE.DirectionalLight()
      dir1.position.set(-30, 30, -30)
      scene.add(dir1)

      var dir2 = new THREE.DirectionalLight()
      dir2.position.set(-30, 30, 30)
      scene.add(dir2)

      var dir3 = new THREE.DirectionalLight()
      dir3.position.set(30, 30, -30)
      scene.add(dir3)

      // add spotlight for the shadows
      var spotLight = new THREE.SpotLight(0xffffff)
      spotLight.position.set(30, 30, 30)
      scene.add(spotLight)

      // add the output of the renderer to the html element
      
        this.$refs.example
        .appendChild(webGLRenderer.domElement)

      // call the render function
      var step = 0

      // setup the control gui
      var controls = new (function () {
        // we need the first child, since it's a multimaterial
      })()

      var gui = new dat.GUI()

      var loader = new THREE.BabylonLoader()
      var group = new THREE.Object3D()
      loader.load(
        "../assets/models/babylon/skull.babylon",
        function (loadedScene) {
          // babylon loader contains a complete scene.
          console.log(
            (loadedScene.children[1].material = new THREE.MeshLambertMaterial())
          )
          scene = loadedScene
        }
      )

      render()

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        orbit.update()

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        webGLRenderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::
