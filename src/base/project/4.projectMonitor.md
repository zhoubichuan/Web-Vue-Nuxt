---
lang: zh-CN
sidebarDepth: 0
meta:
  - name: description
    content: 个人总结的vuepress学习技术文档-主题
  - name: keywords
    content: vuepress,最新技术文档,vuepress主题
---

# 四.材质

<xminder tipkey="a"/>

## 1.MeshBasicMaterial

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var renderer
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      var canvasRenderer = new THREE.CanvasRenderer()
      canvasRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      renderer = webGLRenderer

      var groundGeom = new THREE.PlaneGeometry(100, 100, 4, 4)
      var groundMesh = new THREE.Mesh(
        groundGeom,
        new THREE.MeshBasicMaterial({ color: 0x777777 })
      )
      groundMesh.rotation.x = -Math.PI / 2
      groundMesh.position.y = -20
      scene.add(groundMesh)

      var sphereGeometry = new THREE.SphereGeometry(14, 20, 20)
      var cubeGeometry = new THREE.BoxGeometry(15, 15, 15)
      var planeGeometry = new THREE.PlaneGeometry(14, 14, 4, 4)

      var meshMaterial = new THREE.MeshBasicMaterial({ color: 0x7777ff })

      var sphere = new THREE.Mesh(sphereGeometry, meshMaterial)
      var cube = new THREE.Mesh(cubeGeometry, meshMaterial)
      var plane = new THREE.Mesh(planeGeometry, meshMaterial)

      // position the sphere
      sphere.position.x = 0
      sphere.position.y = 3
      sphere.position.z = 2

      cube.position.set(0, 3, 2)
      plane.position.set(0, 3, 2)

      // add the sphere to the scene
      scene.add(cube)

      camera.position.x = -20
      camera.position.y = 50
      camera.position.z = 40
      camera.lookAt(new THREE.Vector3(10, 0, 0))

      // add subtle ambient lighting
      var ambientLight = new THREE.AmbientLight(0x0c0c0c)
      scene.add(ambientLight)

      // add spotlight for the shadows
      var spotLight = new THREE.SpotLight(0xffffff)
      spotLight.position.set(-40, 60, -10)
      spotLight.castShadow = true
      scene.add(spotLight)

      // add the output of the renderer to the html element
      this.$refs.example.appendChild(renderer.domElement)

      // call the render function
      var step = 0
      var oldContext = null

      var controls = new (function () {
        this.rotationSpeed = 0.02
        this.bouncingSpeed = 0.03

        this.opacity = meshMaterial.opacity
        this.transparent = meshMaterial.transparent
        this.overdraw = meshMaterial.overdraw
        this.visible = meshMaterial.visible
        this.side = "front"

        this.color = meshMaterial.color.getStyle()
        this.wireframe = meshMaterial.wireframe
        this.wireframeLinewidth = meshMaterial.wireframeLinewidth
        this.wireFrameLineJoin = meshMaterial.wireframeLinejoin

        this.selectedMesh = "cube"

        this.switchRenderer = function () {
          if (renderer instanceof THREE.WebGLRenderer) {
            renderer = canvasRenderer
            this.$refs.example.empty()

            this.$refs.example.appendChild(renderer.domElement)
          } else {
            renderer = webGLRenderer
            this.$refs.example.empty()

            this.$refs.example.appendChild(renderer.domElement)
          }
        }
      })()

      var gui = new dat.GUI()

      var spGui = gui.addFolder("Mesh")
      spGui.add(controls, "opacity", 0, 1).onChange(function (e) {
        meshMaterial.opacity = e
      })
      spGui.add(controls, "transparent").onChange(function (e) {
        meshMaterial.transparent = e
      })
      spGui.add(controls, "wireframe").onChange(function (e) {
        meshMaterial.wireframe = e
      })
      spGui.add(controls, "wireframeLinewidth", 0, 20).onChange(function (e) {
        meshMaterial.wireframeLinewidth = e
      })
      spGui.add(controls, "visible").onChange(function (e) {
        meshMaterial.visible = e
      })
      spGui
        .add(controls, "side", ["front", "back", "double"])
        .onChange(function (e) {
          switch (e) {
            case "front":
              meshMaterial.side = THREE.FrontSide
              break
            case "back":
              meshMaterial.side = THREE.BackSide
              break
            case "double":
              meshMaterial.side = THREE.DoubleSide
              break
          }
          meshMaterial.needsUpdate = true
        })
      spGui.addColor(controls, "color").onChange(function (e) {
        meshMaterial.color.setStyle(e)
      })
      spGui
        .add(controls, "selectedMesh", ["cube", "sphere", "plane"])
        .onChange(function (e) {
          scene.remove(plane)
          scene.remove(cube)
          scene.remove(sphere)

          switch (e) {
            case "cube":
              scene.add(cube)
              break
            case "sphere":
              scene.add(sphere)
              break
            case "plane":
              scene.add(plane)
              break
          }

          scene.add(e)
        })

      gui.add(controls, "switchRenderer")
      var cvGui = gui.addFolder("Canvas renderer")
      cvGui.add(controls, "overdraw").onChange(function (e) {
        meshMaterial.overdraw = e
      })
      cvGui
        .add(controls, "wireFrameLineJoin", ["round", "bevel", "miter"])
        .onChange(function (e) {
          meshMaterial.wireframeLinejoin = e
        })

      render()

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        cube.rotation.y = step += 0.01
        plane.rotation.y = step
        sphere.rotation.y = step

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        renderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 2.MeshDepthMaterial

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()
      scene.overrideMaterial = new THREE.MeshDepthMaterial()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        10,
        130
      )

      // create a render and set the size
      var renderer = new THREE.WebGLRenderer()

      renderer.setClearColor(new THREE.Color(0x00000, 1.0))
      renderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      renderer.shadowMapEnabled = true

      // position and point the camera to the center of the scene
      camera.position.x = -50
      camera.position.y = 40
      camera.position.z = 50
      camera.lookAt(scene.position)

      // add the output of the renderer to the html element
      this.$refs.example.appendChild(renderer.domElement)

      // call the render function
      var step = 0

      var controls = new (function () {
        this.cameraNear = camera.near
        this.cameraFar = camera.far
        this.rotationSpeed = 0.02
        this.numberOfObjects = scene.children.length

        this.removeCube = function () {
          var allChildren = scene.children
          var lastObject = allChildren[allChildren.length - 1]
          if (lastObject instanceof THREE.Mesh) {
            scene.remove(lastObject)
            this.numberOfObjects = scene.children.length
          }
        }

        this.addCube = function () {
          var cubeSize = Math.ceil(3 + Math.random() * 3)
          var cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize)
          var cubeMaterial = new THREE.MeshLambertMaterial({
            color: Math.random() * 0xffffff,
          })
          var cube = new THREE.Mesh(cubeGeometry, cubeMaterial)
          cube.castShadow = true

          // position the cube randomly in the scene
          cube.position.x = -60 + Math.round(Math.random() * 100)
          cube.position.y = Math.round(Math.random() * 10)
          cube.position.z = -100 + Math.round(Math.random() * 150)

          // add the cube to the scene
          scene.add(cube)
          this.numberOfObjects = scene.children.length
        }

        this.outputObjects = function () {
          console.log(scene.children)
        }
      })()

      var gui = new dat.GUI()
      gui.add(controls, "rotationSpeed", 0, 0.5)
      gui.add(controls, "addCube")
      gui.add(controls, "removeCube")
      gui.add(controls, "cameraNear", 0, 50).onChange(function (e) {
        camera.near = e
      })
      gui.add(controls, "cameraFar", 50, 200).onChange(function (e) {
        camera.far = e
      })

      var i = 0
      while (i < 10) {
        controls.addCube()
        i++
      }

      render()

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        // rotate the cubes around its axes
        scene.traverse(function (e) {
          if (e instanceof THREE.Mesh) {
            e.rotation.x += controls.rotationSpeed
            e.rotation.y += controls.rotationSpeed
            e.rotation.z += controls.rotationSpeed
          }
        })

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        renderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 3.复合材料

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        10,
        130
      )
      var renderer = new THREE.WebGLRenderer()
      renderer.sortObjects = false
      renderer.setClearColor(new THREE.Color(0x00000, 1.0))
      renderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      renderer.shadowMapEnabled = true
      camera.position.x = -50
      camera.position.y = 40
      camera.position.z = 50
      camera.near = 7
      camera.far = 139
      camera.lookAt(scene.position)
      this.$refs.example.appendChild(renderer.domElement)
      var step = 0
      var controls = new (function () {
        this.cameraNear = camera.near
        this.cameraFar = camera.far
        this.rotationSpeed = 0.02
        this.numberOfObjects = scene.children.length
        this.color = 0x00ff00

        this.removeCube = function () {
          var allChildren = scene.children
          var lastObject = allChildren[allChildren.length - 1]
          if (lastObject instanceof THREE.Mesh) {
            scene.remove(lastObject)
            this.numberOfObjects = scene.children.length
          }
        }
        this.addCube = function () {
          var cubeSize = Math.ceil(3 + Math.random() * 3)
          var cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize)
          var cubeMaterial = new THREE.MeshDepthMaterial()
          var colorMaterial = new THREE.MeshBasicMaterial({
            color: controls.color,
            transparent: true,
            blending: THREE.MultiplyBlending,
          })
          var cube = new THREE.SceneUtils.createMultiMaterialObject(
            cubeGeometry,
            [colorMaterial, cubeMaterial]
          )
          cube.children[1].scale.set(0.99, 0.99, 0.99)
          cube.castShadow = true
          cube.position.x = -60 + Math.round(Math.random() * 100)
          cube.position.y = Math.round(Math.random() * 10)
          cube.position.z = -100 + Math.round(Math.random() * 150)
          scene.add(cube)
          this.numberOfObjects = scene.children.length
        }

        this.outputObjects = function () {
          console.log(scene.children)
        }
      })()

      var gui = new dat.GUI()
      gui.addColor(controls, "color")
      gui.add(controls, "rotationSpeed", 0, 0.5)
      gui.add(controls, "addCube")
      gui.add(controls, "removeCube")
      gui.add(controls, "cameraNear", 0, 50).onChange(function (e) {
        camera.near = e
      })
      gui.add(controls, "cameraFar", 50, 200).onChange(function (e) {
        camera.far = e
      })

      var i = 0
      while (i < 10) {
        controls.addCube()
        i++
      }

      render()

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()
        scene.traverse(function (e) {
          if (e instanceof THREE.Mesh) {
            e.rotation.x += controls.rotationSpeed
            e.rotation.y += controls.rotationSpeed
            e.rotation.z += controls.rotationSpeed
          }
        })
        requestAnimationFrame(render)
        renderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 4.MeshNormalMaterial

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var renderer
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      var canvasRenderer = new THREE.CanvasRenderer()
      canvasRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      renderer = webGLRenderer

      var groundGeom = new THREE.PlaneGeometry(100, 100, 4, 4)
      var groundMesh = new THREE.Mesh(
        groundGeom,
        new THREE.MeshBasicMaterial({ color: 0x777777 })
      )
      groundMesh.rotation.x = -Math.PI / 2
      groundMesh.position.y = -20
      scene.add(groundMesh)

      var sphereGeometry = new THREE.SphereGeometry(14, 20, 20)
      var cubeGeometry = new THREE.BoxGeometry(15, 15, 15)
      var planeGeometry = new THREE.PlaneGeometry(14, 14, 4, 4)

      var meshMaterial = new THREE.MeshNormalMaterial({ color: 0x7777ff })
      var sphere = new THREE.Mesh(sphereGeometry, meshMaterial)
      var cube = new THREE.Mesh(cubeGeometry, meshMaterial)
      var plane = new THREE.Mesh(planeGeometry, meshMaterial)

      // position the sphere
      sphere.position.x = 0
      sphere.position.y = 3
      sphere.position.z = 2

      for (var f = 0, fl = sphere.geometry.faces.length; f < fl; f++) {
        var face = sphere.geometry.faces[f]
        var centroid = new THREE.Vector3(0, 0, 0)
        centroid.add(sphere.geometry.vertices[face.a])
        centroid.add(sphere.geometry.vertices[face.b])
        centroid.add(sphere.geometry.vertices[face.c])
        centroid.divideScalar(3)

        var arrow = new THREE.ArrowHelper(
          face.normal,
          centroid,
          2,
          0x3333ff,
          0.5,
          0.5
        )
        sphere.add(arrow)
      }

      cube.position.set(0, 3, 2)
      plane.position.set(0, 3, 2)

      // add the sphere to the scene
      scene.add(cube)

      // position and point the camera to the center of the scene
      camera.position.x = -20
      camera.position.y = 30
      camera.position.z = 40
      camera.lookAt(new THREE.Vector3(10, 0, 0))

      // add subtle ambient lighting
      var ambientLight = new THREE.AmbientLight(0x0c0c0c)
      scene.add(ambientLight)

      // add spotlight for the shadows
      var spotLight = new THREE.SpotLight(0xffffff)
      spotLight.position.set(-40, 60, -10)
      spotLight.castShadow = true
      scene.add(spotLight)

      // add the output of the renderer to the html element
      this.$refs.example.appendChild(renderer.domElement)

      // call the render function
      var step = 0
      var oldContext = null

      var controls = new (function () {
        this.rotationSpeed = 0.02
        this.bouncingSpeed = 0.03

        this.opacity = meshMaterial.opacity
        this.transparent = meshMaterial.transparent

        this.visible = meshMaterial.visible
        this.side = "front"

        this.wireframe = meshMaterial.wireframe
        this.wireframeLinewidth = meshMaterial.wireframeLinewidth

        this.selectedMesh = "cube"

        this.shadow = "flat"
      })()

      var gui = new dat.GUI()

      var spGui = gui.addFolder("Mesh")
      spGui.add(controls, "opacity", 0, 1).onChange(function (e) {
        meshMaterial.opacity = e
      })
      spGui.add(controls, "transparent").onChange(function (e) {
        meshMaterial.transparent = e
      })
      spGui.add(controls, "wireframe").onChange(function (e) {
        meshMaterial.wireframe = e
      })
      spGui.add(controls, "wireframeLinewidth", 0, 20).onChange(function (e) {
        meshMaterial.wireframeLinewidth = e
      })
      spGui.add(controls, "visible").onChange(function (e) {
        meshMaterial.visible = e
      })
      spGui
        .add(controls, "side", ["front", "back", "double"])
        .onChange(function (e) {
          console.log(e)
          switch (e) {
            case "front":
              meshMaterial.side = THREE.FrontSide
              break
            case "back":
              meshMaterial.side = THREE.BackSide
              break
            case "double":
              meshMaterial.side = THREE.DoubleSide
              break
          }
          meshMaterial.needsUpdate = true
        })
      spGui.add(controls, "shadow", ["flat", "smooth"]).onChange(function (e) {
        switch (e) {
          case "flat":
            // https://github.com/mrdoob/three.js/issues/1929
            meshMaterial.shading = THREE.FlatShading
            break
          case "smooth":
            meshMaterial.shading = THREE.SmoothShading
            break
        }

        var oldPos = sphere.position.clone()
        scene.remove(sphere)
        scene.remove(plane)
        scene.remove(cube)
        sphere = new THREE.Mesh(sphere.geometry.clone(), meshMaterial)
        cube = new THREE.Mesh(cube.geometry.clone(), meshMaterial)
        plane = new THREE.Mesh(plane.geometry.clone(), meshMaterial)

        sphere.position.set(oldPos)
        cube.position.set(oldPos)
        plane.position.set(oldPos)

        switch (controls.selectedMesh) {
          case "cube":
            scene.add(cube)

            break
          case "sphere":
            scene.add(sphere)

            break
          case "plane":
            scene.add(plane)
            break
        }

        meshMaterial.needsUpdate = true
        console.log(meshMaterial)
      })

      spGui
        .add(controls, "selectedMesh", ["cube", "sphere", "plane"])
        .onChange(function (e) {
          scene.remove(plane)
          scene.remove(cube)
          scene.remove(sphere)

          switch (e) {
            case "cube":
              scene.add(cube)

              break
            case "sphere":
              scene.add(sphere)

              break
            case "plane":
              scene.add(plane)
              break
          }

          scene.add(e)
        })

      render()

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        cube.rotation.y = step += 0.01
        plane.rotation.y = step
        sphere.rotation.y = step

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        renderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 5.MeshFaceMaterial

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var renderer = new THREE.WebGLRenderer()

      renderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      renderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      renderer.shadowMapEnabled = false

      // create the ground plane
      var planeGeometry = new THREE.PlaneGeometry(60, 40, 1, 1)
      var planeMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff })
      var plane = new THREE.Mesh(planeGeometry, planeMaterial)
      plane.receiveShadow = true

      // rotate and position the plane
      plane.rotation.x = -0.5 * Math.PI
      plane.position.x = 0
      plane.position.y = -2
      plane.position.z = 0

      // add the plane to the scene
      scene.add(plane)

      // position and point the camera to the center of the scene
      camera.position.x = -40
      camera.position.y = 40
      camera.position.z = 40
      camera.lookAt(scene.position)

      // add subtle ambient lighting
      //        var ambientLight = new THREE.AmbientLight(0x0c0c0c);
      //        scene.add(ambientLight);

      // add spotlight for the shadows
      var spotLight = new THREE.SpotLight(0xffffff)
      spotLight.position.set(-40, 60, -10)
      spotLight.castShadow = true
      scene.add(spotLight)

      // add the output of the renderer to the html element
      this.$refs.example.appendChild(renderer.domElement)

      var group = new THREE.Mesh()
      // add all the rubik cube elements
      var mats = []
      mats.push(new THREE.MeshBasicMaterial({ color: 0x009e60 }))
      mats.push(new THREE.MeshBasicMaterial({ color: 0x009e60 }))
      mats.push(new THREE.MeshBasicMaterial({ color: 0x0051ba }))
      mats.push(new THREE.MeshBasicMaterial({ color: 0x0051ba }))
      mats.push(new THREE.MeshBasicMaterial({ color: 0xffd500 }))
      mats.push(new THREE.MeshBasicMaterial({ color: 0xffd500 }))
      mats.push(new THREE.MeshBasicMaterial({ color: 0xff5800 }))
      mats.push(new THREE.MeshBasicMaterial({ color: 0xff5800 }))
      mats.push(new THREE.MeshBasicMaterial({ color: 0xc41e3a }))
      mats.push(new THREE.MeshBasicMaterial({ color: 0xc41e3a }))
      mats.push(new THREE.MeshBasicMaterial({ color: 0xffffff }))
      mats.push(new THREE.MeshBasicMaterial({ color: 0xffffff }))

      var faceMaterial = new THREE.MeshFaceMaterial(mats)

      for (var x = 0; x < 3; x++) {
        for (var y = 0; y < 3; y++) {
          for (var z = 0; z < 3; z++) {
            var cubeGeom = new THREE.BoxGeometry(2.9, 2.9, 2.9)
            var cube = new THREE.Mesh(cubeGeom, faceMaterial)
            cube.position.set(x * 3 - 3, y * 3, z * 3 - 3)

            group.add(cube)
          }
        }
      }

      // call the render function
      scene.add(group)
      var step = 0

      var controls = new (function () {
        this.rotationSpeed = 0.02
        this.numberOfObjects = scene.children.length
      })()

      var gui = new dat.GUI()
      gui.add(controls, "rotationSpeed", 0, 0.5)

      render()

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        group.rotation.y = step += controls.rotationSpeed
        // render using requestAnimationFrame
        requestAnimationFrame(render)
        renderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 6.MeshLambertMaterial

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var renderer
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      var canvasRenderer = new THREE.CanvasRenderer()
      canvasRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      renderer = webGLRenderer

      var groundGeom = new THREE.PlaneGeometry(100, 100, 4, 4)
      var groundMesh = new THREE.Mesh(
        groundGeom,
        new THREE.MeshBasicMaterial({ color: 0x555555 })
      )
      groundMesh.rotation.x = -Math.PI / 2
      groundMesh.position.y = -20
      scene.add(groundMesh)

      var sphereGeometry = new THREE.SphereGeometry(14, 20, 20)
      var cubeGeometry = new THREE.BoxGeometry(15, 15, 15)
      var planeGeometry = new THREE.PlaneGeometry(14, 14, 4, 4)

      var meshMaterial = new THREE.MeshLambertMaterial({ color: 0x7777ff })
      var sphere = new THREE.Mesh(sphereGeometry, meshMaterial)
      var cube = new THREE.Mesh(cubeGeometry, meshMaterial)
      var plane = new THREE.Mesh(planeGeometry, meshMaterial)

      // position the sphere
      sphere.position.x = 0
      sphere.position.y = 3
      sphere.position.z = 2

      cube.position.set(0, 3, 2)
      plane.position.set(0, 3, 2)

      // add the sphere to the scene
      scene.add(cube)

      // position and point the camera to the center of the scene
      camera.position.x = -20
      camera.position.y = 30
      camera.position.z = 40
      camera.lookAt(new THREE.Vector3(10, 0, 0))

      // add subtle ambient lighting
      var ambientLight = new THREE.AmbientLight(0x0c0c0c)
      scene.add(ambientLight)

      // add spotlight for the shadows
      var spotLight = new THREE.SpotLight(0xffffff)
      spotLight.position.set(-30, 60, 60)
      spotLight.castShadow = true
      scene.add(spotLight)

      // add the output of the renderer to the html element
      this.$refs.example.appendChild(renderer.domElement)

      // call the render function
      var step = 0

      var controls = new (function () {
        this.rotationSpeed = 0.02
        this.bouncingSpeed = 0.03

        this.opacity = meshMaterial.opacity
        this.transparent = meshMaterial.transparent
        this.overdraw = meshMaterial.overdraw
        this.visible = meshMaterial.visible
        this.emissive = meshMaterial.emissive.getHex()
        this.ambient = meshMaterial.ambient.getHex()
        this.side = "front"

        this.color = meshMaterial.color.getStyle()
        this.wrapAround = false
        this.wrapR = 1
        this.wrapG = 1
        this.wrapB = 1

        this.selectedMesh = "cube"
      })()

      var gui = new dat.GUI()

      var spGui = gui.addFolder("Mesh")
      spGui.add(controls, "opacity", 0, 1).onChange(function (e) {
        meshMaterial.opacity = e
      })
      spGui.add(controls, "transparent").onChange(function (e) {
        meshMaterial.transparent = e
      })
      spGui.add(controls, "visible").onChange(function (e) {
        meshMaterial.visible = e
      })
      spGui.addColor(controls, "ambient").onChange(function (e) {
        meshMaterial.ambient = new THREE.Color(e)
      })
      spGui.addColor(controls, "emissive").onChange(function (e) {
        meshMaterial.emissive = new THREE.Color(e)
      })
      spGui
        .add(controls, "side", ["front", "back", "double"])
        .onChange(function (e) {
          console.log(e)
          switch (e) {
            case "front":
              meshMaterial.side = THREE.FrontSide
              break
            case "back":
              meshMaterial.side = THREE.BackSide
              break
            case "double":
              meshMaterial.side = THREE.DoubleSide
              break
          }
          meshMaterial.needsUpdate = true
        })
      spGui.addColor(controls, "color").onChange(function (e) {
        meshMaterial.color.setStyle(e)
      })
      spGui
        .add(controls, "selectedMesh", ["cube", "sphere", "plane"])
        .onChange(function (e) {
          scene.remove(plane)
          scene.remove(cube)
          scene.remove(sphere)

          switch (e) {
            case "cube":
              scene.add(cube)
              break
            case "sphere":
              scene.add(sphere)
              break
            case "plane":
              scene.add(plane)
              break
          }

          scene.add(e)
        })

      spGui.add(controls, "wrapAround").onChange(function (e) {
        meshMaterial.wrapAround = e
        meshMaterial.needsUpdate = true
      })

      spGui
        .add(controls, "wrapR", 0, 1)
        .step(0.01)
        .onChange(function (e) {
          meshMaterial.wrapRGB.x = e
        })

      spGui
        .add(controls, "wrapG", 0, 1)
        .step(0.01)
        .onChange(function (e) {
          meshMaterial.wrapRGB.y = e
        })

      spGui
        .add(controls, "wrapB", 0, 1)
        .step(0.01)
        .onChange(function (e) {
          meshMaterial.wrapRGB.z = e
        })

      render()

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        cube.rotation.y = step += 0.01
        plane.rotation.y = step
        sphere.rotation.y = step

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        renderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)
      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 7.MeshPhongMaterial

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()
      var scene = new THREE.Scene()
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var renderer
      var webGLRenderer = new THREE.WebGLRenderer()
      webGLRenderer.setClearColor(new THREE.Color(0xeeeeee, 1.0))
      webGLRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      webGLRenderer.shadowMapEnabled = true

      var canvasRenderer = new THREE.CanvasRenderer()
      canvasRenderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      renderer = webGLRenderer

      var groundGeom = new THREE.PlaneGeometry(100, 100, 4, 4)
      var groundMesh = new THREE.Mesh(
        groundGeom,
        new THREE.MeshBasicMaterial({ color: 0x555555 })
      )
      groundMesh.rotation.x = -Math.PI / 2
      groundMesh.position.y = -20
      scene.add(groundMesh)

      var sphereGeometry = new THREE.SphereGeometry(14, 20, 20)
      var cubeGeometry = new THREE.BoxGeometry(15, 15, 15)
      var planeGeometry = new THREE.PlaneGeometry(14, 14, 4, 4)

      var meshMaterial = new THREE.MeshPhongMaterial({ color: 0x7777ff })
      var sphere = new THREE.Mesh(sphereGeometry, meshMaterial)
      var cube = new THREE.Mesh(cubeGeometry, meshMaterial)
      var plane = new THREE.Mesh(planeGeometry, meshMaterial)

      // position the sphere
      sphere.position.x = 0
      sphere.position.y = 3
      sphere.position.z = 2

      cube.position.set(0, 3, 2)
      plane.position.set(0, 3, 2)

      // add the sphere to the scene
      scene.add(cube)

      // position and point the camera to the center of the scene
      camera.position.x = -20
      camera.position.y = 30
      camera.position.z = 40
      camera.lookAt(new THREE.Vector3(10, 0, 0))

      // add subtle ambient lighting
      //        var ambientLight = new THREE.AmbientLight(0x0c0c0c);
      //        scene.add(ambientLight);

      // add spotlight for the shadows
      var spotLight = new THREE.SpotLight(0xffffff)
      spotLight.position.set(-0, 30, 60)
      spotLight.castShadow = true
      spotLight.intensity = 0.6
      scene.add(spotLight)

      // add the output of the renderer to the html element
      this.$refs.example.appendChild(renderer.domElement)

      // call the render function
      var step = 0

      var controls = new (function () {
        this.rotationSpeed = 0.02
        this.bouncingSpeed = 0.03

        this.opacity = meshMaterial.opacity
        this.transparent = meshMaterial.transparent
        this.overdraw = meshMaterial.overdraw
        this.visible = meshMaterial.visible
        this.emissive = meshMaterial.emissive.getHex()
        this.ambient = meshMaterial.ambient.getHex()
        this.specular = meshMaterial.specular.getHex()
        this.shininess = meshMaterial.shininess
        this.side = "front"

        this.color = meshMaterial.color.getStyle()

        this.metal = false
        this.wrapAround = false
        this.wrapR = 1
        this.wrapG = 1
        this.wrapB = 1

        this.selectedMesh = "cube"
      })()

      var gui = new dat.GUI()

      var spGui = gui.addFolder("Mesh")
      spGui.add(controls, "opacity", 0, 1).onChange(function (e) {
        meshMaterial.opacity = e
      })
      spGui.add(controls, "transparent").onChange(function (e) {
        meshMaterial.transparent = e
      })
      spGui.add(controls, "visible").onChange(function (e) {
        meshMaterial.visible = e
      })
      spGui.addColor(controls, "ambient").onChange(function (e) {
        meshMaterial.ambient = new THREE.Color(e)
      })
      spGui.addColor(controls, "emissive").onChange(function (e) {
        meshMaterial.emissive = new THREE.Color(e)
      })
      spGui.addColor(controls, "specular").onChange(function (e) {
        meshMaterial.specular = new THREE.Color(e)
      })
      spGui.add(controls, "shininess", 0, 200).onChange(function (e) {
        meshMaterial.shininess = e
      })
      spGui
        .add(controls, "side", ["front", "back", "double"])
        .onChange(function (e) {
          console.log(e)
          switch (e) {
            case "front":
              meshMaterial.side = THREE.FrontSide
              break
            case "back":
              meshMaterial.side = THREE.BackSide
              break
            case "double":
              meshMaterial.side = THREE.DoubleSide
              break
          }
          meshMaterial.needsUpdate = true
          console.log(meshMaterial)
        })
      spGui.addColor(controls, "color").onChange(function (e) {
        meshMaterial.color.setStyle(e)
      })
      spGui
        .add(controls, "selectedMesh", ["cube", "sphere", "plane"])
        .onChange(function (e) {
          scene.remove(plane)
          scene.remove(cube)
          scene.remove(sphere)

          switch (e) {
            case "cube":
              scene.add(cube)
              break
            case "sphere":
              scene.add(sphere)
              break
            case "plane":
              scene.add(plane)
              break
          }

          scene.add(e)
        })

      spGui.add(controls, "metal").onChange(function (e) {
        meshMaterial.metal = e
        meshMaterial.needsUpdate = true
      })

      spGui.add(controls, "wrapAround").onChange(function (e) {
        meshMaterial.wrapAround = e
        meshMaterial.needsUpdate = true
      })

      spGui
        .add(controls, "wrapR", 0, 1)
        .step(0.01)
        .onChange(function (e) {
          meshMaterial.wrapRGB.x = e
        })

      spGui
        .add(controls, "wrapG", 0, 1)
        .step(0.01)
        .onChange(function (e) {
          meshMaterial.wrapRGB.y = e
        })

      spGui
        .add(controls, "wrapB", 0, 1)
        .step(0.01)
        .onChange(function (e) {
          meshMaterial.wrapRGB.z = e
        })

      render()

      this.$refs.gui.appendChild(gui.domElement)
      function render() {
        stats.update()

        cube.rotation.y = step += 0.01
        plane.rotation.y = step
        sphere.rotation.y = step

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        renderer.render(scene, camera)
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)
      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 8.ShaderMaterial

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size

      var renderer = new THREE.WebGLRenderer()
      renderer.setClearColor(new THREE.Color(0x000000, 1.0))
      renderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      renderer.shadowMapEnabled = true

      var cubeGeometry = new THREE.BoxGeometry(20, 20, 20)

      var meshMaterial1 = createMaterial("vertex-shader", "fragment-shader-1")
      var meshMaterial2 = createMaterial("vertex-shader", "fragment-shader-2")
      var meshMaterial3 = createMaterial("vertex-shader", "fragment-shader-3")
      var meshMaterial4 = createMaterial("vertex-shader", "fragment-shader-4")
      var meshMaterial5 = createMaterial("vertex-shader", "fragment-shader-5")
      var meshMaterial6 = createMaterial("vertex-shader", "fragment-shader-6")

      var material = new THREE.MeshFaceMaterial([
        meshMaterial1,
        meshMaterial2,
        meshMaterial3,
        meshMaterial4,
        meshMaterial5,
        meshMaterial6,
      ])
      //        var material = new THREE.MeshFaceMaterial([meshMaterial2, meshMaterial2, meshMaterial1, meshMaterial1, meshMaterial1, meshMaterial1]);

      var cube = new THREE.Mesh(cubeGeometry, material)

      // add the sphere to the scene
      scene.add(cube)

      // position and point the camera to the center of the scene
      camera.position.x = 30
      camera.position.y = 30
      camera.position.z = 30
      camera.lookAt(new THREE.Vector3(0, 0, 0))

      // add subtle ambient lighting
      var ambientLight = new THREE.AmbientLight(0x0c0c0c)
      scene.add(ambientLight)

      // add spotlight for the shadows
      var spotLight = new THREE.SpotLight(0xffffff)
      spotLight.position.set(-40, 60, -10)
      spotLight.castShadow = true
      scene.add(spotLight)

      // add the output of the renderer to the html element
      this.$refs.example.appendChild(renderer.domElement)

      // call the render function
      var step = 0
      var oldContext = null

      var controls = new (function () {
        this.rotationSpeed = 0.02
        this.bouncingSpeed = 0.03

        this.opacity = meshMaterial1.opacity
        this.transparent = meshMaterial1.transparent

        this.visible = meshMaterial1.visible
        this.side = "front"

        this.wireframe = meshMaterial1.wireframe
        this.wireframeLinewidth = meshMaterial1.wireframeLinewidth

        this.selectedMesh = "cube"

        this.shadow = "flat"
      })()

      render()

      function render() {
        stats.update()

        cube.rotation.y = step += 0.01
        cube.rotation.x = step
        cube.rotation.z = step

        cube.material.materials.forEach(function (e) {
          e.uniforms.time.value += 0.01
        })

        // render using requestAnimationFrame
        requestAnimationFrame(render)
        renderer.render(scene, camera)
      }

      function createMaterial(vertexShader, fragmentShader) {
        var vertShader = document.getElementById(vertexShader).innerHTML
        var fragShader = document.getElementById(fragmentShader).innerHTML

        var attributes = {}
        var uniforms = {
          time: { type: "f", value: 0.2 },
          scale: { type: "f", value: 0.2 },
          alpha: { type: "f", value: 0.6 },
          resolution: { type: "v2", value: new THREE.Vector2() },
        }

        uniforms.resolution.value.x = window.innerWidth
        uniforms.resolution.value.y = window.innerHeight

        var meshMaterial = new THREE.ShaderMaterial({
          uniforms: uniforms,
          attributes: attributes,
          vertexShader: vertShader,
          fragmentShader: fragShader,
          transparent: true,
        })

        return meshMaterial
      }
    },
    initStats() {
      var stats = new Stats()

      stats.setMode(0) // 0: fps, 1: ms

      // Align top-left
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"

      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 9.LineBasicMaterial

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()

      // create a scene, that will hold all our elements such as objects, cameras and lights.
      var scene = new THREE.Scene()

      // create a camera, which defines where we're looking at.
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )

      // create a render and set the size
      var renderer = new THREE.WebGLRenderer()

      renderer.setClearColor(new THREE.Color(0x000000, 1.0))
      renderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      renderer.shadowMapEnabled = true

      // position and point the camera to the center of the scene
      camera.position.x = -30
      camera.position.y = 40
      camera.position.z = 30
      camera.lookAt(scene.position)

      // add subtle ambient lighting
      var ambientLight = new THREE.AmbientLight(0x0c0c0c)
      scene.add(ambientLight)

      // add spotlight for the shadows
      var spotLight = new THREE.SpotLight(0xffffff)
      spotLight.position.set(-40, 60, -10)
      spotLight.castShadow = true
      scene.add(spotLight)

      // get the turtle
      var points = gosper(4, 60)

      var lines = new THREE.Geometry()
      var colors = []
      var i = 0
      points.forEach(function (e) {
        lines.vertices.push(new THREE.Vector3(e.x, e.z, e.y))
        colors[i] = new THREE.Color(0xffffff)
        colors[i].setHSL(e.x / 100 + 0.5, (e.y * 20) / 300, 0.8)
        i++
      })

      lines.colors = colors
      var material = new THREE.LineBasicMaterial({
        opacity: 1.0,
        linewidth: 1,
        vertexColors: THREE.VertexColors,
      })

      var line = new THREE.Line(lines, material)
      line.position.set(25, -30, -60)
      scene.add(line)

      // add the output of the renderer to the html element
      this.$refs.example.appendChild(renderer.domElement)

      // call the render function
      var step = 0
      render()

      function render() {
        stats.update()
        line.rotation.z = step += 0.01

        requestAnimationFrame(render)
        renderer.render(scene, camera)
      }

      function gosper(a, b) {
        var turtle = [0, 0, 0]
        var points = []
        var count = 0

        rg(a, b, turtle)

        return points

        function rt(x) {
          turtle[2] += x
        }

        function lt(x) {
          turtle[2] -= x
        }

        function fd(dist) {
          //                ctx.beginPath();
          points.push({ x: turtle[0], y: turtle[1], z: Math.sin(count) * 5 })
          //                ctx.moveTo(turtle[0], turtle[1]);

          var dir = turtle[2] * (Math.PI / 180)
          turtle[0] += Math.cos(dir) * dist
          turtle[1] += Math.sin(dir) * dist

          points.push({ x: turtle[0], y: turtle[1], z: Math.sin(count) * 5 })
          //                ctx.lineTo(turtle[0], turtle[1]);
          //                ctx.stroke();
        }

        function rg(st, ln, turtle) {
          st--
          ln = ln / 2.6457
          if (st > 0) {
            //                    ctx.strokeStyle = '#111';
            rg(st, ln, turtle)
            rt(60)
            gl(st, ln, turtle)
            rt(120)
            gl(st, ln, turtle)
            lt(60)
            rg(st, ln, turtle)
            lt(120)
            rg(st, ln, turtle)
            rg(st, ln, turtle)
            lt(60)
            gl(st, ln, turtle)
            rt(60)
          }
          if (st == 0) {
            fd(ln)
            rt(60)
            fd(ln)
            rt(120)
            fd(ln)
            lt(60)
            fd(ln)
            lt(120)
            fd(ln)
            fd(ln)
            lt(60)
            fd(ln)
            rt(60)
          }
        }

        function gl(st, ln, turtle) {
          st--
          ln = ln / 2.6457
          if (st > 0) {
            //                    ctx.strokeStyle = '#555';
            lt(60)
            rg(st, ln, turtle)
            rt(60)
            gl(st, ln, turtle)
            gl(st, ln, turtle)
            rt(120)
            gl(st, ln, turtle)
            rt(60)
            rg(st, ln, turtle)
            lt(120)
            rg(st, ln, turtle)
            lt(60)
            gl(st, ln, turtle)
          }
          if (st == 0) {
            lt(60)
            fd(ln)
            rt(60)
            fd(ln)
            fd(ln)
            rt(120)
            fd(ln)
            rt(60)
            fd(ln)
            lt(120)
            fd(ln)
            lt(60)
            fd(ln)
          }
        }
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 10.LineDashedMaterial

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var stats = this.initStats()
      var scene = new THREE.Scene()
      var camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )
      var renderer = new THREE.WebGLRenderer()
      renderer.setClearColor(new THREE.Color(0x000000, 1.0))
      renderer.setSize(window.innerWidth / 2, window.innerHeight / 2)
      renderer.shadowMapEnabled = true
      camera.position.x = -30
      camera.position.y = 40
      camera.position.z = 30
      camera.lookAt(scene.position)
      var ambientLight = new THREE.AmbientLight(0x0c0c0c)
      scene.add(ambientLight)
      var spotLight = new THREE.SpotLight(0xffffff)
      spotLight.position.set(-40, 60, -10)
      spotLight.castShadow = true
      scene.add(spotLight)
      var points = gosper(4, 60)
      var lines = new THREE.Geometry()
      var colors = []
      var i = 0
      points.forEach(function (e) {
        lines.vertices.push(new THREE.Vector3(e.x, e.z, e.y))
        colors[i] = new THREE.Color(0xffffff)
        colors[i].setHSL(e.x / 100 + 0.5, (e.y * 20) / 300, 0.8)
        i++
      })
      lines.colors = colors
      lines.computeLineDistances()
      var material = new THREE.LineDashedMaterial({
        vertexColors: true,
        color: 0xffffff,
        dashSize: 2,
        gapSize: 2,
        scale: 0.1,
      })
      var line = new THREE.Line(lines, material)
      line.position.set(25, -30, -60)
      scene.add(line)
      this.$refs.example.appendChild(renderer.domElement)
      var step = 0
      render()
      function render() {
        stats.update()
        line.rotation.z = step += 0.01

        requestAnimationFrame(render)
        renderer.render(scene, camera)
      }
      function gosper(a, b) {
        var turtle = [0, 0, 0]
        var points = []
        var count = 0
        rg(a, b, turtle)
        return points
        function rt(x) {
          turtle[2] += x
        }
        function lt(x) {
          turtle[2] -= x
        }
        function fd(dist) {
          points.push({ x: turtle[0], y: turtle[1], z: Math.sin(count) * 5 })
          var dir = turtle[2] * (Math.PI / 180)
          turtle[0] += Math.cos(dir) * dist
          turtle[1] += Math.sin(dir) * dist
          points.push({ x: turtle[0], y: turtle[1], z: Math.sin(count) * 5 })
        }

        function rg(st, ln, turtle) {
          st--
          ln = ln / 2.6457
          if (st > 0) {
            rg(st, ln, turtle)
            rt(60)
            gl(st, ln, turtle)
            rt(120)
            gl(st, ln, turtle)
            lt(60)
            rg(st, ln, turtle)
            lt(120)
            rg(st, ln, turtle)
            rg(st, ln, turtle)
            lt(60)
            gl(st, ln, turtle)
            rt(60)
          }
          if (st == 0) {
            fd(ln)
            rt(60)
            fd(ln)
            rt(120)
            fd(ln)
            lt(60)
            fd(ln)
            lt(120)
            fd(ln)
            fd(ln)
            lt(60)
            fd(ln)
            rt(60)
          }
        }

        function gl(st, ln, turtle) {
          st--
          ln = ln / 2.6457
          if (st > 0) {
            //                    ctx.strokeStyle = '#555';
            lt(60)
            rg(st, ln, turtle)
            rt(60)
            gl(st, ln, turtle)
            gl(st, ln, turtle)
            rt(120)
            gl(st, ln, turtle)
            rt(60)
            rg(st, ln, turtle)
            lt(120)
            rg(st, ln, turtle)
            lt(60)
            gl(st, ln, turtle)
          }
          if (st == 0) {
            lt(60)
            fd(ln)
            rt(60)
            fd(ln)
            fd(ln)
            rt(120)
            fd(ln)
            rt(60)
            fd(ln)
            lt(120)
            fd(ln)
            lt(60)
            fd(ln)
          }
        }
      }
    },
    initStats() {
      var stats = new Stats()
      stats.setMode(0) // 0: fps, 1: ms
      stats.domElement.style.position = "absolute"
      stats.domElement.style.left = "0px"
      stats.domElement.style.top = "0px"
      this.$refs.webgl.appendChild(stats.domElement)

      return stats
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::
