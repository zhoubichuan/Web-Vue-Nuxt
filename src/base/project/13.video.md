---
lang: zh-CN
sidebarDepth: 0
meta:
  - name: description
    content: 个人总结的vuepress学习技术文档-主题
  - name: keywords
    content: vuepress,最新技术文档,vuepress主题
---

# 十三.综合

## 2.material-properties

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      Physijs.scripts.worker = "../libs/physijs_worker.js"
      Physijs.scripts.ammo = "../libs/ammo.js"

      var scale = chroma.scale(["white", "blue", "red", "yellow"])

      var initScene,
        render,
        applyForce,
        setMousePosition,
        mouse_position,
        ground_material,
        box_material,
        projector,
        renderer,
        render_stats,
        physics_stats,
        scene,
        ground,
        light,
        camera,
        box,
        boxes = []

      initScene = function () {
        renderer = new THREE.WebGLRenderer({ antialias: true })
        renderer.setSize(window.innerWidth, window.innerHeight)

        renderer.setClearColor(new THREE.Color(0x000000))
        document.getElementById("viewport").appendChild(renderer.domElement)

        render_stats = new Stats()
        render_stats.domElement.style.position = "absolute"
        render_stats.domElement.style.top = "1px"
        render_stats.domElement.style.zIndex = 100
        document.getElementById("viewport").appendChild(render_stats.domElement)

        scene = new Physijs.Scene()
        scene.setGravity(new THREE.Vector3(0, -90, 0))

        camera = new THREE.PerspectiveCamera(
          35,
          window.innerWidth / window.innerHeight,
          1,
          1000
        )
        camera.position.set(80, 60, 80)
        camera.lookAt(scene.position)
        scene.add(camera)

        // Light
        light = new THREE.SpotLight(0xffffff)
        light.position.set(20, 100, 50)

        scene.add(light)

        // Materials
        ground_material = Physijs.createMaterial(
          new THREE.MeshPhongMaterial({
            map: THREE.ImageUtils.loadTexture(
              "../assets/textures/general/floor-wood.jpg"
            ),
          }),
          0.9, // high friction
          0.6 // low restitution
        )
        ground_material.map.wrapS = ground_material.map.wrapT =
          THREE.RepeatWrapping
        ground_material.map.repeat.set(4, 8)

        // Ground
        ground = new Physijs.BoxMesh(
          new THREE.BoxGeometry(60, 1, 130),
          ground_material,
          0 // mass
        )
        ground.receiveShadow = true

        var borderLeft = new Physijs.BoxMesh(
          new THREE.BoxGeometry(2, 6, 130),
          ground_material,
          0 // mass
        )

        borderLeft.position.x = -31
        borderLeft.position.y = 2

        ground.add(borderLeft)

        var borderRight = new Physijs.BoxMesh(
          new THREE.BoxGeometry(2, 6, 130),
          ground_material,
          0 // mass
        )
        borderRight.position.x = 31
        borderRight.position.y = 2

        ground.add(borderRight)

        var borderBottom = new Physijs.BoxMesh(
          new THREE.BoxGeometry(64, 6, 2),
          ground_material,
          0 // mass
        )

        borderBottom.position.z = 65
        borderBottom.position.y = 2
        ground.add(borderBottom)

        var borderTop = new Physijs.BoxMesh(
          new THREE.BoxGeometry(64, 6, 2),
          ground_material,
          0 // mass
        )

        borderTop.position.z = -65
        borderTop.position.y = 2
        ground.add(borderTop)

        //            var pilar_material = Physijs.createMaterial(
        //                    new THREE.MeshPhongMaterial({color:0xff3333}),
        //                    .3, // high friction
        //                    .9 // low restitution
        //            );
        //
        //            var pilar = new Physijs.CylinderMesh(new THREE.CylinderGeometry(2,2,24),pilar_material,0);
        //            ground.add(pilar);
        //
        //
        //            var pilar2 = new Physijs.CylinderMesh(new THREE.CylinderGeometry(2,2,24),pilar_material,0);
        //            pilar2.position.x=15;
        //            ground.add(pilar2);
        //
        //
        //            var pilar3 = new Physijs.CylinderMesh(new THREE.CylinderGeometry(2,2,24),pilar_material,0);
        //            ground.add(pilar3);
        //            pilar3.position.x=-15;

        scene.add(ground)

        var meshes = []

        var controls = new (function () {
          this.cubeRestitution = 0.4
          this.cubeFriction = 0.4
          this.sphereRestitution = 0.9
          this.sphereFriction = 0.1

          this.clearMeshes = function () {
            meshes.forEach(function (e) {
              scene.remove(e)
            })
            meshes = []
          }

          this.addSpheres = function () {
            var colorSphere = scale(Math.random()).hex()
            for (var i = 0; i < 5; i++) {
              box = new Physijs.SphereMesh(
                new THREE.SphereGeometry(2, 20),
                Physijs.createMaterial(
                  new THREE.MeshPhongMaterial({
                    color: colorSphere,
                    opacity: 0.8,
                    transparent: true,
                    //                                                        map: THREE.ImageUtils.loadTexture( '../assets/textures/general/floor-wood.jpg' )
                  }),
                  controls.sphereFriction,
                  controls.sphereRestitution
                )
              )
              box.position.set(
                Math.random() * 50 - 25,
                20 + Math.random() * 5,
                Math.random() * 50 - 25
              )
              meshes.push(box)
              scene.add(box)
            }
          }

          this.addCubes = function () {
            var colorBox = scale(Math.random()).hex()

            for (var i = 0; i < 5; i++) {
              box = new Physijs.BoxMesh(
                new THREE.BoxGeometry(4, 4, 4),
                //                            new THREE.SphereGeometry( 2, 20 ),
                Physijs.createMaterial(
                  new THREE.MeshPhongMaterial({
                    color: colorBox,
                    opacity: 0.8,
                    transparent: true,
                    //                                                map: THREE.ImageUtils.loadTexture( '../assets/textures/general/stone.jpg' )
                  }),
                  controls.cubeFriction,
                  controls.cubeRestitution
                )
              )
              box.position.set(
                Math.random() * 50 - 25,
                20 + Math.random() * 5,
                Math.random() * 50 - 25
              )
              box.rotation.set(
                Math.random() * Math.PI * 2,
                Math.random() * Math.PI * 2,
                Math.random() * Math.PI * 2
              )

              meshes.push(box)
              scene.add(box)
            }
          }
        })()

        var gui = new dat.GUI()
        gui.add(controls, "cubeRestitution", 0, 1)
        gui.add(controls, "cubeFriction", 0, 1)
        gui.add(controls, "sphereRestitution", 0, 1)
        gui.add(controls, "sphereFriction", 0, 1)
        gui.add(controls, "addCubes")
        gui.add(controls, "addSpheres")
        gui.add(controls, "clearMeshes")

        requestAnimationFrame(render)
        scene.simulate()
      }

      var stepX
      var direction = 1

      render = function () {
        requestAnimationFrame(render)
        renderer.render(scene, camera)
        render_stats.update()
        ground.rotation.x += 0.002 * direction

        if (ground.rotation.x < -0.4) direction = 1
        if (ground.rotation.x > 0.4) direction = -1
        ground.__dirtyRotation = true
        scene.simulate(undefined, 1)
      }
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 3.shapes

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      Physijs.scripts.worker = "../libs/physijs_worker.js"
      Physijs.scripts.ammo = "../libs/ammo.js"

      var scale = chroma.scale(["blue", "white"])

      var initScene,
        render,
        applyForce,
        setMousePosition,
        mouse_position,
        ground_material,
        box_material,
        projector,
        renderer,
        render_stats,
        physics_stats,
        scene,
        ground,
        light,
        camera,
        box,
        boxes = []

      initScene = function () {
        renderer = new THREE.WebGLRenderer({ antialias: true })
        renderer.setSize(window.innerWidth, window.innerHeight)

        renderer.setClearColor(new THREE.Color(0x000000))
        renderer.shadowMapEnabled = true

        document.getElementById("viewport").appendChild(renderer.domElement)

        render_stats = new Stats()
        render_stats.domElement.style.position = "absolute"
        render_stats.domElement.style.top = "1px"
        render_stats.domElement.style.left = "1px"
        render_stats.domElement.style.zIndex = 100
        document.getElementById("viewport").appendChild(render_stats.domElement)

        scene = new Physijs.Scene({ reportSize: 10, fixedTimeStep: 1 / 60 })

        scene.setGravity(new THREE.Vector3(0, -20, 0))

        camera = new THREE.PerspectiveCamera(
          35,
          window.innerWidth / window.innerHeight,
          1,
          1000
        )
        camera.position.set(105, 85, 85)
        camera.lookAt(new THREE.Vector3(0, 0, 0))
        scene.add(camera)

        // ambi
        var ambi = new THREE.AmbientLight(0x222222)
        scene.add(ambi)

        // Light
        light = new THREE.SpotLight(0xffffff)
        light.position.set(40, 50, 100)
        light.castShadow = true
        light.shadowMapDebug = true
        light.shadowCameraNear = 10
        light.shadowCameraFar = 200
        light.intensity = 1.5

        var meshes = []
        scene.add(light)

        //            createGround();

        var controls = new (function () {
          this.addSphereMesh = function () {
            var sphere = new Physijs.SphereMesh(
              new THREE.SphereGeometry(3, 20),
              getMaterial()
            )
            setPosAndShade(sphere)
            meshes.push(sphere)
            scene.add(sphere)
          }
          this.addBoxMesh = function () {
            var cube = new Physijs.BoxMesh(
              new THREE.BoxGeometry(4, 2, 6),
              getMaterial()
            )
            setPosAndShade(cube)

            meshes.push(cube)
            scene.add(cube)
          }

          this.addCylinderMesh = function () {
            var cylinder = new Physijs.CylinderMesh(
              new THREE.CylinderGeometry(2, 2, 6),
              getMaterial()
            )
            setPosAndShade(cylinder)

            meshes.push(cylinder)
            scene.add(cylinder)
          }
          this.addConeMesh = function () {
            var cone = new Physijs.ConeMesh(
              new THREE.CylinderGeometry(0, 3, 7, 20, 10),
              getMaterial()
            )
            setPosAndShade(cone)

            meshes.push(cone)
            scene.add(cone)
          }
          this.addPlaneMesh = function () {
            var plane = new Physijs.PlaneMesh(
              new THREE.PlaneGeometry(5, 5, 10, 10),
              getMaterial()
            )
            setPosAndShade(plane)

            meshes.push(plane)
            scene.add(plane)
          }
          this.addCapsuleMesh = function () {
            var merged = new THREE.Geometry()
            var cyl = new THREE.CylinderGeometry(2, 2, 6)
            var top = new THREE.SphereGeometry(2)
            var bot = new THREE.SphereGeometry(2)

            var matrix = new THREE.Matrix4()
            matrix.makeTranslation(0, 3, 0)
            top.applyMatrix(matrix)

            var matrix = new THREE.Matrix4()
            matrix.makeTranslation(0, -3, 0)
            bot.applyMatrix(matrix)

            // merge to create a capsule
            merged.merge(top)
            merged.merge(bot)
            merged.merge(cyl)

            // create a physijs capsule mesh
            var capsule = new Physijs.CapsuleMesh(merged, getMaterial())
            setPosAndShade(capsule)

            meshes.push(capsule)
            scene.add(capsule)
          }
          this.addConvexMesh = function () {
            var convex = new Physijs.ConvexMesh(
              new THREE.TorusKnotGeometry(0.5, 0.3, 64, 8, 2, 3, 10),
              getMaterial()
            )

            setPosAndShade(convex)

            meshes.push(convex)
            scene.add(convex)
          }

          this.clearMeshes = function () {
            meshes.forEach(function (e) {
              scene.remove(e)
            })
            meshes = []
          }
        })()

        var gui = new dat.GUI()
        gui.add(controls, "addPlaneMesh")
        gui.add(controls, "addBoxMesh")
        gui.add(controls, "addSphereMesh")
        gui.add(controls, "addCylinderMesh")
        gui.add(controls, "addConeMesh")
        gui.add(controls, "addCapsuleMesh")
        gui.add(controls, "addConvexMesh")
        gui.add(controls, "clearMeshes")

        var date = new Date()
        var pn = new Perlin("rnd" + date.getTime())
        var map = createHeightMap(pn)
        scene.add(map)

        requestAnimationFrame(render)
        scene.simulate()
      }

      function createHeightMap(pn) {
        var ground_material = Physijs.createMaterial(
          new THREE.MeshLambertMaterial({
            map: THREE.ImageUtils.loadTexture(
              "../assets/textures/ground/grasslight-big.jpg"
            ),
          }),
          0.3, // high friction
          0.8 // low restitution
        )

        var ground_geometry = new THREE.PlaneGeometry(120, 100, 100, 100)
        for (var i = 0; i < ground_geometry.vertices.length; i++) {
          var vertex = ground_geometry.vertices[i]
          var value = pn.noise(vertex.x / 10, vertex.y / 10, 0)
          vertex.z = value * 10
        }
        ground_geometry.computeFaceNormals()
        ground_geometry.computeVertexNormals()

        var ground = new Physijs.HeightfieldMesh(
          ground_geometry,
          ground_material,
          0, // mass
          100,
          100
        )
        ground.rotation.x = Math.PI / -2
        ground.rotation.y = 0.4
        ground.receiveShadow = true

        return ground
      }

      function createShape() {
        // add 10 random spheres
        var points = []
        for (var i = 0; i < 30; i++) {
          var randomX = -5 + Math.round(Math.random() * 10)
          var randomY = -5 + Math.round(Math.random() * 10)
          var randomZ = -5 + Math.round(Math.random() * 10)

          points.push(new THREE.Vector3(randomX, randomY, randomZ))
        }

        // use the same points to create a convexgeometry
        var hullGeometry = new THREE.ConvexGeometry(points)
        return hullGeometry
      }

      function setPosAndShade(obj) {
        obj.position.set(Math.random() * 20 - 45, 40, Math.random() * 20 - 5)

        obj.rotation.set(
          Math.random() * 2 * Math.PI,
          Math.random() * 2 * Math.PI,
          Math.random() * 2 * Math.PI
        )
        obj.castShadow = true
      }

      function getMaterial() {
        var material = Physijs.createMaterial(
          new THREE.MeshLambertMaterial({
            color: scale(Math.random()).hex(),
            //                                opacity: 0.8,
            //                                transparent: true
          }),
          0.5,
          0.7
        )

        return material
      }

      function createGround() {
        var length = 120
        var width = 120
        // Materials
        ground_material = Physijs.createMaterial(
          new THREE.MeshPhongMaterial({
            //                                color: 0xaaaaaa,
            map: THREE.ImageUtils.loadTexture(
              "../assets/textures/general/floor-wood.jpg"
            ),
          }),
          1, // high friction
          0.7 // low restitution
        )

        // Ground
        ground = new Physijs.BoxMesh(
          new THREE.BoxGeometry(length, 1, width),
          ground_material,
          0 // mass
        )

        ground.receiveShadow = true

        var borderLeft = new Physijs.BoxMesh(
          new THREE.BoxGeometry(2, 6, width),
          ground_material,
          0 // mass
        )

        borderLeft.position.x = (-1 * length) / 2 - 1
        borderLeft.position.y = 2
        borderLeft.receiveShadow = true

        ground.add(borderLeft)

        var borderRight = new Physijs.BoxMesh(
          new THREE.BoxGeometry(2, 6, width),
          ground_material,
          0 // mass
        )
        borderRight.position.x = length / 2 + 1
        borderRight.position.y = 2
        borderRight.receiveShadow = true

        ground.add(borderRight)

        var borderBottom = new Physijs.BoxMesh(
          new THREE.BoxGeometry(width - 1, 6, 2),
          ground_material,
          0 // mass
        )

        borderBottom.position.z = width / 2
        borderBottom.position.y = 1.5
        borderBottom.receiveShadow = true
        ground.add(borderBottom)

        var borderTop = new Physijs.BoxMesh(
          new THREE.BoxGeometry(width, 6, 2),
          ground_material,
          0 // mass
        )

        borderTop.position.z = -width / 2
        borderTop.position.y = 2

        borderTop.receiveShadow = true

        ground.position.x = 0
        ground.position.z = 0
        ground.add(borderTop)

        ground.receiveShadow = true

        scene.add(ground)
      }

      render = function () {
        requestAnimationFrame(render)
        renderer.render(scene, camera)
        render_stats.update()
        scene.simulate(undefined, 2)
      }
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 4.constraints

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      Physijs.scripts.worker = "../libs/physijs_worker.js"
      Physijs.scripts.ammo = "../libs/ammo.js"

      var scale = chroma.scale(["white", "blue", "red", "yellow"])

      var initScene,
        render,
        applyForce,
        setMousePosition,
        mouse_position,
        ground_material,
        box_material,
        projector,
        renderer,
        render_stats,
        physics_stats,
        scene,
        ground,
        light,
        camera,
        box,
        boxes = []

      initScene = function () {
        projector = new THREE.Projector()

        renderer = new THREE.WebGLRenderer({ antialias: true })
        renderer.setSize(window.innerWidth, window.innerHeight)

        renderer.setClearColor(new THREE.Color(0x000000))
        renderer.shadowMapEnabled = true

        document.getElementById("viewport").appendChild(renderer.domElement)

        render_stats = new Stats()
        render_stats.domElement.style.position = "absolute"
        render_stats.domElement.style.top = "1px"
        render_stats.domElement.style.right = "1px"
        render_stats.domElement.style.zIndex = 100
        document.getElementById("viewport").appendChild(render_stats.domElement)

        scene = new Physijs.Scene({ reportSize: 10, fixedTimeStep: 1 / 60 })

        scene.setGravity(new THREE.Vector3(0, -10, 0))

        camera = new THREE.PerspectiveCamera(
          35,
          window.innerWidth / window.innerHeight,
          1,
          1000
        )
        camera.position.set(85, 65, 65)
        camera.lookAt(new THREE.Vector3(0, 0, 0))
        scene.add(camera)

        // Light
        light = new THREE.SpotLight(0xffffff)
        light.position.set(20, 50, 50)
        light.castShadow = true
        light.shadowMapDebug = true
        light.shadowCameraNear = 10
        light.shadowCameraFar = 100

        scene.add(light)

        var meshes = []

        createGround()
        var flipperLeftConstraint = createLeftFlipper()
        var flipperRightConstraint = createRightFlipper()
        var sliderBottomConstraint = createSliderBottom()
        var sliderTopConstraint = createSliderTop()
        var coneTwistConstraint = createConeTwist()

        var point2point = createPointToPoint(true)

        var controls = new (function () {
          this.enableMotor = false
          this.acceleration = 2
          this.velocity = -10

          this.enableConeTwistMotor = false
          this.motorTargetX = 0
          this.motorTargetY = 0
          this.motorTargetZ = 0

          this.updateCone = function () {
            if (controls.enableConeTwistMotor) {
              coneTwistConstraint.enableMotor()
              coneTwistConstraint.setMotorTarget(
                new THREE.Vector3(
                  controls.motorTargetX,
                  controls.motorTargetY,
                  controls.motorTargetZ
                )
              )
            } else {
              coneTwistConstraint.disableMotor()
            }
          }

          this.updateMotor = function () {
            if (controls.enableMotor) {
              // velocity is the velocity we are going for.
              // acceleration is how fast we're going to reach it
              flipperLeftConstraint.disableMotor()
              flipperLeftConstraint.enableAngularMotor(
                controls.velocity,
                controls.acceleration
              )
              flipperRightConstraint.disableMotor()
              flipperRightConstraint.enableAngularMotor(
                -1 * controls.velocity,
                controls.acceleration
              )
            } else {
              flipperLeftConstraint.disableMotor()
              flipperRightConstraint.disableMotor()
            }
          }

          this.sliderLeft = function () {
            sliderBottomConstraint.disableLinearMotor()
            sliderBottomConstraint.enableLinearMotor(
              controls.velocity,
              controls.acceleration
            )
            sliderTopConstraint.disableLinearMotor()
            sliderTopConstraint.enableLinearMotor(
              controls.velocity,
              controls.acceleration
            )
          }

          this.sliderRight = function () {
            sliderBottomConstraint.disableLinearMotor()
            sliderBottomConstraint.enableLinearMotor(
              -1 * controls.velocity,
              controls.acceleration
            )
            sliderTopConstraint.disableLinearMotor()
            sliderTopConstraint.enableLinearMotor(
              -1 * controls.velocity,
              controls.acceleration
            )
          }

          this.clearMeshes = function () {
            meshes.forEach(function (e) {
              scene.remove(e)
            })
            meshes = []
          }

          this.addSpheres = function () {
            var colorSphere = scale(Math.random()).hex()
            for (var i = 0; i < 5; i++) {
              box = new Physijs.SphereMesh(
                new THREE.SphereGeometry(2, 20),
                Physijs.createMaterial(
                  new THREE.MeshPhongMaterial({
                    color: colorSphere,
                    opacity: 0.8,
                    transparent: true,
                    //                                                        map: THREE.ImageUtils.loadTexture( '../assets/textures/general/floor-wood.jpg' )
                  }),
                  controls.sphereFriction,
                  controls.sphereRestitution
                ),
                0.1
              )
              box.castShadow = true
              box.receiveShadow = true
              box.position.set(
                Math.random() * 50 - 25,
                20 + Math.random() * 5,
                Math.random() * 5
              )
              meshes.push(box)
              scene.add(box)
            }
          }
        })()

        controls.updateMotor()

        var gui = new dat.GUI()
        gui.domElement.style.position = "absolute"
        gui.domElement.style.top = "20px"
        gui.domElement.style.left = "20px"

        var generalFolder = gui.addFolder("general")
        generalFolder
          .add(controls, "acceleration", 0, 15)
          .onChange(controls.updateMotor)
        generalFolder
          .add(controls, "velocity", -10, 10)
          .onChange(controls.updateMotor)

        var hingeFolder = gui.addFolder("hinge")
        hingeFolder.add(controls, "enableMotor").onChange(controls.updateMotor)

        var sliderFolder = gui.addFolder("sliders")
        sliderFolder.add(controls, "sliderLeft").onChange(controls.sliderLeft)
        sliderFolder.add(controls, "sliderRight").onChange(controls.sliderRight)

        var coneTwistFolder = gui.addFolder("coneTwist")
        coneTwistFolder
          .add(controls, "enableConeTwistMotor")
          .onChange(controls.updateCone)
        coneTwistFolder
          .add(controls, "motorTargetX", -Math.PI / 2, Math.PI / 2)
          .onChange(controls.updateCone)
        coneTwistFolder
          .add(controls, "motorTargetY", -Math.PI / 2, Math.PI / 2)
          .onChange(controls.updateCone)
        coneTwistFolder
          .add(controls, "motorTargetZ", -Math.PI / 2, Math.PI / 2)
          .onChange(controls.updateCone)

        var spheresFolder = gui.addFolder("spheres")
        spheresFolder
          .add(controls, "clearMeshes")
          .onChange(controls.updateMotor)
        spheresFolder.add(controls, "addSpheres").onChange(controls.updateMotor)

        requestAnimationFrame(render)
        scene.simulate()
      }

      function createGround() {
        // Materials
        ground_material = Physijs.createMaterial(
          new THREE.MeshPhongMaterial({
            //                                color: 0xaaaaaa,
            map: THREE.ImageUtils.loadTexture(
              "../assets/textures/general/floor-wood.jpg"
            ),
          }),
          0.9, // high friction
          0.7 // low restitution
        )

        // Ground
        ground = new Physijs.BoxMesh(
          new THREE.BoxGeometry(60, 1, 65),
          ground_material,
          0 // mass
        )

        ground.receiveShadow = true

        var borderLeft = new Physijs.BoxMesh(
          new THREE.BoxGeometry(2, 6, 65),
          ground_material,
          0 // mass
        )

        borderLeft.position.x = -31
        borderLeft.position.y = 2
        borderLeft.receiveShadow = true

        ground.add(borderLeft)

        var borderRight = new Physijs.BoxMesh(
          new THREE.BoxGeometry(2, 6, 65),
          ground_material,
          0 // mass
        )
        borderRight.position.x = 31
        borderRight.position.y = 2
        borderRight.receiveShadow = true

        ground.add(borderRight)

        var borderBottom = new Physijs.BoxMesh(
          new THREE.BoxGeometry(64, 6, 2),
          ground_material,
          0 // mass
        )

        borderBottom.position.z = 32
        borderBottom.position.y = 1.5
        borderBottom.receiveShadow = true
        ground.add(borderBottom)

        var borderTop = new Physijs.BoxMesh(
          new THREE.BoxGeometry(64, 6, 2),
          ground_material,
          0 // mass
        )

        borderTop.position.z = -32
        borderTop.position.y = 2
        borderTop.receiveShadow = true

        ground.add(borderTop)

        ground.receiveShadow = true

        scene.add(ground)
      }

      function createConeTwist() {
        var baseMesh = new THREE.SphereGeometry(1)
        var armMesh = new THREE.BoxGeometry(2, 12, 3)

        var objectOne = new Physijs.BoxMesh(
          baseMesh,
          Physijs.createMaterial(
            new THREE.MeshPhongMaterial({
              color: 0x4444ff,
              transparent: true,
              opacity: 0.7,
            }),
            0,
            0
          ),
          0
        )
        objectOne.position.z = 0
        objectOne.position.x = 20
        objectOne.position.y = 15.5
        objectOne.castShadow = true
        scene.add(objectOne)

        var objectTwo = new Physijs.SphereMesh(
          armMesh,
          Physijs.createMaterial(
            new THREE.MeshPhongMaterial({
              color: 0x4444ff,
              transparent: true,
              opacity: 0.7,
            }),
            0,
            0
          ),
          10
        )
        objectTwo.position.z = 0
        objectTwo.position.x = 20
        objectTwo.position.y = 7.5
        scene.add(objectTwo)

        objectTwo.castShadow = true

        //position is the position of the axis, relative to the ref, based on the current position
        var constraint = new Physijs.ConeTwistConstraint(
          objectOne,
          objectTwo,
          objectOne.position
        )

        scene.addConstraint(constraint)
        // set limit to quarter circle for each axis
        constraint.setLimit(0.5 * Math.PI, 0.5 * Math.PI, 0.5 * Math.PI)
        constraint.setMaxMotorImpulse(1)
        constraint.setMotorTarget(new THREE.Vector3(0, 0, 0)) // desired rotation

        return constraint
      }

      function createPointToPoint() {
        var obj1 = new THREE.SphereGeometry(2)
        var obj2 = new THREE.SphereGeometry(2)

        var objectOne = new Physijs.SphereMesh(
          obj1,
          Physijs.createMaterial(
            new THREE.MeshPhongMaterial({
              color: 0xff4444,
              transparent: true,
              opacity: 0.7,
            }),
            0,
            0
          )
        )
        objectOne.position.z = -18
        objectOne.position.x = -10
        objectOne.position.y = 2
        objectOne.castShadow = true
        scene.add(objectOne)

        var objectTwo = new Physijs.SphereMesh(
          obj2,
          Physijs.createMaterial(
            new THREE.MeshPhongMaterial({
              color: 0xff4444,
              transparent: true,
              opacity: 0.7,
            }),
            0,
            0
          )
        )
        objectTwo.position.z = -5
        objectTwo.position.x = -20
        objectTwo.position.y = 2
        objectTwo.castShadow = true
        scene.add(objectTwo)

        // if no position two, its fixed to a position. Else fixed to objectTwo and both will move
        var constraint = new Physijs.PointConstraint(
          objectOne,
          objectTwo,
          objectTwo.position
        )
        scene.addConstraint(constraint)
      }

      function createSliderBottom() {
        var sliderCube = new THREE.BoxGeometry(12, 2, 2)

        var sliderMesh = new Physijs.BoxMesh(
          sliderCube,
          Physijs.createMaterial(
            new THREE.MeshPhongMaterial({
              color: 0x44ff44,
              opacity: 0.6,
              transparent: true,
            }),
            0,
            0
          ),
          0.01
        )
        sliderMesh.position.z = 20
        sliderMesh.position.x = 6
        sliderMesh.position.y = 1.5
        sliderMesh.castShadow = true

        scene.add(sliderMesh)
        var constraint = new Physijs.SliderConstraint(
          sliderMesh,
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(0, 1, 0)
        )

        scene.addConstraint(constraint)
        constraint.setLimits(-10, 10, 0, 0)
        constraint.setRestitution(0.1, 0.1)

        return constraint
      }

      function createSliderTop() {
        var sliderSphere = new THREE.BoxGeometry(7, 2, 7)

        var sliderMesh = new Physijs.BoxMesh(
          sliderSphere,
          Physijs.createMaterial(
            new THREE.MeshPhongMaterial({
              color: 0x44ff44,
              transparent: true,
              opacity: 0.5,
            }),
            0,
            0
          ),
          10
        )
        sliderMesh.position.z = -15
        sliderMesh.position.x = -20
        sliderMesh.position.y = 1.5
        scene.add(sliderMesh)
        sliderMesh.castShadow = true

        //position is the position of the axis, relative to the ref, based on the current position
        var constraint = new Physijs.SliderConstraint(
          sliderMesh,
          new THREE.Vector3(-10, 0, 20),
          new THREE.Vector3(Math.PI / 2, 0, 0)
        )

        scene.addConstraint(constraint)
        constraint.setLimits(-20, 10, 0.5, -0, 5)
        constraint.setRestitution(0.2, 0.1)

        return constraint
      }

      function createLeftFlipper() {
        var flipperLeft = new Physijs.BoxMesh(
          new THREE.BoxGeometry(12, 2, 2),
          Physijs.createMaterial(
            new THREE.MeshPhongMaterial({ opacity: 0.6, transparent: true })
          ),
          0.3
        )
        flipperLeft.position.x = -6
        flipperLeft.position.y = 2
        flipperLeft.position.z = 0
        flipperLeft.castShadow = true
        scene.add(flipperLeft)
        var flipperLeftPivot = new Physijs.SphereMesh(
          new THREE.BoxGeometry(1, 1, 1),
          ground_material,
          0
        )

        flipperLeftPivot.position.y = 1
        flipperLeftPivot.position.x = -15
        flipperLeftPivot.position.z = 0
        flipperLeftPivot.rotation.y = 1.4
        flipperLeftPivot.castShadow = true

        scene.add(flipperLeftPivot)

        // when looking at the axis, the axis of object two are used.
        // so as long as that one is the same as the scene, no problems
        // rotation and axis are relative to object2. If position == cube2.position it works as expected
        var constraint = new Physijs.HingeConstraint(
          flipperLeft,
          flipperLeftPivot,
          flipperLeftPivot.position,
          new THREE.Vector3(0, 1, 0)
        )
        scene.addConstraint(constraint)

        constraint.setLimits(
          -2.2, // minimum angle of motion, in radians, from the point object 1 starts (going back)
          -0.6, // maximum angle of motion, in radians, from the point object 1 starts (going forward)
          0.1, // applied as a factor to constraint error, how big the kantelpunt is moved when a constraint is hit
          0 // controls bounce at limit (0.0 == no bounce)
        )

        return constraint
      }

      function createRightFlipper() {
        var flipperright = new Physijs.BoxMesh(
          new THREE.BoxGeometry(12, 2, 2),
          Physijs.createMaterial(
            new THREE.MeshPhongMaterial({ opacity: 0.6, transparent: true })
          ),
          0.3
        )
        flipperright.position.x = 8
        flipperright.position.y = 2
        flipperright.position.z = 0
        flipperright.castShadow = true
        scene.add(flipperright)
        var flipperLeftPivot = new Physijs.SphereMesh(
          new THREE.BoxGeometry(1, 1, 1),
          ground_material,
          0
        )

        flipperLeftPivot.position.y = 2
        flipperLeftPivot.position.x = 15
        flipperLeftPivot.position.z = 0
        flipperLeftPivot.rotation.y = 1.4
        flipperLeftPivot.castShadow = true

        scene.add(flipperLeftPivot)

        // when looking at the axis, the axis of object two are used.
        // so as long as that one is the same as the scene, no problems
        // rotation and axis are relative to object2. If position == cube2.position it works as expected
        var constraint = new Physijs.HingeConstraint(
          flipperright,
          flipperLeftPivot,
          flipperLeftPivot.position,
          new THREE.Vector3(0, 1, 0)
        )
        //            var constraint = new Physijs.HingeConstraint(cube1, new THREE.Vector3(0,0,0), new THREE.Vector3(0,1,0));
        scene.addConstraint(constraint)

        constraint.setLimits(
          -2.2, // minimum angle of motion, in radians, from the point object 1 starts (going back)
          -0.6, // maximum angle of motion, in radians, from the point object 1 starts (going forward)
          0.1, // applied as a factor to constraint error, how big the kantelpunt is moved when a constraint is hit
          0 // controls bounce at limit (0.0 == no bounce)
        )

        return constraint
      }

      var direction = 1

      render = function () {
        requestAnimationFrame(render)
        renderer.render(scene, camera)
        render_stats.update()
        ground.__dirtyRotation = true
        scene.simulate(undefined, 2)
      }
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 5.dof-constraint

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      Physijs.scripts.worker = "../libs/physijs_worker.js"
      Physijs.scripts.ammo = "../libs/ammo.js"

      var scale = chroma.scale(["white", "blue", "red", "yellow"])

      var initScene,
        render,
        applyForce,
        setMousePosition,
        mouse_position,
        ground_material,
        box_material,
        projector,
        renderer,
        render_stats,
        physics_stats,
        scene,
        ground,
        light,
        camera,
        box,
        boxes = []

      initScene = function () {
        renderer = new THREE.WebGLRenderer({ antialias: true })
        renderer.setSize(window.innerWidth, window.innerHeight)

        renderer.setClearColor(new THREE.Color(0x000000))
        renderer.shadowMapEnabled = true

        document.getElementById("viewport").appendChild(renderer.domElement)

        render_stats = new Stats()
        render_stats.domElement.style.position = "absolute"
        render_stats.domElement.style.top = "1px"
        render_stats.domElement.style.left = "1px"
        render_stats.domElement.style.zIndex = 100
        document.getElementById("viewport").appendChild(render_stats.domElement)

        scene = new Physijs.Scene({ reportSize: 10, fixedTimeStep: 1 / 60 })

        scene.setGravity(new THREE.Vector3(0, -40, 0))

        camera = new THREE.PerspectiveCamera(
          35,
          window.innerWidth / window.innerHeight,
          1,
          1000
        )
        camera.position.set(90, 90, 90)
        camera.lookAt(new THREE.Vector3(30, 0, -20))
        scene.add(camera)

        // Light
        light = new THREE.SpotLight(0xffffff)
        light.position.set(120, 70, 100)
        light.castShadow = true
        light.shadowMapDebug = true
        light.shadowCameraNear = 10
        light.shadowCameraFar = 200

        scene.add(light)

        var meshes = []

        createGround()
        var car = createCar()

        var controls = new (function () {
          this.velocity = -2
          this.wheelAngle = 0.5

          this.loosenXRight = 0.0001
          this.loosenXLeft = 0.0001

          this.changeVelocity = function () {
            // if you add a motor, the current constraint is overridden
            // if you want to rotate set min higher then max
            car.flConstraint.configureAngularMotor(
              2,
              0.1,
              0,
              controls.velocity,
              15000
            )
            car.frConstraint.configureAngularMotor(
              2,
              0.1,
              0,
              controls.velocity,
              15000
            )

            // motor one is for left and right
            //                frConstraint.enableAngularMotor(1);

            // motor two is forward and backwards
            car.flConstraint.enableAngularMotor(2)
            car.frConstraint.enableAngularMotor(2)
          }

          this.changeOrientation = function () {
            car.rrConstraint.setAngularLowerLimit({
              x: 0,
              y: controls.wheelAngle,
              z: 0.1,
            })
            car.rrConstraint.setAngularUpperLimit({
              x: controls.loosenXRight,
              y: controls.wheelAngle,
              z: 0,
            })
            car.rlConstraint.setAngularLowerLimit({
              x: controls.loosenXLeft,
              y: controls.wheelAngle,
              z: 0.1,
            })
            car.rlConstraint.setAngularUpperLimit({
              x: 0,
              y: controls.wheelAngle,
              z: 0,
            })
          }
        })()

        var gui = new dat.GUI()
        gui.add(controls, "velocity", -10, 10).onChange(controls.changeVelocity)
        gui
          .add(controls, "wheelAngle", -1, 1)
          .onChange(controls.changeOrientation)
        gui
          .add(controls, "loosenXRight", 0, 0.5)
          .step(0.01)
          .onChange(controls.changeOrientation)
        gui
          .add(controls, "loosenXLeft", 0, 0.6)
          .step(-0.01)
          .onChange(controls.changeOrientation)
        controls.loosenXLeft = 0
        controls.loosenXRight = 0

        requestAnimationFrame(render)
        scene.simulate()
      }

      function createWheel(position) {
        var wheel_material = Physijs.createMaterial(
          new THREE.MeshLambertMaterial({
            color: 0x444444,
            opacity: 0.9,
            transparent: true,
          }),
          1.0, // high friction
          0.5 // medium restitution
        )

        var wheel_geometry = new THREE.CylinderGeometry(4, 4, 2, 10)
        var wheel = new Physijs.CylinderMesh(
          wheel_geometry,
          wheel_material,
          100
        )

        wheel.rotation.x = Math.PI / 2
        wheel.castShadow = true
        wheel.position.copy(position)
        return wheel
      }

      function createCar() {
        var car = {}
        var car_material = Physijs.createMaterial(
          new THREE.MeshLambertMaterial({
            color: 0xff4444,
            opacity: 0.9,
            transparent: true,
          }),
          0.5, // high friction
          0.5 // medium restitution
        )

        // create the car body
        var geom = new THREE.BoxGeometry(15, 4, 4)
        var body = new Physijs.BoxMesh(geom, car_material, 500)
        body.position.set(5, 5, 5)
        body.castShadow = true
        scene.add(body)

        // create the wheels
        var fr = createWheel(new THREE.Vector3(0, 4, 10))
        var fl = createWheel(new THREE.Vector3(0, 4, 0))
        var rr = createWheel(new THREE.Vector3(10, 4, 10))
        var rl = createWheel(new THREE.Vector3(10, 4, 0))

        // add the wheels to the scene
        scene.add(fr)
        scene.add(fl)
        scene.add(rr)
        scene.add(rl)

        var frConstraint = createWheelConstraint(
          fr,
          body,
          new THREE.Vector3(0, 4, 8)
        )
        scene.addConstraint(frConstraint)

        var flConstraint = createWheelConstraint(
          fl,
          body,
          new THREE.Vector3(0, 4, 2)
        )
        scene.addConstraint(flConstraint)

        var rrConstraint = createWheelConstraint(
          rr,
          body,
          new THREE.Vector3(10, 4, 8)
        )
        scene.addConstraint(rrConstraint)

        var rlConstraint = createWheelConstraint(
          rl,
          body,
          new THREE.Vector3(10, 4, 2)
        )
        scene.addConstraint(rlConstraint)

        // backwheels don't move themselves and are restriced in their
        // movement. They should be able to rotate along the z-axis
        // same here, if the complete angle is allowed set lower higher
        // than upper.
        // by setting the lower and upper to the same value you can
        // fix the position
        // we can set the x position to 'loosen' the axis for the directional
        rrConstraint.setAngularLowerLimit({ x: 0, y: 0.5, z: 0.1 })
        rrConstraint.setAngularUpperLimit({ x: 0, y: 0.5, z: 0 })
        rlConstraint.setAngularLowerLimit({ x: 0, y: 0.5, z: 0.1 })
        rlConstraint.setAngularUpperLimit({ x: 0, y: 0.5, z: 0 })

        // front wheels should only move along the z axis.
        // we don't need to specify anything here, since
        // that value is overridden by the motors
        frConstraint.setAngularLowerLimit({ x: 0, y: 0, z: 0 })
        frConstraint.setAngularUpperLimit({ x: 0, y: 0, z: 0 })
        flConstraint.setAngularLowerLimit({ x: 0, y: 0, z: 0 })
        flConstraint.setAngularUpperLimit({ x: 0, y: 0, z: 0 })

        // if you add a motor, the current constraint is overridden
        // if you want to rotate set min higher then max
        flConstraint.configureAngularMotor(2, 0.1, 0, -2, 1500)
        frConstraint.configureAngularMotor(2, 0.1, 0, -2, 1500)

        // motor one is for left and right
        //                frConstraint.enableAngularMotor(1);

        // motor two is forward and backwards
        flConstraint.enableAngularMotor(2)
        frConstraint.enableAngularMotor(2)

        car.flConstraint = flConstraint
        car.frConstraint = frConstraint
        car.rlConstraint = rlConstraint
        car.rrConstraint = rrConstraint

        return car
      }

      function createWheelConstraint(wheel, body, position) {
        var constraint = new Physijs.DOFConstraint(wheel, body, position)

        return constraint
      }

      function createGround() {
        var length = 120
        var width = 120
        // Materials
        ground_material = Physijs.createMaterial(
          new THREE.MeshPhongMaterial({
            //                                color: 0xaaaaaa,
            map: THREE.ImageUtils.loadTexture(
              "../assets/textures/general/floor-wood.jpg"
            ),
          }),
          1, // high friction
          0.7 // low restitution
        )

        // Ground
        ground = new Physijs.BoxMesh(
          new THREE.BoxGeometry(length, 1, width),
          ground_material,
          0 // mass
        )

        ground.receiveShadow = true

        var borderLeft = new Physijs.BoxMesh(
          new THREE.BoxGeometry(2, 6, width),
          ground_material,
          0 // mass
        )

        borderLeft.position.x = (-1 * length) / 2 - 1
        borderLeft.position.y = 2
        borderLeft.receiveShadow = true

        ground.add(borderLeft)

        var borderRight = new Physijs.BoxMesh(
          new THREE.BoxGeometry(2, 6, width),
          ground_material,
          0 // mass
        )
        borderRight.position.x = length / 2 + 1
        borderRight.position.y = 2
        borderRight.receiveShadow = true

        ground.add(borderRight)

        var borderBottom = new Physijs.BoxMesh(
          new THREE.BoxGeometry(width - 1, 6, 2),
          ground_material,
          0 // mass
        )

        borderBottom.position.z = width / 2
        borderBottom.position.y = 1.5
        borderBottom.receiveShadow = true
        ground.add(borderBottom)

        var borderTop = new Physijs.BoxMesh(
          new THREE.BoxGeometry(width, 6, 2),
          ground_material,
          0 // mass
        )

        borderTop.position.z = -width / 2
        borderTop.position.y = 2

        borderTop.receiveShadow = true

        ground.position.x = 20
        ground.position.z = -20
        ground.add(borderTop)

        ground.receiveShadow = true

        scene.add(ground)
      }

      render = function () {
        requestAnimationFrame(render)
        renderer.render(scene, camera)
        render_stats.update()
        scene.simulate(undefined, 2)
      }
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 6.audio

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      var container
      var camera, controls, scene, renderer
      var light, pointLight

      var mesh
      var material_sphere1, material_sphere2

      var clock = new THREE.Clock()

      init()
      animate()

      function init() {
        container = document.getElementById("container")

        camera = new THREE.PerspectiveCamera(
          50,
          window.innerWidth / window.innerHeight,
          1,
          10000
        )
        camera.position.set(-200, 25, 0)

        var listener1 = new THREE.AudioListener()
        camera.add(listener1)
        var listener2 = new THREE.AudioListener()
        camera.add(listener2)
        var listener3 = new THREE.AudioListener()
        camera.add(listener3)

        controls = new THREE.FirstPersonControls(camera)

        controls.movementSpeed = 70
        controls.lookSpeed = 0.15
        controls.noFly = true
        controls.lookVertical = false

        scene = new THREE.Scene()
        scene.fog = new THREE.FogExp2(0x000000, 0.0035)

        light = new THREE.DirectionalLight(0xffffff)
        light.position.set(0, 0.5, 1).normalize()
        scene.add(light)

        var cube = new THREE.BoxGeometry(40, 40, 40)

        var material_1 = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          map: THREE.ImageUtils.loadTexture(
            "../assets/textures/animals/cow.png"
          ),
        })

        var material_2 = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          map: THREE.ImageUtils.loadTexture(
            "../assets/textures/animals/dog.jpg"
          ),
        })

        var material_3 = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          map: THREE.ImageUtils.loadTexture(
            "../assets/textures/animals/cat.jpg"
          ),
        })

        // sound spheres

        var mesh1 = new THREE.Mesh(cube, material_1)
        mesh1.position.set(0, 20, 100)
        var mesh2 = new THREE.Mesh(cube, material_2)
        mesh2.position.set(0, 20, 0)
        var mesh3 = new THREE.Mesh(cube, material_3)
        mesh3.position.set(0, 20, -100)

        scene.add(mesh1)
        scene.add(mesh2)
        scene.add(mesh3)

        var sound1 = new THREE.Audio(listener1)
        sound1.load("../assets/audio/cow.ogg")
        sound1.setRefDistance(20)
        sound1.setLoop(true)
        sound1.setRolloffFactor(2)
        mesh1.add(sound1)

        var sound2 = new THREE.Audio(listener2)
        sound2.load("../assets/audio/dog.ogg")
        sound2.setRefDistance(20)
        sound2.setLoop(true)
        sound2.setRolloffFactor(2)
        mesh2.add(sound2)

        var sound3 = new THREE.Audio(listener3)
        sound3.load("../assets/audio/cat.ogg")
        sound3.setRefDistance(20)
        sound3.setLoop(true)
        sound3.setRolloffFactor(2)
        mesh3.add(sound3)

        // ground

        var helper = new THREE.GridHelper(500, 10)
        helper.color1.setHex(0x444444)
        helper.color2.setHex(0x444444)
        helper.position.y = 0.1
        scene.add(helper)

        //

        renderer = new THREE.WebGLRenderer({ antialias: true })
        renderer.setSize(window.innerWidth, window.innerHeight)

        container.innerHTML = ""
        container.appendChild(renderer.domElement)

        //

        window.addEventListener("resize", onWindowResize, false)
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight
        camera.updateProjectionMatrix()

        renderer.setSize(window.innerWidth, window.innerHeight)

        controls.handleResize()
      }

      function animate() {
        requestAnimationFrame(animate)
        render()
      }

      function render() {
        var delta = clock.getDelta(),
          time = clock.getElapsedTime() * 5

        controls.update(delta)

        //        material_sphere1.color.setHSL( 0.0, 0.3 + 0.7 * ( 1 + Math.cos( time ) ) / 2, 0.5 );
        //        material_sphere2.color.setHSL( 0.1, 0.3 + 0.7 * ( 1 + Math.sin( time ) ) / 2, 0.5 );

        renderer.render(scene, camera)
      }
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::

## 7.hinge

:::demo

```vue
<template>
  <div style="position:relative">
    <div ref="webgl"></div>
    <div style="position:absolute;right:0" ref="gui"></div>
    <div ref="example"></div>
  </div>
</template>

<script>
export default {
  methods: {
    init() {
      Physijs.scripts.worker = "../libs/physijs_worker.js"
      Physijs.scripts.ammo = "../libs/ammo.js"

      var initScene,
        render,
        projector,
        renderer,
        render_stats,
        physics_stats,
        scene,
        light,
        camera

      initScene = function () {
        projector = new THREE.Projector()

        renderer = new THREE.WebGLRenderer({ antialias: true })
        renderer.setSize(window.innerWidth, window.innerHeight)
        renderer.shadowMapEnabled = true
        renderer.shadowMapSoft = true
        document.getElementById("viewport").appendChild(renderer.domElement)

        render_stats = new Stats()
        render_stats.domElement.style.position = "absolute"
        render_stats.domElement.style.top = "1px"
        render_stats.domElement.style.zIndex = 100
        document.getElementById("viewport").appendChild(render_stats.domElement)

        physics_stats = new Stats()
        physics_stats.domElement.style.position = "absolute"
        physics_stats.domElement.style.top = "50px"
        physics_stats.domElement.style.zIndex = 100
        document
          .getElementById("viewport")
          .appendChild(physics_stats.domElement)

        scene = new Physijs.Scene()
        scene.setGravity(new THREE.Vector3(0, -10, 0))
        scene.addEventListener("update", function () {
          physics_stats.update()
          setTimeout(function () {
            scene.simulate(undefined, 1)
          }, 50)
        })

        camera = new THREE.PerspectiveCamera(
          35,
          window.innerWidth / window.innerHeight,
          1,
          1000
        )
        camera.position.set(60, 50, 60)
        camera.lookAt(scene.position)
        scene.add(camera)

        // Light
        light = new THREE.DirectionalLight(0xffffff)
        light.position.set(20, 40, -15)
        light.target.position.copy(scene.position)
        light.castShadow = true
        light.shadowCameraLeft = -60
        light.shadowCameraTop = -60
        light.shadowCameraRight = 60
        light.shadowCameraBottom = 60
        light.shadowCameraNear = 20
        light.shadowCameraFar = 200
        light.shadowBias = -0.0001
        light.shadowMapWidth = light.shadowMapHeight = 2048
        light.shadowDarkness = 0.7
        scene.add(light)

        // Materials
        var ground_material = Physijs.createMaterial(
          new THREE.MeshLambertMaterial({
            map: THREE.ImageUtils.loadTexture("images/rocks.jpg"),
          }),
          0.8, // high friction
          0.4 // low restitution
        )
        ground_material.map.wrapS = ground_material.map.wrapT =
          THREE.RepeatWrapping
        ground_material.map.repeat.set(2.5, 2.5)

        // Ground
        var ground = new Physijs.BoxMesh(
          new THREE.BoxGeometry(50, 1, 50),
          //new THREE.PlaneGeometry(50, 50),
          ground_material,
          0 // mass
        )
        ground.receiveShadow = true
        scene.add(ground)

        var size = 3
        var mass = 1
        var NUM = 6
        var geometry = new THREE.BoxGeometry(size, size, size)
        for (var i = 0; i < NUM; i++) {
          var material1 = Physijs.createMaterial(
            new THREE.MeshLambertMaterial({ color: 0x992222 + i * 0x3333 }),
            0.1,
            0.1
          )
          var material2 = Physijs.createMaterial(
            new THREE.MeshLambertMaterial({
              color: 0x992222 + i * 0x3333,
              transparent: true,
              opacity: 0.7,
            }),
            0.1,
            0.1
          )
          var material3 = new THREE.MeshLambertMaterial({
            color: 0x992222 + i * 0x3333,
            transparent: true,
            opacity: 0.3,
          })

          var base = new Physijs.BoxMesh(geometry, material1, 0)
          base.add(new THREE.AxisHelper(size))

          var satellite = new Physijs.BoxMesh(geometry, material2, mass)
          base.position.set(size * 6 * (i - NUM / 2), size * i + size * 2, 0)
          satellite.add(new THREE.AxisHelper(size))

          satellite.position.copy(base.position)
          satellite.position.x += size * 2
          if (false) base.rotation.set((i * Math.PI) / 4, 0, 0)
          satellite.rotation.set(
            (i * Math.PI) / 7,
            (i * Math.PI) / 7,
            (-i * Math.PI) / 7
          )
          var ghost = new THREE.Mesh(geometry, material3)
          ghost.add(new THREE.AxisHelper(size))
          ghost.position.copy(satellite.position)
          ghost.rotation.copy(satellite.rotation)

          var position = base.position.clone()
          var axis = new THREE.Vector3(0, 1, 0)

          scene.add(base)
          scene.add(satellite)
          scene.add(ghost)

          var constraint = new Physijs.HingeConstraint(
            base,
            satellite,
            position,
            axis
          )
          scene.addConstraint(constraint)
          constraint.setLimits(1, 0)
          constraint.enableAngularMotor(3, 10000)
        }

        requestAnimationFrame(render)
        scene.simulate()
      }

      render = function () {
        renderer.render(scene, camera)
        render_stats.update()
        setTimeout(function () {
          requestAnimationFrame(render)
        }, 100)
      }
    },
  },
  mounted() {
    this.init()
  },
}
</script>
```

:::
